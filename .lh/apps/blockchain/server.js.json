{
    "sourceFile": "apps/blockchain/server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 46,
            "patches": [
                {
                    "date": 1761990495129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761992357735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,15 +129,16 @@\n \n // ----------------------\n // Halving-based reward\n // ----------------------\n-function getBlockReward(height) {\n+function getBlockReward(height, config) {\n   const interval = config.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n   const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n   return reward > 0 ? reward : 0;\n }\n \n+\n // ----------------------\n // Chain init\n // ----------------------\n function applyTxToUTXO(tx) {\n"
                },
                {
                    "date": 1761992494359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,121 +1,60 @@\n /**\n- * üß± Minimal Blockchain Full Node (Final)\n- * ------------------------------------------------------------\n- * - UTXO validation\n- * - Deterministic TX IDs\n+ * ‚õèÔ∏è Final Bitcoin-like Miner (Fully synced with server.js)\n+ * --------------------------------------------------------\n+ * - Real UTXO & mempool fee calculation\n+ * - Exact halving-based block reward (like node)\n  * - Numeric PoW: BigInt(hash) < target\n- * - Merkle root + canonical header hashing\n- * - Halving-based block reward\n- * - Difficulty adjustment\n- * - File-based block persistence\n- * - REST + WebSocket miner interface\n- * ------------------------------------------------------------\n+ * - Auto abort on WS updates\n+ * --------------------------------------------------------\n  */\n \n-const express = require('express');\n-const bodyParser = require('body-parser');\n-const fs = require('fs');\n-const path = require('path');\n+const axios = require('axios');\n const crypto = require('crypto');\n-const EC = require('elliptic').ec;\n-const ec = new EC('secp256k1');\n-const http = require('http');\n-const { WebSocketServer } = require('ws');\n+const WebSocket = require('ws');\n+const argv = require('minimist')(process.argv.slice(2));\n \n-const app = express();\n-app.use(bodyParser.json());\n-const PORT = 3000;\n+if (!argv.address) {\n+  console.error('Usage: node miner.js --address <ADDRESS>');\n+  process.exit(1);\n+}\n \n-// ----------------------\n-// Directories & Config\n-// ----------------------\n-const BLOCKS_DIR = path.join(__dirname, 'blocks');\n-if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n+//-----------------------------------------------\n+// üîß Node configuration\n+//-----------------------------------------------\n+const NODE_HTTP = 'http://localhost:3000';\n+const NODE_WS = 'ws://localhost:3000';\n+const ADDRESS = argv.address;\n \n-const MEMPOOL_MAX = 1000;\n-const CONFIG_FILE = path.join(__dirname, 'config.json');\n-let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n-\n-// ----------------------\n-// In-memory state\n-// ----------------------\n-let chain = [];\n-let mempool = [];\n-let UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n-\n-// ----------------------\n-// Crypto Utils\n-// ----------------------\n+//-----------------------------------------------\n+// üîπ Hashing utilities\n+//-----------------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n const sha256 = d => crypto.createHash('sha256').update(d).digest();\n-const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n \n-function pubKeyToAddress(pubKeyHex) {\n-  return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n-}\n-\n-function txHashForSigning(tx) {\n-  const slim = {\n-    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256hex(JSON.stringify(slim));\n-}\n-\n-// ----------------------------------------------------\n-// Proof-of-Work target (Bitcoin-style): target = MAX / difficulty\n-// ----------------------------------------------------\n+//-----------------------------------------------\n+// üîπ Target & Merkle\n+//-----------------------------------------------\n function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n+  const maxTarget = BigInt('0x' + 'f'.repeat(64));\n   return maxTarget / BigInt(difficulty);\n }\n \n-// ----------------------\n-// Helpers\n-// ----------------------\n-function conflictsWithMempool(tx) {\n-  if (!tx.inputs) return false;\n-  const spent = new Set();\n-  for (const t of mempool)\n-    for (const i of (t.inputs || []))\n-      spent.add(`${i.txid}:${i.index}`);\n-  return tx.inputs.some(i => spent.has(`${i.txid}:${i.index}`));\n-}\n-\n-function stableStringify(obj) {\n-  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n-  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n-  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n-}\n-\n-function computeTxId(tx) {\n-  const idShape = {\n-    inputs: (tx.inputs || []).map(i => ({\n-      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n-    })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256hex(stableStringify(idShape));\n-}\n-\n-// Merkle root over txids (binary concatenation)\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n       const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate last if odd\n+      const right = layer[i + 1] || left;\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n   }\n   return layer[0].toString('hex');\n }\n \n-// Canonical header hashing (no JSON, deterministic order)\n function headerHash(header) {\n   const data = [\n     String(header.index),\n     header.previousHash,\n@@ -126,286 +65,214 @@\n   ].join('|');\n   return sha256hex(data);\n }\n \n-// ----------------------\n-// Halving-based reward\n-// ----------------------\n+//-----------------------------------------------\n+// üîπ Global state\n+//-----------------------------------------------\n+let abortFlag = false;\n+let currentDiff = 1;\n+let totalMined = 0;\n+let blockTimes = [];\n+let hashrateWindow = [];\n+let UTXO = new Map();\n+\n+//-----------------------------------------------\n+// üîπ Rebuild UTXO from chain\n+//-----------------------------------------------\n+async function rebuildUTXOFromChain() {\n+  const { data } = await axios.get(`${NODE_HTTP}/chain`);\n+  const chain = data.chain;\n+  UTXO.clear();\n+  for (const block of chain) {\n+    for (const tx of block.transactions) {\n+      for (const inp of (tx.inputs || []))\n+        UTXO.delete(`${inp.txid}:${inp.index}`);\n+      tx.outputs.forEach((o, i) => {\n+        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n+      });\n+    }\n+  }\n+  console.log(`üîÅ Rebuilt local UTXO (${UTXO.size} entries)`);\n+}\n+\n+//-----------------------------------------------\n+// üîπ Halving logic (identical to server.js)\n+//-----------------------------------------------\n function getBlockReward(height, config) {\n   const interval = config.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n   const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n   return reward > 0 ? reward : 0;\n }\n \n+//-----------------------------------------------\n+// üîπ Fee calculation (like node)\n+//-----------------------------------------------\n+function calcFeesForBlockOrder(mempool, utxoSnapshot) {\n+  const temp = new Map(utxoSnapshot);\n+  let fees = 0;\n \n-// ----------------------\n-// Chain init\n-// ----------------------\n-function applyTxToUTXO(tx) {\n-  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n-  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n-}\n+  for (const tx of mempool) {\n+    if (!tx.inputs || tx.inputs.length === 0) continue; // skip coinbase\n+    let inSum = 0, outSum = 0, ok = true;\n \n-function rebuildUTXO() {\n-  UTXO.clear();\n-  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n-}\n+    for (const inp of tx.inputs) {\n+      const u = temp.get(`${inp.txid}:${inp.index}`);\n+      if (!u) { ok = false; break; }\n+      inSum += u.amount;\n+    }\n+    if (!ok) continue;\n \n-function createGenesisBlock() {\n-  const g = {\n-    index: 0,\n-    timestamp: new Date().toISOString(),\n-    transactions: [],\n-    previousHash: '0',\n-    nonce: 0,\n-    difficulty: config.difficulty\n-  };\n-  const root = merkleRoot([]);\n-  const header = { ...g, merkleRoot: root };\n-  g.hash = headerHash(header);\n-  return g;\n-}\n+    for (const o of tx.outputs) outSum += o.amount;\n+    fees += (inSum - outSum);\n \n-function loadChain() {\n-  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n-  if (files.length === 0) {\n-    const g = createGenesisBlock();\n-    chain.push(g);\n-    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n-    console.log('üß± Genesis block created');\n-  } else {\n-    for (const f of files)\n-      chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n-    console.log(`üì¶ Loaded ${chain.length} blocks from disk`);\n+    // apply changes to temp UTXO\n+    for (const inp of tx.inputs) temp.delete(`${inp.txid}:${inp.index}`);\n+    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n-  rebuildUTXO();\n-  console.log(`‚õìÔ∏è  Tip: #${chain[chain.length - 1].index}, hash=${chain[chain.length - 1].hash.slice(0, 12)}...`);\n+\n+  return Math.max(0, Math.floor(fees));\n }\n-loadChain();\n \n-// ----------------------\n-// Validation\n-// ----------------------\n-function validateTx(tx, utxoSet = UTXO) {\n-  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n+//-----------------------------------------------\n+// üîπ Build block template\n+//-----------------------------------------------\n+async function buildTemplate() {\n+  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n+    axios.get(`${NODE_HTTP}/chain`),\n+    axios.get(`${NODE_HTTP}/mempool`),\n+    axios.get(`${NODE_HTTP}/config`)\n+  ]);\n \n-  if (isCoinbase) {\n-    for (const o of tx.outputs)\n-      if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n-        return { ok: false, error: 'invalid output' };\n-    return { ok: true, fee: 0 };\n-  }\n+  const chain = chainData.chain;\n+  const mempool = memData.mempool || [];\n+  currentDiff = conf.difficulty;\n \n-  const seen = new Set();\n-  let inSum = 0, outSum = 0;\n-  const msgHash = txHashForSigning(tx);\n+  const index = chain.length;\n+  const last = chain[chain.length - 1];\n+  const previousHash = last.hash;\n+  const timestamp = new Date().toISOString();\n \n-  for (const inp of tx.inputs) {\n-    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number')\n-      return { ok: false, error: 'bad input format' };\n+  // sync UTXO from node\n+  await rebuildUTXOFromChain();\n \n-    const key = `${inp.txid}:${inp.index}`;\n-    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n-    seen.add(key);\n+  const fees = calcFeesForBlockOrder(mempool, UTXO);\n+  const subsidy = getBlockReward(index, conf);\n+  const rewardTotal = Math.floor(subsidy + fees);\n \n-    const u = utxoSet.get(key);\n-    if (!u) return { ok: false, error: `missing utxo ${key}` };\n-\n-    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n-    const addr = pubKeyToAddress(inp.pubKey);\n-    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n-\n-    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n-    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n-\n-    inSum += u.amount;\n+  if (rewardTotal <= 0) {\n+    console.log(`üí§ No reward available (height=${index}, halving reached). Skipping mining.`);\n+    await new Promise(r => setTimeout(r, 10_000));\n+    return null;\n   }\n \n-  for (const o of tx.outputs) {\n-    if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n-      return { ok: false, error: 'invalid output' };\n-    outSum += o.amount;\n-  }\n+  // coinbase TX\n+  const coinbase = {\n+    id: sha256hex('coinbase' + Date.now()),\n+    inputs: [],\n+    outputs: [{ address: ADDRESS, amount: rewardTotal }]\n+  };\n \n-  const fee = inSum - outSum;\n-  if (fee < 0) return { ok: false, error: 'negative fee' };\n-\n-  return { ok: true, fee };\n+  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n }\n \n-function validateBlock(block) {\n-  const last = chain[chain.length - 1];\n+//-----------------------------------------------\n+// üîπ Main mining loop (target-based PoW)\n+//-----------------------------------------------\n+async function mineLoop() {\n+  while (true) {\n+    try {\n+      const tpl = await buildTemplate();\n+      if (!tpl) continue; // skip if no reward\n \n-  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n-  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n+      const { index, previousHash, timestamp, txs, diff } = tpl;\n+      abortFlag = false;\n \n-  // Timestamp sanity (+2 min skew window)\n-  const t = new Date(block.timestamp).getTime();\n-  const now = Date.now();\n-  const lastT = new Date(last.timestamp).getTime();\n-  if (!(t >= lastT && t <= now + 2 * 60 * 1000))\n-    return { ok: false, error: 'bad timestamp' };\n+      const target = getTarget(diff);\n+      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n \n-  // Recompute header hash & PoW\n-  const root = merkleRoot(block.transactions.map(tx => tx.id));\n-  const header = {\n-    index: block.index,\n-    previousHash: block.previousHash,\n-    timestamp: block.timestamp,\n-    merkleRoot: root,\n-    nonce: block.nonce,\n-    difficulty: block.difficulty\n-  };\n-  const h = headerHash(header);\n-  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n+      let nonce = 0;\n+      let hash;\n+      const start = Date.now();\n+      let hashesTried = 0;\n+      let lastStat = start;\n \n-  const target = getTarget(block.difficulty);\n-  const hashInt = BigInt('0x' + block.hash);\n-  if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n-  console.log(`üîç PoW OK: target‚âà0x${target.toString(16).slice(0, 16)}...`);\n+      while (!abortFlag) {\n+        const root = merkleRoot(txs.map(tx => tx.id));\n+        const header = { index, previousHash, timestamp, merkleRoot: root, nonce, difficulty: diff };\n+        hash = headerHash(header);\n+        hashesTried++;\n \n-  // TXs + temp UTXO\n-  const temp = new Map(UTXO);\n-  let seenTxIds = new Set();\n-  let coinbaseCount = 0;\n-  let feeTotal = 0;\n+        if (hashesTried % 1_000_000 === 0) {\n+          const now = Date.now();\n+          const elapsed = (now - lastStat) / 1000;\n+          const hashrate = (1_000_000 / elapsed) / 1_000_000;\n+          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n+          hashrateWindow.push(hashrate);\n+          if (hashrateWindow.length > 10) hashrateWindow.shift();\n+          lastStat = now;\n+        }\n \n-  for (const tx of block.transactions) {\n-    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n-    seenTxIds.add(tx.id);\n+        const hashInt = BigInt('0x' + hash);\n+        if (hashInt < target) {\n+          const took = (Date.now() - start) / 1000;\n+          const avgTime = (blockTimes.reduce((a, b) => a + b, 0) + took) / (blockTimes.length + 1);\n+          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n \n-    const v = validateTx(tx, temp);\n-    if (!v.ok) return v;\n+          blockTimes.push(took);\n+          if (blockTimes.length > 10) blockTimes.shift();\n \n-    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n-    feeTotal += v.fee;\n+          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n+          console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n+          console.log(`üî¢ hash=${hash}`);\n+          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n \n-    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n-    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n-  }\n+          const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff, hash };\n \n-  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n+          try {\n+            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n+            console.log('üì¶ Submitted:', res.data);\n+          } catch (e) {\n+            console.error('‚ùå Submit error:', e.response?.data || e.message);\n+          }\n \n-  // Enforce coinbase amount (‚â§ subsidy+fees)\n-  const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n-  const expectedReward = getBlockReward(block.index) + feeTotal;\n-  if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n-    return { ok: false, error: 'coinbase reward too high' };\n+          totalMined++;\n+          break;\n+        }\n \n-  return { ok: true };\n-}\n-\n-// ----------------------\n-// Difficulty Adjustment\n-// ----------------------\n-function adjustDifficulty(tipIndex) {\n-  const n = config.adjustEvery;\n-  if (chain.length <= n || n < 2) return;\n-\n-  const lastN = chain.slice(-n);\n-  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a, b) => a - b);\n-  const duration = (times[times.length - 1] - times[0]) / 1000;\n-  const avgTime = duration / (n - 1);\n-  const target = config.targetBlockTimeSec;\n-  const ratio = avgTime / target;\n-\n-  const oldDiff = config.difficulty;\n-  if (ratio < 0.9) config.difficulty++;\n-  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n-\n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  console.log(`‚öôÔ∏è Difficulty adjust ‚Üí old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type: 'config_update', config });\n-\n-  const height = typeof tipIndex === 'number' ? tipIndex : (chain.length - 1);\n-  const currentReward = getBlockReward(height);\n-  const nextHalving = Math.ceil((Math.floor(height / (config.halvingInterval || Infinity)) + 1) * (config.halvingInterval || Infinity));\n-  if (isFinite(nextHalving)) {\n-    console.log(`üíé Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n-  } else {\n-    console.log(`üíé Block reward: ${currentReward} | Halving disabled`);\n+        nonce++;\n+      }\n+    } catch (e) {\n+      console.error('‚ö†Ô∏è Miner error:', e.message);\n+      await new Promise(r => setTimeout(r, 2000));\n+    }\n   }\n }\n \n-// ----------------------\n-// REST API\n-// ----------------------\n-app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n-app.get('/mempool', (req, res) => res.json({ mempool }));\n-app.get('/config', (req, res) => res.json(config));\n-\n-app.post('/transactions', (req, res) => {\n-  const tx = req.body;\n-\n-  if (mempool.length >= MEMPOOL_MAX)\n-    return res.status(400).json({ error: 'mempool full' });\n-\n-  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n-    return res.status(400).json({ error: 'missing outputs' });\n-\n-  tx.id = computeTxId(tx);\n-\n-  const v = validateTx(tx);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n-  tx.fee = v.fee;\n-\n-  if (conflictsWithMempool(tx))\n-    return res.status(400).json({ error: 'mempool double-spend' });\n-\n-  mempool.push(tx);\n-  console.log(`üí∞ TX accepted: ${tx.id.slice(0, 12)}... | fee=${tx.fee}`);\n-  wsBroadcast({ type: 'mempool_tx', tx });\n-  res.json({ status: 'added', id: tx.id });\n-});\n-\n-app.post('/blocks', (req, res) => {\n-  const block = req.body;\n-  const v = validateBlock(block);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n-\n-  const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n-  if (fs.existsSync(filePath))\n-    return res.status(400).json({ error: 'block file already exists' });\n-\n-  fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n-  chain.push(block);\n-\n-  for (const tx of block.transactions) applyTxToUTXO(tx);\n-  const ids = new Set(block.transactions.map(t => t.id));\n-  mempool = mempool.filter(t => !ids.has(t.id));\n-\n-  console.log(`üß± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n-  wsBroadcast({\n-    type: 'new_block',\n-    header: {\n-      index: block.index,\n-      hash: block.hash,\n-      difficulty: block.difficulty,\n-      txs: block.transactions.length\n-    }\n+//-----------------------------------------------\n+// üîπ WebSocket listener (auto abort)\n+//-----------------------------------------------\n+function startWS() {\n+  const ws = new WebSocket(NODE_WS);\n+  ws.on('open', () => console.log('üîå Connected to node'));\n+  ws.on('message', buf => {\n+    try {\n+      const msg = JSON.parse(buf.toString());\n+      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n+        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n+        abortFlag = true;\n+      }\n+    } catch (e) { console.error('‚ö†Ô∏è WS parse error:', e.message); }\n   });\n-\n-  adjustDifficulty(block.index);\n-  res.json({ status: 'block accepted', index: block.index });\n-});\n-\n-// ----------------------\n-// WebSocket Server\n-// ----------------------\n-const server = http.createServer(app);\n-const wss = new WebSocketServer({ server });\n-\n-function wsBroadcast(obj) {\n-  const msg = JSON.stringify(obj);\n-  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n+  ws.on('close', () => {\n+    console.log('üîÑ WS closed ‚Üí reconnecting...');\n+    setTimeout(startWS, 3000);\n+  });\n }\n \n-wss.on('connection', (ws) => {\n-  console.log('üîå Miner connected');\n-  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n-});\n-\n-// ----------------------\n-// Start\n-// ----------------------\n-server.listen(PORT, () => console.log(`üöÄ Node running on http://localhost:${PORT}`));\n+//-----------------------------------------------\n+// üöÄ Start miner\n+//-----------------------------------------------\n+console.log('üöÄ Miner started (halving + UTXO + PoW numeric)');\n+startWS();\n+mineLoop();\n"
                },
                {
                    "date": 1761992513386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,60 +1,121 @@\n /**\n- * ‚õèÔ∏è Final Bitcoin-like Miner (Fully synced with server.js)\n- * --------------------------------------------------------\n- * - Real UTXO & mempool fee calculation\n- * - Exact halving-based block reward (like node)\n+ * üß± Minimal Blockchain Full Node (Final)\n+ * ------------------------------------------------------------\n+ * - UTXO validation\n+ * - Deterministic TX IDs\n  * - Numeric PoW: BigInt(hash) < target\n- * - Auto abort on WS updates\n- * --------------------------------------------------------\n+ * - Merkle root + canonical header hashing\n+ * - Halving-based block reward\n+ * - Difficulty adjustment\n+ * - File-based block persistence\n+ * - REST + WebSocket miner interface\n+ * ------------------------------------------------------------\n  */\n \n-const axios = require('axios');\n+const express = require('express');\n+const bodyParser = require('body-parser');\n+const fs = require('fs');\n+const path = require('path');\n const crypto = require('crypto');\n-const WebSocket = require('ws');\n-const argv = require('minimist')(process.argv.slice(2));\n+const EC = require('elliptic').ec;\n+const ec = new EC('secp256k1');\n+const http = require('http');\n+const { WebSocketServer } = require('ws');\n \n-if (!argv.address) {\n-  console.error('Usage: node miner.js --address <ADDRESS>');\n-  process.exit(1);\n-}\n+const app = express();\n+app.use(bodyParser.json());\n+const PORT = 3000;\n \n-//-----------------------------------------------\n-// üîß Node configuration\n-//-----------------------------------------------\n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n-const ADDRESS = argv.address;\n+// ----------------------\n+// Directories & Config\n+// ----------------------\n+const BLOCKS_DIR = path.join(__dirname, 'blocks');\n+if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n-//-----------------------------------------------\n-// üîπ Hashing utilities\n-//-----------------------------------------------\n+const MEMPOOL_MAX = 1000;\n+const CONFIG_FILE = path.join(__dirname, 'config.json');\n+let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n+\n+// ----------------------\n+// In-memory state\n+// ----------------------\n+let chain = [];\n+let mempool = [];\n+let UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n+\n+// ----------------------\n+// Crypto Utils\n+// ----------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n const sha256 = d => crypto.createHash('sha256').update(d).digest();\n+const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n \n-//-----------------------------------------------\n-// üîπ Target & Merkle\n-//-----------------------------------------------\n+function pubKeyToAddress(pubKeyHex) {\n+  return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n+}\n+\n+function txHashForSigning(tx) {\n+  const slim = {\n+    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256hex(JSON.stringify(slim));\n+}\n+\n+// ----------------------------------------------------\n+// Proof-of-Work target (Bitcoin-style): target = MAX / difficulty\n+// ----------------------------------------------------\n function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64));\n+  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n   return maxTarget / BigInt(difficulty);\n }\n \n+// ----------------------\n+// Helpers\n+// ----------------------\n+function conflictsWithMempool(tx) {\n+  if (!tx.inputs) return false;\n+  const spent = new Set();\n+  for (const t of mempool)\n+    for (const i of (t.inputs || []))\n+      spent.add(`${i.txid}:${i.index}`);\n+  return tx.inputs.some(i => spent.has(`${i.txid}:${i.index}`));\n+}\n+\n+function stableStringify(obj) {\n+  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n+  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n+  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n+}\n+\n+function computeTxId(tx) {\n+  const idShape = {\n+    inputs: (tx.inputs || []).map(i => ({\n+      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n+    })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256hex(stableStringify(idShape));\n+}\n+\n+// Merkle root over txids (binary concatenation)\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n       const left = layer[i];\n-      const right = layer[i + 1] || left;\n+      const right = layer[i + 1] || left; // duplicate last if odd\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n   }\n   return layer[0].toString('hex');\n }\n \n+// Canonical header hashing (no JSON, deterministic order)\n function headerHash(header) {\n   const data = [\n     String(header.index),\n     header.previousHash,\n@@ -65,214 +126,285 @@\n   ].join('|');\n   return sha256hex(data);\n }\n \n-//-----------------------------------------------\n-// üîπ Global state\n-//-----------------------------------------------\n-let abortFlag = false;\n-let currentDiff = 1;\n-let totalMined = 0;\n-let blockTimes = [];\n-let hashrateWindow = [];\n-let UTXO = new Map();\n-\n-//-----------------------------------------------\n-// üîπ Rebuild UTXO from chain\n-//-----------------------------------------------\n-async function rebuildUTXOFromChain() {\n-  const { data } = await axios.get(`${NODE_HTTP}/chain`);\n-  const chain = data.chain;\n-  UTXO.clear();\n-  for (const block of chain) {\n-    for (const tx of block.transactions) {\n-      for (const inp of (tx.inputs || []))\n-        UTXO.delete(`${inp.txid}:${inp.index}`);\n-      tx.outputs.forEach((o, i) => {\n-        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n-      });\n-    }\n-  }\n-  console.log(`üîÅ Rebuilt local UTXO (${UTXO.size} entries)`);\n-}\n-\n-//-----------------------------------------------\n-// üîπ Halving logic (identical to server.js)\n-//-----------------------------------------------\n+// ----------------------\n+// Halving-based reward\n+// ----------------------\n function getBlockReward(height, config) {\n   const interval = config.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n   const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n   return reward > 0 ? reward : 0;\n }\n \n-//-----------------------------------------------\n-// üîπ Fee calculation (like node)\n-//-----------------------------------------------\n-function calcFeesForBlockOrder(mempool, utxoSnapshot) {\n-  const temp = new Map(utxoSnapshot);\n-  let fees = 0;\n+// ----------------------\n+// Chain init\n+// ----------------------\n+function applyTxToUTXO(tx) {\n+  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n+  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+}\n \n-  for (const tx of mempool) {\n-    if (!tx.inputs || tx.inputs.length === 0) continue; // skip coinbase\n-    let inSum = 0, outSum = 0, ok = true;\n+function rebuildUTXO() {\n+  UTXO.clear();\n+  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n+}\n \n-    for (const inp of tx.inputs) {\n-      const u = temp.get(`${inp.txid}:${inp.index}`);\n-      if (!u) { ok = false; break; }\n-      inSum += u.amount;\n-    }\n-    if (!ok) continue;\n+function createGenesisBlock() {\n+  const g = {\n+    index: 0,\n+    timestamp: new Date().toISOString(),\n+    transactions: [],\n+    previousHash: '0',\n+    nonce: 0,\n+    difficulty: config.difficulty\n+  };\n+  const root = merkleRoot([]);\n+  const header = { ...g, merkleRoot: root };\n+  g.hash = headerHash(header);\n+  return g;\n+}\n \n-    for (const o of tx.outputs) outSum += o.amount;\n-    fees += (inSum - outSum);\n+function loadChain() {\n+  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n+  if (files.length === 0) {\n+    const g = createGenesisBlock();\n+    chain.push(g);\n+    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n+    console.log('üß± Genesis block created');\n+  } else {\n+    for (const f of files)\n+      chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n+    console.log(`üì¶ Loaded ${chain.length} blocks from disk`);\n+  }\n+  rebuildUTXO();\n+  console.log(`‚õìÔ∏è  Tip: #${chain[chain.length - 1].index}, hash=${chain[chain.length - 1].hash.slice(0, 12)}...`);\n+}\n+loadChain();\n \n-    // apply changes to temp UTXO\n-    for (const inp of tx.inputs) temp.delete(`${inp.txid}:${inp.index}`);\n-    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+// ----------------------\n+// Validation\n+// ----------------------\n+function validateTx(tx, utxoSet = UTXO) {\n+  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n+\n+  if (isCoinbase) {\n+    for (const o of tx.outputs)\n+      if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n+        return { ok: false, error: 'invalid output' };\n+    return { ok: true, fee: 0 };\n   }\n \n-  return Math.max(0, Math.floor(fees));\n-}\n+  const seen = new Set();\n+  let inSum = 0, outSum = 0;\n+  const msgHash = txHashForSigning(tx);\n \n-//-----------------------------------------------\n-// üîπ Build block template\n-//-----------------------------------------------\n-async function buildTemplate() {\n-  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n-    axios.get(`${NODE_HTTP}/chain`),\n-    axios.get(`${NODE_HTTP}/mempool`),\n-    axios.get(`${NODE_HTTP}/config`)\n-  ]);\n+  for (const inp of tx.inputs) {\n+    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number')\n+      return { ok: false, error: 'bad input format' };\n \n-  const chain = chainData.chain;\n-  const mempool = memData.mempool || [];\n-  currentDiff = conf.difficulty;\n+    const key = `${inp.txid}:${inp.index}`;\n+    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n+    seen.add(key);\n \n-  const index = chain.length;\n-  const last = chain[chain.length - 1];\n-  const previousHash = last.hash;\n-  const timestamp = new Date().toISOString();\n+    const u = utxoSet.get(key);\n+    if (!u) return { ok: false, error: `missing utxo ${key}` };\n \n-  // sync UTXO from node\n-  await rebuildUTXOFromChain();\n+    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n+    const addr = pubKeyToAddress(inp.pubKey);\n+    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n \n-  const fees = calcFeesForBlockOrder(mempool, UTXO);\n-  const subsidy = getBlockReward(index, conf);\n-  const rewardTotal = Math.floor(subsidy + fees);\n+    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n+    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n \n-  if (rewardTotal <= 0) {\n-    console.log(`üí§ No reward available (height=${index}, halving reached). Skipping mining.`);\n-    await new Promise(r => setTimeout(r, 10_000));\n-    return null;\n+    inSum += u.amount;\n   }\n \n-  // coinbase TX\n-  const coinbase = {\n-    id: sha256hex('coinbase' + Date.now()),\n-    inputs: [],\n-    outputs: [{ address: ADDRESS, amount: rewardTotal }]\n-  };\n+  for (const o of tx.outputs) {\n+    if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n+      return { ok: false, error: 'invalid output' };\n+    outSum += o.amount;\n+  }\n \n-  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n+  const fee = inSum - outSum;\n+  if (fee < 0) return { ok: false, error: 'negative fee' };\n+\n+  return { ok: true, fee };\n }\n \n-//-----------------------------------------------\n-// üîπ Main mining loop (target-based PoW)\n-//-----------------------------------------------\n-async function mineLoop() {\n-  while (true) {\n-    try {\n-      const tpl = await buildTemplate();\n-      if (!tpl) continue; // skip if no reward\n+function validateBlock(block) {\n+  const last = chain[chain.length - 1];\n \n-      const { index, previousHash, timestamp, txs, diff } = tpl;\n-      abortFlag = false;\n+  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n+  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n \n-      const target = getTarget(diff);\n-      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n+  // Timestamp sanity (+2 min skew window)\n+  const t = new Date(block.timestamp).getTime();\n+  const now = Date.now();\n+  const lastT = new Date(last.timestamp).getTime();\n+  if (!(t >= lastT && t <= now + 2 * 60 * 1000))\n+    return { ok: false, error: 'bad timestamp' };\n \n-      let nonce = 0;\n-      let hash;\n-      const start = Date.now();\n-      let hashesTried = 0;\n-      let lastStat = start;\n+  // Recompute header hash & PoW\n+  const root = merkleRoot(block.transactions.map(tx => tx.id));\n+  const header = {\n+    index: block.index,\n+    previousHash: block.previousHash,\n+    timestamp: block.timestamp,\n+    merkleRoot: root,\n+    nonce: block.nonce,\n+    difficulty: block.difficulty\n+  };\n+  const h = headerHash(header);\n+  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n \n-      while (!abortFlag) {\n-        const root = merkleRoot(txs.map(tx => tx.id));\n-        const header = { index, previousHash, timestamp, merkleRoot: root, nonce, difficulty: diff };\n-        hash = headerHash(header);\n-        hashesTried++;\n+  const target = getTarget(block.difficulty);\n+  const hashInt = BigInt('0x' + block.hash);\n+  if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n+  console.log(`üîç PoW OK: target‚âà0x${target.toString(16).slice(0, 16)}...`);\n \n-        if (hashesTried % 1_000_000 === 0) {\n-          const now = Date.now();\n-          const elapsed = (now - lastStat) / 1000;\n-          const hashrate = (1_000_000 / elapsed) / 1_000_000;\n-          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n-          hashrateWindow.push(hashrate);\n-          if (hashrateWindow.length > 10) hashrateWindow.shift();\n-          lastStat = now;\n-        }\n+  // TXs + temp UTXO\n+  const temp = new Map(UTXO);\n+  let seenTxIds = new Set();\n+  let coinbaseCount = 0;\n+  let feeTotal = 0;\n \n-        const hashInt = BigInt('0x' + hash);\n-        if (hashInt < target) {\n-          const took = (Date.now() - start) / 1000;\n-          const avgTime = (blockTimes.reduce((a, b) => a + b, 0) + took) / (blockTimes.length + 1);\n-          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n+  for (const tx of block.transactions) {\n+    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n+    seenTxIds.add(tx.id);\n \n-          blockTimes.push(took);\n-          if (blockTimes.length > 10) blockTimes.shift();\n+    const v = validateTx(tx, temp);\n+    if (!v.ok) return v;\n \n-          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n-          console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n-          console.log(`üî¢ hash=${hash}`);\n-          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n+    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n+    feeTotal += v.fee;\n \n-          const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff, hash };\n+    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n+    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+  }\n \n-          try {\n-            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n-            console.log('üì¶ Submitted:', res.data);\n-          } catch (e) {\n-            console.error('‚ùå Submit error:', e.response?.data || e.message);\n-          }\n+  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n \n-          totalMined++;\n-          break;\n-        }\n+  // Enforce coinbase amount (‚â§ subsidy+fees)\n+  const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n+  const expectedReward = getBlockReward(block.index) + feeTotal;\n+  if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n+    return { ok: false, error: 'coinbase reward too high' };\n \n-        nonce++;\n-      }\n-    } catch (e) {\n-      console.error('‚ö†Ô∏è Miner error:', e.message);\n-      await new Promise(r => setTimeout(r, 2000));\n-    }\n+  return { ok: true };\n+}\n+\n+// ----------------------\n+// Difficulty Adjustment\n+// ----------------------\n+function adjustDifficulty(tipIndex) {\n+  const n = config.adjustEvery;\n+  if (chain.length <= n || n < 2) return;\n+\n+  const lastN = chain.slice(-n);\n+  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a, b) => a - b);\n+  const duration = (times[times.length - 1] - times[0]) / 1000;\n+  const avgTime = duration / (n - 1);\n+  const target = config.targetBlockTimeSec;\n+  const ratio = avgTime / target;\n+\n+  const oldDiff = config.difficulty;\n+  if (ratio < 0.9) config.difficulty++;\n+  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n+\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+  console.log(`‚öôÔ∏è Difficulty adjust ‚Üí old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n+  wsBroadcast({ type: 'config_update', config });\n+\n+  const height = typeof tipIndex === 'number' ? tipIndex : (chain.length - 1);\n+  const currentReward = getBlockReward(height);\n+  const nextHalving = Math.ceil((Math.floor(height / (config.halvingInterval || Infinity)) + 1) * (config.halvingInterval || Infinity));\n+  if (isFinite(nextHalving)) {\n+    console.log(`üíé Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n+  } else {\n+    console.log(`üíé Block reward: ${currentReward} | Halving disabled`);\n   }\n }\n \n-//-----------------------------------------------\n-// üîπ WebSocket listener (auto abort)\n-//-----------------------------------------------\n-function startWS() {\n-  const ws = new WebSocket(NODE_WS);\n-  ws.on('open', () => console.log('üîå Connected to node'));\n-  ws.on('message', buf => {\n-    try {\n-      const msg = JSON.parse(buf.toString());\n-      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n-        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n-        abortFlag = true;\n-      }\n-    } catch (e) { console.error('‚ö†Ô∏è WS parse error:', e.message); }\n+// ----------------------\n+// REST API\n+// ----------------------\n+app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n+app.get('/mempool', (req, res) => res.json({ mempool }));\n+app.get('/config', (req, res) => res.json(config));\n+\n+app.post('/transactions', (req, res) => {\n+  const tx = req.body;\n+\n+  if (mempool.length >= MEMPOOL_MAX)\n+    return res.status(400).json({ error: 'mempool full' });\n+\n+  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n+    return res.status(400).json({ error: 'missing outputs' });\n+\n+  tx.id = computeTxId(tx);\n+\n+  const v = validateTx(tx);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n+  tx.fee = v.fee;\n+\n+  if (conflictsWithMempool(tx))\n+    return res.status(400).json({ error: 'mempool double-spend' });\n+\n+  mempool.push(tx);\n+  console.log(`üí∞ TX accepted: ${tx.id.slice(0, 12)}... | fee=${tx.fee}`);\n+  wsBroadcast({ type: 'mempool_tx', tx });\n+  res.json({ status: 'added', id: tx.id });\n+});\n+\n+app.post('/blocks', (req, res) => {\n+  const block = req.body;\n+  const v = validateBlock(block);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n+\n+  const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n+  if (fs.existsSync(filePath))\n+    return res.status(400).json({ error: 'block file already exists' });\n+\n+  fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n+  chain.push(block);\n+\n+  for (const tx of block.transactions) applyTxToUTXO(tx);\n+  const ids = new Set(block.transactions.map(t => t.id));\n+  mempool = mempool.filter(t => !ids.has(t.id));\n+\n+  console.log(`üß± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n+  wsBroadcast({\n+    type: 'new_block',\n+    header: {\n+      index: block.index,\n+      hash: block.hash,\n+      difficulty: block.difficulty,\n+      txs: block.transactions.length\n+    }\n   });\n-  ws.on('close', () => {\n-    console.log('üîÑ WS closed ‚Üí reconnecting...');\n-    setTimeout(startWS, 3000);\n-  });\n+\n+  adjustDifficulty(block.index);\n+  res.json({ status: 'block accepted', index: block.index });\n+});\n+\n+// ----------------------\n+// WebSocket Server\n+// ----------------------\n+const server = http.createServer(app);\n+const wss = new WebSocketServer({ server });\n+\n+function wsBroadcast(obj) {\n+  const msg = JSON.stringify(obj);\n+  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n }\n \n-//-----------------------------------------------\n-// üöÄ Start miner\n-//-----------------------------------------------\n-console.log('üöÄ Miner started (halving + UTXO + PoW numeric)');\n-startWS();\n-mineLoop();\n+wss.on('connection', (ws) => {\n+  console.log('üîå Miner connected');\n+  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n+});\n+\n+// ----------------------\n+// Start\n+// ----------------------\n+server.listen(PORT, () => console.log(`üöÄ Node running on http://localhost:${PORT}`));\n"
                },
                {
                    "date": 1761993041253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -332,8 +332,21 @@\n app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n app.get('/mempool', (req, res) => res.json({ mempool }));\n app.get('/config', (req, res) => res.json(config));\n \n+app.get('/utxos/:addr', (req, res) => {\n+  const addr = req.params.addr;\n+  const utxos = [];\n+  UTXO.forEach((u, key) => {\n+    if (u.address === addr) {\n+      const [txid, index] = key.split(':');\n+      utxos.push({ txid, index: +index, amount: u.amount, address: u.address });\n+    }\n+  });\n+  res.json({ utxos });\n+});\n+\n+\n app.post('/transactions', (req, res) => {\n   const tx = req.body;\n \n   if (mempool.length >= MEMPOOL_MAX)\n"
                },
                {
                    "date": 1761993842721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,15 +129,16 @@\n \n // ----------------------\n // Halving-based reward\n // ----------------------\n-function getBlockReward(height, config) {\n-  const interval = config.halvingInterval || Infinity;\n+function getBlockReward(height, cfg = config) {\n+  const interval = cfg.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n-  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n-  return reward > 0 ? reward : 0;\n+  const reward = Math.floor(cfg.blockSubsidy / Math.pow(2, halvings));\n+  return Math.max(reward, 0);\n }\n \n+\n // ----------------------\n // Chain init\n // ----------------------\n function applyTxToUTXO(tx) {\n"
                },
                {
                    "date": 1761993876381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,16 +129,15 @@\n \n // ----------------------\n // Halving-based reward\n // ----------------------\n-function getBlockReward(height, cfg = config) {\n-  const interval = cfg.halvingInterval || Infinity;\n+function getBlockReward(height, config) {\n+  const interval = config.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n-  const reward = Math.floor(cfg.blockSubsidy / Math.pow(2, halvings));\n-  return Math.max(reward, 0);\n+  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n+  return reward > 0 ? reward : 0;\n }\n \n-\n // ----------------------\n // Chain init\n // ----------------------\n function applyTxToUTXO(tx) {\n@@ -287,9 +286,9 @@\n   if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n \n   // Enforce coinbase amount (‚â§ subsidy+fees)\n   const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n-  const expectedReward = getBlockReward(block.index) + feeTotal;\n+  const expectedReward = getBlockReward(block.index, config) + feeTotal;\n   if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n     return { ok: false, error: 'coinbase reward too high' };\n \n   return { ok: true };\n@@ -317,9 +316,9 @@\n   console.log(`‚öôÔ∏è Difficulty adjust ‚Üí old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n   wsBroadcast({ type: 'config_update', config });\n \n   const height = typeof tipIndex === 'number' ? tipIndex : (chain.length - 1);\n-  const currentReward = getBlockReward(height);\n+  const currentReward = getBlockReward(height, config);\n   const nextHalving = Math.ceil((Math.floor(height / (config.halvingInterval || Infinity)) + 1) * (config.halvingInterval || Infinity));\n   if (isFinite(nextHalving)) {\n     console.log(`üíé Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n   } else {\n"
                },
                {
                    "date": 1761995341945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,423 +1,450 @@\n-/**\n- * üß± Minimal Blockchain Full Node (Final)\n- * ------------------------------------------------------------\n- * - UTXO validation\n- * - Deterministic TX IDs\n- * - Numeric PoW: BigInt(hash) < target\n- * - Merkle root + canonical header hashing\n- * - Halving-based block reward\n- * - Difficulty adjustment\n- * - File-based block persistence\n- * - REST + WebSocket miner interface\n- * ------------------------------------------------------------\n- */\n+// apps/blockchain/server.js\n+// Full Node (simplified Bitcoin-like, educational)\n+// Run: node apps/blockchain/server.js\n \n const express = require('express');\n const bodyParser = require('body-parser');\n const fs = require('fs');\n-const path = require('path');\n const crypto = require('crypto');\n-const EC = require('elliptic').ec;\n-const ec = new EC('secp256k1');\n-const http = require('http');\n const { WebSocketServer } = require('ws');\n+const stableStringify = require('stable-stringify');\n \n const app = express();\n app.use(bodyParser.json());\n-const PORT = 3000;\n \n-// ----------------------\n-// Directories & Config\n-// ----------------------\n-const BLOCKS_DIR = path.join(__dirname, 'blocks');\n-if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n+const DATA_DIR = __dirname + '/data';\n+const BLOCK_DIR = DATA_DIR + '/blocks';\n+if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR);\n+if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR);\n \n-const MEMPOOL_MAX = 1000;\n-const CONFIG_FILE = path.join(__dirname, 'config.json');\n-let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n+// -------------------- Config (editable) --------------------\n+let config = {\n+  // difficulty = number of leading hex '0' nibbles? We use hex chars '0' repeated.\n+  // Each hex '0' is 4 leading zero bits. For simplicity we use hex-nibble prefix.\n+  difficulty: 4,            // initial difficulty = number of leading '0' hex chars required\n+  adjustEvery: 10,          // retarget every 10 blocks\n+  targetBlockTimeSec: 15,   // target block time in seconds\n+  blockSubsidy: 50,         // initial block reward\n+  halvingInterval: 100,     // halving interval (in blocks) for demo\n+  coinbaseMaturity: 10,     // coinbase must wait this many confirmations\n+  maxBlockTx: 50,           // max tx per block\n+};\n+const CONFIG_FILE = DATA_DIR + '/config.json';\n+if (fs.existsSync(CONFIG_FILE)) {\n+  try {\n+    const loaded = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n+    Object.assign(config, loaded);\n+  } catch(e) { /* ignore */ }\n+} else {\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+}\n \n-// ----------------------\n-// In-memory state\n-// ----------------------\n-let chain = [];\n-let mempool = [];\n-let UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n+// -------------------- In-memory state --------------------\n+let chain = [];           // array of blocks\n+let mempool = {};         // txid -> tx\n+let utxo = new Map();     // key: `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n \n-// ----------------------\n-// Crypto Utils\n-// ----------------------\n-const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256 = d => crypto.createHash('sha256').update(d).digest();\n-const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n-\n-function pubKeyToAddress(pubKeyHex) {\n-  return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n+// utility: sha256 hex\n+function sha256Hex(buf) {\n+  return crypto.createHash('sha256').update(buf).digest('hex');\n }\n \n-function txHashForSigning(tx) {\n-  const slim = {\n-    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n+// canonical txid: hash of serialized tx without signatures (stable)\n+function txIdFor(tx) {\n+  // remove sigs for id\n+  const copy = {\n+    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey || null })),\n     outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n   };\n-  return sha256hex(JSON.stringify(slim));\n+  return sha256Hex(Buffer.from(stableStringify(copy)));\n }\n \n-// ----------------------------------------------------\n-// Proof-of-Work target (Bitcoin-style): target = MAX / difficulty\n-// ----------------------------------------------------\n-function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n-  return maxTarget / BigInt(difficulty);\n+// block header hash (hex)\n+function headerHash(block) {\n+  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.difficulty}`;\n+  return sha256Hex(Buffer.from(header));\n }\n \n-// ----------------------\n-// Helpers\n-// ----------------------\n-function conflictsWithMempool(tx) {\n-  if (!tx.inputs) return false;\n-  const spent = new Set();\n-  for (const t of mempool)\n-    for (const i of (t.inputs || []))\n-      spent.add(`${i.txid}:${i.index}`);\n-  return tx.inputs.some(i => spent.has(`${i.txid}:${i.index}`));\n-}\n-\n-function stableStringify(obj) {\n-  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n-  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n-  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n-}\n-\n-function computeTxId(tx) {\n-  const idShape = {\n-    inputs: (tx.inputs || []).map(i => ({\n-      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n-    })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256hex(stableStringify(idShape));\n-}\n-\n-// Merkle root over txids (binary concatenation)\n+// merkle root (simple): hashes txids pairwise\n function merkleRoot(txids) {\n-  if (txids.length === 0) return sha256hex('');\n-  let layer = txids.map(x => Buffer.from(x, 'hex'));\n-  while (layer.length > 1) {\n+  if (!txids.length) return sha256Hex(Buffer.from(''));\n+  let list = txids.map(t => Buffer.from(t, 'hex'));\n+  while (list.length > 1) {\n+    if (list.length % 2 === 1) list.push(list[list.length - 1]);\n     const next = [];\n-    for (let i = 0; i < layer.length; i += 2) {\n-      const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate last if odd\n-      next.push(sha256(Buffer.concat([left, right])));\n+    for (let i = 0; i < list.length; i += 2) {\n+      next.push(Buffer.from(sha256Hex(Buffer.concat([list[i], list[i + 1]])), 'hex'));\n     }\n-    layer = next;\n+    list = next;\n   }\n-  return layer[0].toString('hex');\n+  return list[0].toString('hex');\n }\n \n-// Canonical header hashing (no JSON, deterministic order)\n-function headerHash(header) {\n-  const data = [\n-    String(header.index),\n-    header.previousHash,\n-    String(header.timestamp),\n-    header.merkleRoot,\n-    String(header.nonce),\n-    String(header.difficulty)\n-  ].join('|');\n-  return sha256hex(data);\n+// check hash meets difficulty (leading '0' hex chars)\n+function hashMeetsDifficulty(hexHash, difficulty) {\n+  return hexHash.startsWith('0'.repeat(difficulty));\n }\n \n-// ----------------------\n-// Halving-based reward\n-// ----------------------\n-function getBlockReward(height, config) {\n-  const interval = config.halvingInterval || Infinity;\n-  const halvings = Math.floor(height / interval);\n-  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n-  return reward > 0 ? reward : 0;\n+// read blocks from disk at startup\n+function loadBlocks() {\n+  const files = fs.readdirSync(BLOCK_DIR).filter(f => f.endsWith('.json'));\n+  const blocks = files\n+    .map(f => ({ f, n: parseInt(f.split('_')[1]) }))\n+    .sort((a,b) => a.n - b.n)\n+    .map(x => JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${x.f}`, 'utf8')));\n+  for (const b of blocks) {\n+    chain.push(b);\n+  }\n }\n \n-// ----------------------\n-// Chain init\n-// ----------------------\n-function applyTxToUTXO(tx) {\n-  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n-  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+// persist block\n+function saveBlock(block) {\n+  fs.writeFileSync(`${BLOCK_DIR}/block_${block.index}.json`, JSON.stringify(block, null, 2));\n }\n \n+// rebuild UTXO from chain\n function rebuildUTXO() {\n-  UTXO.clear();\n-  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n+  utxo = new Map();\n+  for (let h = 0; h < chain.length; h++) {\n+    const block = chain[h];\n+    for (const tx of block.transactions) {\n+      const tid = tx.id;\n+      // remove spent inputs\n+      for (const inp of tx.inputs || []) {\n+        const key = `${inp.txid}:${inp.index}`;\n+        utxo.delete(key);\n+      }\n+      // add outputs\n+      tx.outputs.forEach((out, idx) => {\n+        const key = `${tid}:${idx}`;\n+        utxo.set(key, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase });\n+      });\n+    }\n+  }\n }\n \n-function createGenesisBlock() {\n-  const g = {\n-    index: 0,\n-    timestamp: new Date().toISOString(),\n-    transactions: [],\n-    previousHash: '0',\n-    nonce: 0,\n-    difficulty: config.difficulty\n-  };\n-  const root = merkleRoot([]);\n-  const header = { ...g, merkleRoot: root };\n-  g.hash = headerHash(header);\n-  return g;\n+// get block reward based on height (halving)\n+function getBlockReward(height) {\n+  const halvings = Math.floor(height / config.halvingInterval);\n+  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n+  return Math.max(reward, 0);\n }\n \n-function loadChain() {\n-  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n-  if (files.length === 0) {\n-    const g = createGenesisBlock();\n-    chain.push(g);\n-    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n-    console.log('üß± Genesis block created');\n-  } else {\n-    for (const f of files)\n-      chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n-    console.log(`üì¶ Loaded ${chain.length} blocks from disk`);\n+// validate transaction (basic): inputs exist in UTXO and sum in >= sum out + fee, signatures assumed valid (educational)\n+function validateTx(tx, currentHeight) {\n+  if (!tx || !tx.inputs || !tx.outputs) throw new Error('invalid tx format');\n+  // coinbase: special\n+  if (tx.isCoinbase) {\n+    // coinbase rules: only outputs, no inputs\n+    if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n+    // later block validation ensures coinbase reward <= expected\n+    return true;\n   }\n-  rebuildUTXO();\n-  console.log(`‚õìÔ∏è  Tip: #${chain[chain.length - 1].index}, hash=${chain[chain.length - 1].hash.slice(0, 12)}...`);\n-}\n-loadChain();\n-\n-// ----------------------\n-// Validation\n-// ----------------------\n-function validateTx(tx, utxoSet = UTXO) {\n-  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n-\n-  if (isCoinbase) {\n-    for (const o of tx.outputs)\n-      if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n-        return { ok: false, error: 'invalid output' };\n-    return { ok: true, fee: 0 };\n-  }\n-\n-  const seen = new Set();\n-  let inSum = 0, outSum = 0;\n-  const msgHash = txHashForSigning(tx);\n-\n+  let inSum = 0;\n+  let outSum = 0;\n+  // check inputs exist, not double spending mempool-internal\n+  const usedKeys = new Set();\n   for (const inp of tx.inputs) {\n-    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number')\n-      return { ok: false, error: 'bad input format' };\n-\n     const key = `${inp.txid}:${inp.index}`;\n-    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n-    seen.add(key);\n-\n-    const u = utxoSet.get(key);\n-    if (!u) return { ok: false, error: `missing utxo ${key}` };\n-\n-    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n-    const addr = pubKeyToAddress(inp.pubKey);\n-    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n-\n-    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n-    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n-\n+    if (usedKeys.has(key)) throw new Error('double spend in tx');\n+    usedKeys.add(key);\n+    const u = utxo.get(key);\n+    if (!u) throw new Error('input missing UTXO: ' + key);\n+    // coinbase maturity\n+    if (u.isCoinbase && (currentHeight - u.blockHeight) < config.coinbaseMaturity) throw new Error('coinbase input not matured');\n     inSum += u.amount;\n   }\n-\n   for (const o of tx.outputs) {\n-    if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n-      return { ok: false, error: 'invalid output' };\n+    if (o.amount <= 0) throw new Error('output amount <= 0');\n     outSum += o.amount;\n   }\n-\n-  const fee = inSum - outSum;\n-  if (fee < 0) return { ok: false, error: 'negative fee' };\n-\n-  return { ok: true, fee };\n+  if (inSum < outSum) throw new Error('inputs < outputs');\n+  // signature verification omitted for brevity ‚Äî assume signing handled by client (educational)\n+  return true;\n }\n \n+// validate block\n function validateBlock(block) {\n-  const last = chain[chain.length - 1];\n-\n-  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n-  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n-\n-  // Timestamp sanity (+2 min skew window)\n-  const t = new Date(block.timestamp).getTime();\n-  const now = Date.now();\n-  const lastT = new Date(last.timestamp).getTime();\n-  if (!(t >= lastT && t <= now + 2 * 60 * 1000))\n-    return { ok: false, error: 'bad timestamp' };\n-\n-  // Recompute header hash & PoW\n-  const root = merkleRoot(block.transactions.map(tx => tx.id));\n-  const header = {\n-    index: block.index,\n-    previousHash: block.previousHash,\n-    timestamp: block.timestamp,\n-    merkleRoot: root,\n-    nonce: block.nonce,\n-    difficulty: block.difficulty\n-  };\n-  const h = headerHash(header);\n-  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n-\n-  const target = getTarget(block.difficulty);\n-  const hashInt = BigInt('0x' + block.hash);\n-  if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n-  console.log(`üîç PoW OK: target‚âà0x${target.toString(16).slice(0, 16)}...`);\n-\n-  // TXs + temp UTXO\n-  const temp = new Map(UTXO);\n-  let seenTxIds = new Set();\n+  // index and previousHash\n+  const tip = chain[chain.length - 1];\n+  if (chain.length === 0) {\n+    if (block.index !== 0) throw new Error('genesis must index 0');\n+  } else {\n+    if (block.previousHash !== headerHash(tip)) throw new Error('previousHash mismatch');\n+    if (block.index !== tip.index + 1) throw new Error('bad index');\n+  }\n+  // merkle root\n+  const txids = block.transactions.map(t => t.id);\n+  if (merkleRoot(txids) !== block.merkleRoot) throw new Error('merkle mismatch');\n+  // hash -> difficulty\n+  const h = headerHash(block);\n+  if (!hashMeetsDifficulty(h, block.difficulty)) throw new Error('PoW not satisfied');\n+  // transactions validity: coinbase rules, sums\n+  let feeTotal = 0;\n   let coinbaseCount = 0;\n-  let feeTotal = 0;\n+  // create temporary UTXO snapshot (shallow copy)\n+  const utxoTemp = new Map(utxo);\n+  for (const tx of block.transactions) {\n+    if (tx.isCoinbase) {\n+      coinbaseCount++;\n+      // coinbase should have no inputs\n+      if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n+      // we'll check coinbase amount later\n+      // add outputs to utxoTemp\n+      tx.outputs.forEach((out, idx) => {\n+        utxoTemp.set(`${tx.id}:${idx}`, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: true });\n+      });\n+    } else {\n+      // check inputs exist in utxoTemp\n+      let inSum = 0, outSum = 0;\n+      for (const inp of tx.inputs) {\n+        const key = `${inp.txid}:${inp.index}`;\n+        const entry = utxoTemp.get(key);\n+        if (!entry) throw new Error('missing input in block tx: ' + key);\n+        inSum += entry.amount;\n+        utxoTemp.delete(key);\n+      }\n+      for (const out of tx.outputs) {\n+        outSum += out.amount;\n+      }\n+      if (inSum < outSum) throw new Error('tx spends more than inputs');\n+      feeTotal += (inSum - outSum);\n+      // add outputs\n+      tx.outputs.forEach((out, idx) => {\n+        utxoTemp.set(`${tx.id}:${idx}`, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: false });\n+      });\n+    }\n+  }\n+  if (coinbaseCount !== 1) throw new Error('block must contain exactly 1 coinbase tx');\n+  // check coinbase amount\n+  const expected = getBlockReward(block.index) + feeTotal;\n+  const coinbaseTx = block.transactions.find(t => t.isCoinbase);\n+  const coinbaseOut = coinbaseTx.outputs.reduce((s,o) => s + o.amount, 0);\n+  if (coinbaseOut > expected) throw new Error(`coinbase too large: ${coinbaseOut} > ${expected}`);\n+  return true;\n+}\n \n+// apply a block (assumes valid)\n+function applyBlock(block) {\n+  // remove spent UTXOs and add outputs\n   for (const tx of block.transactions) {\n-    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n-    seenTxIds.add(tx.id);\n+    for (const inp of tx.inputs || []) {\n+      const key = `${inp.txid}:${inp.index}`;\n+      utxo.delete(key);\n+    }\n+    tx.outputs.forEach((out, idx) => {\n+      const key = `${tx.id}:${idx}`;\n+      utxo.set(key, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase });\n+    });\n+    // remove tx from mempool\n+    if (mempool[tx.id]) delete mempool[tx.id];\n+  }\n+  chain.push(block);\n+  saveBlock(block);\n+  // write config occasionally\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+}\n \n-    const v = validateTx(tx, temp);\n-    if (!v.ok) return v;\n+// difficulty retargeting (called when new block appended)\n+function maybeRetarget() {\n+  const height = chain.length;\n+  if (height > 0 && height % config.adjustEvery === 0) {\n+    const last = chain[height - 1];\n+    const first = chain[Math.max(0, height - config.adjustEvery)];\n+    const actualTime = (last.timestamp - first.timestamp) / 1000;\n+    const expectedTime = config.adjustEvery * config.targetBlockTimeSec;\n+    let ratio = expectedTime / (actualTime || 1);\n+    // clamp ratio to avoid huge jumps\n+    const minRatio = 0.25, maxRatio = 4;\n+    if (ratio < minRatio) ratio = minRatio;\n+    if (ratio > maxRatio) ratio = maxRatio;\n+    const newDifficulty = Math.max(1, Math.round(config.difficulty * ratio));\n+    console.log(`Retarget: height=${height} actual=${actualTime}s expected=${expectedTime}s ratio=${ratio.toFixed(3)} diff ${config.difficulty} -> ${newDifficulty}`);\n+    config.difficulty = newDifficulty;\n+    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+  }\n+}\n \n-    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n-    feeTotal += v.fee;\n+// Broadcast helpers (WebSocket)\n+const wss = new WebSocketServer({ noServer: true });\n+let sockets = new Set();\n \n-    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n-    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+function broadcast(msg) {\n+  const s = JSON.stringify(msg);\n+  for (const ws of sockets) {\n+    if (ws.readyState === ws.OPEN) ws.send(s);\n   }\n-\n-  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n-\n-  // Enforce coinbase amount (‚â§ subsidy+fees)\n-  const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n-  const expectedReward = getBlockReward(block.index, config) + feeTotal;\n-  if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n-    return { ok: false, error: 'coinbase reward too high' };\n-\n-  return { ok: true };\n }\n \n-// ----------------------\n-// Difficulty Adjustment\n-// ----------------------\n-function adjustDifficulty(tipIndex) {\n-  const n = config.adjustEvery;\n-  if (chain.length <= n || n < 2) return;\n+// -------------------- Endpoints --------------------\n \n-  const lastN = chain.slice(-n);\n-  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a, b) => a - b);\n-  const duration = (times[times.length - 1] - times[0]) / 1000;\n-  const avgTime = duration / (n - 1);\n-  const target = config.targetBlockTimeSec;\n-  const ratio = avgTime / target;\n+// basic info\n+app.get('/config', (req, res) => {\n+  res.json(config);\n+});\n \n-  const oldDiff = config.difficulty;\n-  if (ratio < 0.9) config.difficulty++;\n-  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n+// chain / tip\n+app.get('/chain', (req, res) => res.json(chain));\n+app.get('/tip', (req, res) => res.json(chain[chain.length - 1] || null));\n+app.get('/block/:height', (req, res) => {\n+  const h = parseInt(req.params.height);\n+  if (isNaN(h) || h < 0 || h >= chain.length) return res.status(404).json({ error: 'not found' });\n+  res.json(chain[h]);\n+});\n \n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  console.log(`‚öôÔ∏è Difficulty adjust ‚Üí old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type: 'config_update', config });\n+// mempool\n+app.get('/mempool', (req, res) => res.json(Object.values(mempool)));\n \n-  const height = typeof tipIndex === 'number' ? tipIndex : (chain.length - 1);\n-  const currentReward = getBlockReward(height, config);\n-  const nextHalving = Math.ceil((Math.floor(height / (config.halvingInterval || Infinity)) + 1) * (config.halvingInterval || Infinity));\n-  if (isFinite(nextHalving)) {\n-    console.log(`üíé Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n-  } else {\n-    console.log(`üíé Block reward: ${currentReward} | Halving disabled`);\n-  }\n-}\n-\n-// ----------------------\n-// REST API\n-// ----------------------\n-app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n-app.get('/mempool', (req, res) => res.json({ mempool }));\n-app.get('/config', (req, res) => res.json(config));\n-\n+// utxos by address\n app.get('/utxos/:addr', (req, res) => {\n   const addr = req.params.addr;\n-  const utxos = [];\n-  UTXO.forEach((u, key) => {\n-    if (u.address === addr) {\n-      const [txid, index] = key.split(':');\n-      utxos.push({ txid, index: +index, amount: u.amount, address: u.address });\n+  const arr = [];\n+  for (const [k, v] of utxo.entries()) {\n+    if (v.address === addr) {\n+      const [txid, idx] = k.split(':');\n+      arr.push({ txid, index: +idx, amount: v.amount, blockHeight: v.blockHeight, isCoinbase: v.isCoinbase });\n     }\n-  });\n-  res.json({ utxos });\n+  }\n+  res.json({ utxos: arr });\n });\n \n+// tx lookup\n+app.get('/tx/:id', (req, res) => {\n+  const id = req.params.id;\n+  // search chain\n+  for (const b of chain) {\n+    const tx = b.transactions.find(t => t.id === id);\n+    if (tx) return res.json({ tx, blockHeight: b.index });\n+  }\n+  // mempool\n+  if (mempool[id]) return res.json({ tx: mempool[id], blockHeight: null });\n+  res.status(404).json({ error: 'tx not found' });\n+});\n \n+// submit transaction\n app.post('/transactions', (req, res) => {\n-  const tx = req.body;\n-\n-  if (mempool.length >= MEMPOOL_MAX)\n-    return res.status(400).json({ error: 'mempool full' });\n-\n-  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n-    return res.status(400).json({ error: 'missing outputs' });\n-\n-  tx.id = computeTxId(tx);\n-\n-  const v = validateTx(tx);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n-  tx.fee = v.fee;\n-\n-  if (conflictsWithMempool(tx))\n-    return res.status(400).json({ error: 'mempool double-spend' });\n-\n-  mempool.push(tx);\n-  console.log(`üí∞ TX accepted: ${tx.id.slice(0, 12)}... | fee=${tx.fee}`);\n-  wsBroadcast({ type: 'mempool_tx', tx });\n-  res.json({ status: 'added', id: tx.id });\n+  try {\n+    const tx = req.body;\n+    if (!tx.id) tx.id = txIdFor(tx);\n+    // don't accept if already in mempool or chain\n+    if (mempool[tx.id]) return res.status(400).json({ error: 'already in mempool' });\n+    // naive validation (uses current height)\n+    validateTx(tx, chain.length);\n+    mempool[tx.id] = tx;\n+    broadcast({ type: 'mempool_tx', tx });\n+    res.json({ ok: true, id: tx.id });\n+  } catch (e) {\n+    res.status(400).json({ error: e.message });\n+  }\n });\n \n+// submit block (from miner/peer)\n app.post('/blocks', (req, res) => {\n-  const block = req.body;\n-  const v = validateBlock(block);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n+  try {\n+    const block = req.body;\n+    // ensure block.difficulty equals current config.difficulty (we allow equal)\n+    // validate against current UTXO set\n+    validateBlock(block);\n+    applyBlock(block);\n+    maybeRetarget();\n+    broadcast({ type: 'new_block', block });\n+    res.json({ ok: true, height: block.index });\n+  } catch (e) {\n+    res.status(400).json({ error: e.message });\n+  }\n+});\n \n-  const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n-  if (fs.existsSync(filePath))\n-    return res.status(400).json({ error: 'block file already exists' });\n+// HTTP server + WS upgrade\n+const server = app.listen(3000, () => {\n+  console.log('Blockchain node started on port 3000');\n+  loadBlocks();\n+  if (chain.length === 0) {\n+    // create genesis\n+    const genesis = {\n+      index: 0,\n+      previousHash: '0',\n+      timestamp: Date.now(),\n+      transactions: [{\n+        id: 'genesis',\n+        isCoinbase: true,\n+        inputs: [],\n+        outputs: [{ address: 'genesis', amount: 0 }]\n+      }],\n+      merkleRoot: merkleRoot(['genesis']),\n+      nonce: 0,\n+      difficulty: config.difficulty\n+    };\n+    genesis.hash = headerHash(genesis);\n+    chain.push(genesis);\n+    saveBlock(genesis);\n+  }\n+  rebuildUTXO();\n+  console.log(`Loaded ${chain.length} blocks. Chain tip #${chain.length-1}`);\n+});\n \n-  fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n-  chain.push(block);\n-\n-  for (const tx of block.transactions) applyTxToUTXO(tx);\n-  const ids = new Set(block.transactions.map(t => t.id));\n-  mempool = mempool.filter(t => !ids.has(t.id));\n-\n-  console.log(`üß± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n-  wsBroadcast({\n-    type: 'new_block',\n-    header: {\n-      index: block.index,\n-      hash: block.hash,\n-      difficulty: block.difficulty,\n-      txs: block.transactions.length\n-    }\n+server.on('upgrade', (req, socket, head) => {\n+  wss.handleUpgrade(req, socket, head, ws => {\n+    sockets.add(ws);\n+    ws.on('message', msg => {\n+      // ignore for now\n+    });\n+    ws.on('close', () => sockets.delete(ws));\n+    // send initial tip/config\n+    ws.send(JSON.stringify({ type: 'welcome', tip: chain[chain.length -1] || null, config }));\n   });\n-\n-  adjustDifficulty(block.index);\n-  res.json({ status: 'block accepted', index: block.index });\n });\n \n-// ----------------------\n-// WebSocket Server\n-// ----------------------\n-const server = http.createServer(app);\n-const wss = new WebSocketServer({ server });\n-\n-function wsBroadcast(obj) {\n-  const msg = JSON.stringify(obj);\n-  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n+// internal utility: create a block candidate (used by miners remotely too)\n+function createBlockCandidate(coinbaseAddr, maxTx = config.maxBlockTx) {\n+  const tip = chain[chain.length - 1];\n+  const index = tip.index + 1;\n+  const previousHash = headerHash(tip);\n+  // select txs from mempool by fee-rate (not implemented: we assume fee included in outputs/in)\n+  const txs = [];\n+  // coinbase tx first\n+  const coinbase = {\n+    isCoinbase: true,\n+    inputs: [],\n+    outputs: [{ address: coinbaseAddr, amount: getBlockReward(index) }], // fee will be added after including txs\n+    id: null\n+  };\n+  // select txs up to max\n+  const pool = Object.values(mempool);\n+  // no fee-based sorting for simplicity: preserve insertion-like behavior\n+  for (const t of pool.slice(0, maxTx)) txs.push(t);\n+  // compute fee total and add to coinbase\n+  let feeTotal = 0;\n+  for (const tx of txs) {\n+    // compute fee (sum inputs from UTXO)\n+    let inSum = 0, outSum = 0;\n+    for (const inp of tx.inputs) {\n+      const entry = utxo.get(`${inp.txid}:${inp.index}`);\n+      if (entry) inSum += entry.amount;\n+    }\n+    for (const o of tx.outputs) outSum += o.amount;\n+    feeTotal += Math.max(0, inSum - outSum);\n+  }\n+  coinbase.outputs[0].amount += feeTotal;\n+  // finalize ids\n+  coinbase.id = txIdFor(coinbase);\n+  const finalTxs = [coinbase, ...txs];\n+  for (const t of finalTxs) if (!t.id) t.id = txIdFor(t);\n+  const merkle = merkleRoot(finalTxs.map(t => t.id));\n+  const candidate = {\n+    index, previousHash, timestamp: Date.now(), transactions: finalTxs,\n+    merkleRoot: merkle, nonce: 0, difficulty: config.difficulty\n+  };\n+  candidate.hash = headerHash(candidate);\n+  return candidate;\n }\n \n-wss.on('connection', (ws) => {\n-  console.log('üîå Miner connected');\n-  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n+// expose candidate endpoint for miners\n+app.get('/block/candidate/:address', (req, res) => {\n+  const addr = req.params.address;\n+  try {\n+    const cand = createBlockCandidate(addr);\n+    res.json(cand);\n+  } catch (e) {\n+    res.status(500).json({ error: e.message });\n+  }\n });\n-\n-// ----------------------\n-// Start\n-// ----------------------\n-server.listen(PORT, () => console.log(`üöÄ Node running on http://localhost:${PORT}`));\n"
                },
                {
                    "date": 1761995516791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n // -------------------- Config (editable) --------------------\n let config = {\n   // difficulty = number of leading hex '0' nibbles? We use hex chars '0' repeated.\n   // Each hex '0' is 4 leading zero bits. For simplicity we use hex-nibble prefix.\n-  difficulty: 4,            // initial difficulty = number of leading '0' hex chars required\n+  difficulty: 1,            // initial difficulty = number of leading '0' hex chars required\n   adjustEvery: 10,          // retarget every 10 blocks\n   targetBlockTimeSec: 15,   // target block time in seconds\n   blockSubsidy: 50,         // initial block reward\n   halvingInterval: 100,     // halving interval (in blocks) for demo\n"
                },
                {
                    "date": 1761995757013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n if (fs.existsSync(CONFIG_FILE)) {\n   try {\n     const loaded = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n     Object.assign(config, loaded);\n-  } catch(e) { /* ignore */ }\n+  } catch (e) { /* ignore */ }\n } else {\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n }\n \n@@ -55,9 +55,9 @@\n   const copy = {\n     inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey || null })),\n     outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n   };\n-  return sha256Hex(Buffer.from(stableStringify(copy)));\n+  return sha256Hex(Buffer.from(JSON.stringify(copy)));\n }\n \n // block header hash (hex)\n function headerHash(block) {\n@@ -89,9 +89,9 @@\n function loadBlocks() {\n   const files = fs.readdirSync(BLOCK_DIR).filter(f => f.endsWith('.json'));\n   const blocks = files\n     .map(f => ({ f, n: parseInt(f.split('_')[1]) }))\n-    .sort((a,b) => a.n - b.n)\n+    .sort((a, b) => a.n - b.n)\n     .map(x => JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${x.f}`, 'utf8')));\n   for (const b of blocks) {\n     chain.push(b);\n   }\n@@ -218,9 +218,9 @@\n   if (coinbaseCount !== 1) throw new Error('block must contain exactly 1 coinbase tx');\n   // check coinbase amount\n   const expected = getBlockReward(block.index) + feeTotal;\n   const coinbaseTx = block.transactions.find(t => t.isCoinbase);\n-  const coinbaseOut = coinbaseTx.outputs.reduce((s,o) => s + o.amount, 0);\n+  const coinbaseOut = coinbaseTx.outputs.reduce((s, o) => s + o.amount, 0);\n   if (coinbaseOut > expected) throw new Error(`coinbase too large: ${coinbaseOut} > ${expected}`);\n   return true;\n }\n \n@@ -378,9 +378,9 @@\n     chain.push(genesis);\n     saveBlock(genesis);\n   }\n   rebuildUTXO();\n-  console.log(`Loaded ${chain.length} blocks. Chain tip #${chain.length-1}`);\n+  console.log(`Loaded ${chain.length} blocks. Chain tip #${chain.length - 1}`);\n });\n \n server.on('upgrade', (req, socket, head) => {\n   wss.handleUpgrade(req, socket, head, ws => {\n@@ -389,9 +389,9 @@\n       // ignore for now\n     });\n     ws.on('close', () => sockets.delete(ws));\n     // send initial tip/config\n-    ws.send(JSON.stringify({ type: 'welcome', tip: chain[chain.length -1] || null, config }));\n+    ws.send(JSON.stringify({ type: 'welcome', tip: chain[chain.length - 1] || null, config }));\n   });\n });\n \n // internal utility: create a block candidate (used by miners remotely too)\n"
                },
                {
                    "date": 1761996676868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,366 +1,440 @@\n // apps/blockchain/server.js\n-// Full Node (simplified Bitcoin-like, educational)\n+// Mini Bitcoin-like Full Node (ECDSA verify + P2P + Compact Target Bits)\n // Run: node apps/blockchain/server.js\n \n const express = require('express');\n const bodyParser = require('body-parser');\n const fs = require('fs');\n const crypto = require('crypto');\n-const { WebSocketServer } = require('ws');\n const stableStringify = require('stable-stringify');\n+const { initP2P, p2pBroadcast, p2pOnMessage } = require('../p2p');\n \n+const log = (...a) => console.log('[NODE]', ...a);\n+const warn = (...a) => console.warn('[NODE]', ...a);\n+\n const app = express();\n-app.use(bodyParser.json());\n+app.use(bodyParser.json({ limit: '2mb' }));\n \n+// -------------------- Directories --------------------\n const DATA_DIR = __dirname + '/data';\n const BLOCK_DIR = DATA_DIR + '/blocks';\n-if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR);\n-if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR);\n+if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n+if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n-// -------------------- Config (editable) --------------------\n+// -------------------- Config --------------------\n let config = {\n-  // difficulty = number of leading hex '0' nibbles? We use hex chars '0' repeated.\n-  // Each hex '0' is 4 leading zero bits. For simplicity we use hex-nibble prefix.\n-  difficulty: 1,            // initial difficulty = number of leading '0' hex chars required\n-  adjustEvery: 10,          // retarget every 10 blocks\n-  targetBlockTimeSec: 15,   // target block time in seconds\n-  blockSubsidy: 50,         // initial block reward\n-  halvingInterval: 100,     // halving interval (in blocks) for demo\n-  coinbaseMaturity: 10,     // coinbase must wait this many confirmations\n-  maxBlockTx: 50,           // max tx per block\n+  httpPort: 3000,\n+  p2pPort: 3001,\n+  peers: [], // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n+  adjustEvery: 10,          // blocks per retarget\n+  targetBlockTimeSec: 15,   // target block time\n+  blockSubsidy: 50,\n+  halvingInterval: 100,     // in blocks\n+  coinbaseMaturity: 10,\n+  maxBlockTx: 100,\n+  // Compact difficulty bits (Bitcoin-like): 0x1eXXXXXX ~ easy; 0x1dXXXXXX is BTC-ish\n+  bits: 0x1f00ffff           // very easy default (increase difficulty by lowering exponent or mantissa)\n };\n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n-  try {\n-    const loaded = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n-    Object.assign(config, loaded);\n-  } catch (e) { /* ignore */ }\n+  try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch {}\n } else {\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n }\n \n-// -------------------- In-memory state --------------------\n-let chain = [];           // array of blocks\n-let mempool = {};         // txid -> tx\n-let utxo = new Map();     // key: `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n+// -------------------- State --------------------\n+let chain = [];             // array of blocks\n+let mempool = {};           // txid -> tx\n+let utxo = new Map();       // `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n+let seenTx = new Set();     // prevent gossip loops\n+let seenBlockHash = new Set();\n \n-// utility: sha256 hex\n-function sha256Hex(buf) {\n-  return crypto.createHash('sha256').update(buf).digest('hex');\n-}\n+// -------------------- Utils --------------------\n+const sha256Hex = (buf) => crypto.createHash('sha256').update(buf).digest('hex');\n \n-// canonical txid: hash of serialized tx without signatures (stable)\n function txIdFor(tx) {\n-  // remove sigs for id\n+  // deterministic id without sig variability: inputs(txid,index,pubKey) + outputs\n   const copy = {\n-    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey || null })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+    inputs: (tx.inputs || []).map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey })),\n+    outputs: (tx.outputs || []).map(o => ({ address: o.address, amount: o.amount }))\n   };\n-  return sha256Hex(Buffer.from(JSON.stringify(copy)));\n+  return sha256Hex(Buffer.from(stableStringify(copy)));\n }\n \n-// block header hash (hex)\n function headerHash(block) {\n-  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.difficulty}`;\n+  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`;\n   return sha256Hex(Buffer.from(header));\n }\n \n-// merkle root (simple): hashes txids pairwise\n function merkleRoot(txids) {\n   if (!txids.length) return sha256Hex(Buffer.from(''));\n-  let list = txids.map(t => Buffer.from(t, 'hex'));\n-  while (list.length > 1) {\n-    if (list.length % 2 === 1) list.push(list[list.length - 1]);\n+  let nodes = txids.map(t => Buffer.from(t, 'hex'));\n+  while (nodes.length > 1) {\n+    if (nodes.length % 2 === 1) nodes.push(nodes[nodes.length - 1]);\n     const next = [];\n-    for (let i = 0; i < list.length; i += 2) {\n-      next.push(Buffer.from(sha256Hex(Buffer.concat([list[i], list[i + 1]])), 'hex'));\n+    for (let i = 0; i < nodes.length; i += 2) {\n+      next.push(Buffer.from(sha256Hex(Buffer.concat([nodes[i], nodes[i + 1]])), 'hex'));\n     }\n-    list = next;\n+    nodes = next;\n   }\n-  return list[0].toString('hex');\n+  return nodes[0].toString('hex');\n }\n \n-// check hash meets difficulty (leading '0' hex chars)\n-function hashMeetsDifficulty(hexHash, difficulty) {\n-  return hexHash.startsWith('0'.repeat(difficulty));\n+// --- Compact Target Bits (Bitcoin-like) ---\n+function bitsToTarget(bits) {\n+  const exp = (bits >>> 24) & 0xff;\n+  let mant = BigInt(bits & 0x007fffff);\n+  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n+  // target = mantissa * 256^(exp-3)\n+  const shift = BigInt(8 * (exp - 3));\n+  return mant << shift;\n }\n-\n-// read blocks from disk at startup\n-function loadBlocks() {\n-  const files = fs.readdirSync(BLOCK_DIR).filter(f => f.endsWith('.json'));\n-  const blocks = files\n-    .map(f => ({ f, n: parseInt(f.split('_')[1]) }))\n-    .sort((a, b) => a.n - b.n)\n-    .map(x => JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${x.f}`, 'utf8')));\n-  for (const b of blocks) {\n-    chain.push(b);\n+function targetToBits(target) {\n+  // convert BigInt target to compact\n+  let hex = target.toString(16);\n+  if (hex.length % 2) hex = '0' + hex;\n+  const size = Math.ceil(hex.length / 2);\n+  let mant;\n+  if (size <= 3) {\n+    mant = BigInt('0x' + hex.padEnd(6, '0'));\n+  } else {\n+    mant = BigInt('0x' + hex.slice(0, 6));\n   }\n+  let bits = (size << 24) | Number(mant & 0x007fffff);\n+  return bits >>> 0;\n }\n+function hashMeetsBits(hexHash, bits) {\n+  const h = BigInt('0x' + hexHash);\n+  const target = bitsToTarget(bits);\n+  return h <= target;\n+}\n \n-// persist block\n+// -------------------- Persistence --------------------\n function saveBlock(block) {\n   fs.writeFileSync(`${BLOCK_DIR}/block_${block.index}.json`, JSON.stringify(block, null, 2));\n }\n-\n-// rebuild UTXO from chain\n+function loadBlocks() {\n+  const files = fs.readdirSync(BLOCK_DIR).filter(f => f.startsWith('block_') && f.endsWith('.json'));\n+  files.sort((a,b)=> parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));\n+  for (const f of files) {\n+    const b = JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${f}`, 'utf8'));\n+    chain.push(b);\n+    seenBlockHash.add(headerHash(b));\n+  }\n+}\n function rebuildUTXO() {\n   utxo = new Map();\n-  for (let h = 0; h < chain.length; h++) {\n-    const block = chain[h];\n-    for (const tx of block.transactions) {\n-      const tid = tx.id;\n-      // remove spent inputs\n-      for (const inp of tx.inputs || []) {\n-        const key = `${inp.txid}:${inp.index}`;\n-        utxo.delete(key);\n-      }\n+  for (const b of chain) {\n+    for (const tx of b.transactions) {\n+      // spend inputs\n+      for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n       // add outputs\n-      tx.outputs.forEach((out, idx) => {\n-        const key = `${tid}:${idx}`;\n-        utxo.set(key, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase });\n+      tx.outputs.forEach((o, idx) => {\n+        utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: b.index, isCoinbase: !!tx.isCoinbase });\n       });\n     }\n   }\n }\n \n-// get block reward based on height (halving)\n+// -------------------- Consensus Rules --------------------\n function getBlockReward(height) {\n   const halvings = Math.floor(height / config.halvingInterval);\n-  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n-  return Math.max(reward, 0);\n+  const r = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n+  return Math.max(r, 0);\n }\n \n-// validate transaction (basic): inputs exist in UTXO and sum in >= sum out + fee, signatures assumed valid (educational)\n+function pubKeyToAddress(pubKeyHex) {\n+  // address = RIPEMD160(SHA256(pubKey))\n+  const sha = crypto.createHash('sha256').update(Buffer.from(pubKeyHex, 'hex')).digest();\n+  return crypto.createHash('ripemd160').update(sha).digest('hex');\n+}\n+\n+function verifyInputSig(tx, inputIndex) {\n+  const ec = new (require('elliptic').ec)('secp256k1');\n+  const inp = tx.inputs[inputIndex];\n+  const pub = inp.pubKey;\n+  const sigHex = inp.sig;\n+  if (!pub || !sigHex) throw new Error('missing pubKey or sig');\n+\n+  // Sighash (ALL): hash( stableStringify({inputs:[{txid,index}], outputs}) )\n+  const msg = sha256Hex(Buffer.from(stableStringify({\n+    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  })));\n+\n+  const key = ec.keyFromPublic(pub, 'hex');\n+  const sig = Buffer.from(sigHex, 'hex');\n+  let ok = false;\n+  try { ok = key.verify(msg, sig); } catch { ok = false; }\n+  if (!ok) throw new Error('bad signature');\n+  return true;\n+}\n+\n function validateTx(tx, currentHeight) {\n-  if (!tx || !tx.inputs || !tx.outputs) throw new Error('invalid tx format');\n-  // coinbase: special\n+  if (!tx || !Array.isArray(tx.inputs) || !Array.isArray(tx.outputs)) throw new Error('invalid tx format');\n+\n   if (tx.isCoinbase) {\n-    // coinbase rules: only outputs, no inputs\n-    if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n-    // later block validation ensures coinbase reward <= expected\n+    if (tx.inputs.length !== 0) throw new Error('coinbase must have no inputs');\n+    tx.outputs.forEach(o => { if (o.amount <= 0) throw new Error('coinbase bad amount'); });\n     return true;\n   }\n-  let inSum = 0;\n-  let outSum = 0;\n-  // check inputs exist, not double spending mempool-internal\n-  const usedKeys = new Set();\n-  for (const inp of tx.inputs) {\n-    const key = `${inp.txid}:${inp.index}`;\n-    if (usedKeys.has(key)) throw new Error('double spend in tx');\n-    usedKeys.add(key);\n-    const u = utxo.get(key);\n-    if (!u) throw new Error('input missing UTXO: ' + key);\n-    // coinbase maturity\n-    if (u.isCoinbase && (currentHeight - u.blockHeight) < config.coinbaseMaturity) throw new Error('coinbase input not matured');\n-    inSum += u.amount;\n+\n+  let inSum = 0, outSum = 0;\n+  const used = new Set();\n+\n+  // check inputs exist & mature & signatures correct & address matches pubKey\n+  for (let idx = 0; idx < tx.inputs.length; idx++) {\n+    const i = tx.inputs[idx];\n+    const key = `${i.txid}:${i.index}`;\n+    if (used.has(key)) throw new Error('double spend in tx');\n+    used.add(key);\n+\n+    const entry = utxo.get(key);\n+    if (!entry) throw new Error('missing UTXO ' + key);\n+    if (entry.isCoinbase && (currentHeight - entry.blockHeight) < config.coinbaseMaturity)\n+      throw new Error('coinbase not mature');\n+\n+    // verify signature\n+    verifyInputSig(tx, idx);\n+\n+    // verify that provided pubKey actually controls the referenced output address\n+    const addr = pubKeyToAddress(i.pubKey);\n+    if (addr !== entry.address) throw new Error('pubKey does not match UTXO address');\n+\n+    inSum += entry.amount;\n   }\n+\n   for (const o of tx.outputs) {\n-    if (o.amount <= 0) throw new Error('output amount <= 0');\n+    if (o.amount <= 0) throw new Error('output <= 0');\n     outSum += o.amount;\n   }\n   if (inSum < outSum) throw new Error('inputs < outputs');\n-  // signature verification omitted for brevity ‚Äî assume signing handled by client (educational)\n   return true;\n }\n \n-// validate block\n function validateBlock(block) {\n-  // index and previousHash\n   const tip = chain[chain.length - 1];\n   if (chain.length === 0) {\n-    if (block.index !== 0) throw new Error('genesis must index 0');\n+    if (block.index !== 0) throw new Error('genesis index must be 0');\n   } else {\n-    if (block.previousHash !== headerHash(tip)) throw new Error('previousHash mismatch');\n     if (block.index !== tip.index + 1) throw new Error('bad index');\n+    if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n   }\n-  // merkle root\n+\n+  // basic header checks\n   const txids = block.transactions.map(t => t.id);\n   if (merkleRoot(txids) !== block.merkleRoot) throw new Error('merkle mismatch');\n-  // hash -> difficulty\n-  const h = headerHash(block);\n-  if (!hashMeetsDifficulty(h, block.difficulty)) throw new Error('PoW not satisfied');\n-  // transactions validity: coinbase rules, sums\n+  const hh = headerHash(block);\n+  if (!hashMeetsBits(hh, block.bits)) throw new Error('insufficient PoW');\n+\n+  // tx rules\n+  let coinbaseCount = 0;\n   let feeTotal = 0;\n-  let coinbaseCount = 0;\n-  // create temporary UTXO snapshot (shallow copy)\n-  const utxoTemp = new Map(utxo);\n+\n+  // temp UTXO (for intra-block spends)\n+  const temp = new Map(utxo);\n   for (const tx of block.transactions) {\n     if (tx.isCoinbase) {\n       coinbaseCount++;\n-      // coinbase should have no inputs\n       if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n-      // we'll check coinbase amount later\n-      // add outputs to utxoTemp\n-      tx.outputs.forEach((out, idx) => {\n-        utxoTemp.set(`${tx.id}:${idx}`, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: true });\n-      });\n+      // add outputs\n+      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: true }));\n     } else {\n-      // check inputs exist in utxoTemp\n+      // spend\n       let inSum = 0, outSum = 0;\n-      for (const inp of tx.inputs) {\n-        const key = `${inp.txid}:${inp.index}`;\n-        const entry = utxoTemp.get(key);\n-        if (!entry) throw new Error('missing input in block tx: ' + key);\n-        inSum += entry.amount;\n-        utxoTemp.delete(key);\n+      for (let idx = 0; idx < tx.inputs.length; idx++) {\n+        const i = tx.inputs[idx];\n+        const key = `${i.txid}:${i.index}`;\n+        const ent = temp.get(key);\n+        if (!ent) throw new Error('missing input ' + key);\n+        // signature check against original tx object (already contains sigs)\n+        verifyInputSig(tx, idx);\n+        // pubKey matches address\n+        const addr = pubKeyToAddress(i.pubKey);\n+        if (addr !== ent.address) throw new Error('pubKey!=address');\n+        inSum += ent.amount;\n+        temp.delete(key);\n       }\n-      for (const out of tx.outputs) {\n-        outSum += out.amount;\n-      }\n+      tx.outputs.forEach(o => outSum += o.amount);\n       if (inSum < outSum) throw new Error('tx spends more than inputs');\n       feeTotal += (inSum - outSum);\n       // add outputs\n-      tx.outputs.forEach((out, idx) => {\n-        utxoTemp.set(`${tx.id}:${idx}`, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: false });\n-      });\n+      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: false }));\n     }\n   }\n-  if (coinbaseCount !== 1) throw new Error('block must contain exactly 1 coinbase tx');\n-  // check coinbase amount\n+  if (coinbaseCount !== 1) throw new Error('block must have exactly 1 coinbase');\n+\n+  // coinbase value <= subsidy + fees\n   const expected = getBlockReward(block.index) + feeTotal;\n-  const coinbaseTx = block.transactions.find(t => t.isCoinbase);\n-  const coinbaseOut = coinbaseTx.outputs.reduce((s, o) => s + o.amount, 0);\n-  if (coinbaseOut > expected) throw new Error(`coinbase too large: ${coinbaseOut} > ${expected}`);\n+  const coinbase = block.transactions.find(t => t.isCoinbase);\n+  const cbOut = coinbase.outputs.reduce((s, o) => s + o.amount, 0);\n+  if (cbOut > expected) throw new Error(`coinbase too large: ${cbOut} > ${expected}`);\n+\n   return true;\n }\n \n-// apply a block (assumes valid)\n function applyBlock(block) {\n-  // remove spent UTXOs and add outputs\n+  // spend & create\n   for (const tx of block.transactions) {\n-    for (const inp of tx.inputs || []) {\n-      const key = `${inp.txid}:${inp.index}`;\n-      utxo.delete(key);\n-    }\n-    tx.outputs.forEach((out, idx) => {\n-      const key = `${tx.id}:${idx}`;\n-      utxo.set(key, { amount: out.amount, address: out.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase });\n-    });\n-    // remove tx from mempool\n+    for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n+    tx.outputs.forEach((o, idx) => utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase }));\n     if (mempool[tx.id]) delete mempool[tx.id];\n   }\n   chain.push(block);\n   saveBlock(block);\n-  // write config occasionally\n+  seenBlockHash.add(headerHash(block));\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+  log(`Accepted block #${block.index} hash=${headerHash(block).slice(0,16)}‚Ä¶ txs=${block.transactions.length}`);\n }\n \n-// difficulty retargeting (called when new block appended)\n function maybeRetarget() {\n-  const height = chain.length;\n-  if (height > 0 && height % config.adjustEvery === 0) {\n-    const last = chain[height - 1];\n-    const first = chain[Math.max(0, height - config.adjustEvery)];\n-    const actualTime = (last.timestamp - first.timestamp) / 1000;\n-    const expectedTime = config.adjustEvery * config.targetBlockTimeSec;\n-    let ratio = expectedTime / (actualTime || 1);\n-    // clamp ratio to avoid huge jumps\n-    const minRatio = 0.25, maxRatio = 4;\n-    if (ratio < minRatio) ratio = minRatio;\n-    if (ratio > maxRatio) ratio = maxRatio;\n-    const newDifficulty = Math.max(1, Math.round(config.difficulty * ratio));\n-    console.log(`Retarget: height=${height} actual=${actualTime}s expected=${expectedTime}s ratio=${ratio.toFixed(3)} diff ${config.difficulty} -> ${newDifficulty}`);\n-    config.difficulty = newDifficulty;\n-    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  }\n-}\n+  const h = chain.length;\n+  if (h === 0 || h % config.adjustEvery !== 0) return;\n+  const last = chain[h - 1];\n+  const first = chain[h - config.adjustEvery];\n+  const actual = (last.timestamp - first.timestamp) / 1000;\n+  const expected = config.adjustEvery * config.targetBlockTimeSec;\n+  let ratio = expected / (actual || 1);\n+  // clamp (like BTC caps to 4x)\n+  const minR = 0.25, maxR = 4;\n+  if (ratio < minR) ratio = minR;\n+  if (ratio > maxR) ratio = maxR;\n \n-// Broadcast helpers (WebSocket)\n-const wss = new WebSocketServer({ noServer: true });\n-let sockets = new Set();\n-\n-function broadcast(msg) {\n-  const s = JSON.stringify(msg);\n-  for (const ws of sockets) {\n-    if (ws.readyState === ws.OPEN) ws.send(s);\n-  }\n+  const curTarget = bitsToTarget(config.bits);\n+  let newTarget = BigInt(curTarget / BigInt(Math.round(1 / ratio * 1e6))) * BigInt(1e6); // smooth-ish\n+  if (newTarget <= 0n) newTarget = 1n;\n+  const newBits = targetToBits(newTarget);\n+  log(`Retarget @${h}: actual=${actual.toFixed(2)}s expected=${expected}s ratio=${ratio.toFixed(3)} bits ${config.bits.toString(16)} -> ${newBits.toString(16)}`);\n+  config.bits = newBits >>> 0;\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n }\n \n-// -------------------- Endpoints --------------------\n-\n-// basic info\n-app.get('/config', (req, res) => {\n-  res.json(config);\n-});\n-\n-// chain / tip\n-app.get('/chain', (req, res) => res.json(chain));\n-app.get('/tip', (req, res) => res.json(chain[chain.length - 1] || null));\n-app.get('/block/:height', (req, res) => {\n-  const h = parseInt(req.params.height);\n-  if (isNaN(h) || h < 0 || h >= chain.length) return res.status(404).json({ error: 'not found' });\n+// -------------------- API --------------------\n+app.get('/config', (req,res)=> res.json(config));\n+app.get('/chain', (req,res)=> res.json(chain));\n+app.get('/tip', (req,res)=> res.json(chain[chain.length-1] || null));\n+app.get('/block/:h', (req,res)=> {\n+  const h = +req.params.h;\n+  if (Number.isNaN(h) || h<0 || h>=chain.length) return res.status(404).json({error:'not found'});\n   res.json(chain[h]);\n });\n-\n-// mempool\n-app.get('/mempool', (req, res) => res.json(Object.values(mempool)));\n-\n-// utxos by address\n-app.get('/utxos/:addr', (req, res) => {\n+app.get('/mempool', (req,res)=> res.json(Object.values(mempool)));\n+app.get('/utxos/:addr', (req,res)=> {\n   const addr = req.params.addr;\n-  const arr = [];\n-  for (const [k, v] of utxo.entries()) {\n+  const out = [];\n+  for (const [k,v] of utxo.entries()) {\n     if (v.address === addr) {\n-      const [txid, idx] = k.split(':');\n-      arr.push({ txid, index: +idx, amount: v.amount, blockHeight: v.blockHeight, isCoinbase: v.isCoinbase });\n+      const [txid,idx]=k.split(':');\n+      out.push({txid,index:+idx,amount:v.amount,blockHeight:v.blockHeight,isCoinbase:v.isCoinbase});\n     }\n   }\n-  res.json({ utxos: arr });\n+  res.json({utxos: out});\n });\n-\n-// tx lookup\n-app.get('/tx/:id', (req, res) => {\n+app.get('/tx/:id', (req,res)=> {\n   const id = req.params.id;\n-  // search chain\n   for (const b of chain) {\n-    const tx = b.transactions.find(t => t.id === id);\n-    if (tx) return res.json({ tx, blockHeight: b.index });\n+    const t = b.transactions.find(x=>x.id===id);\n+    if (t) return res.json({tx:t, blockHeight: b.index});\n   }\n-  // mempool\n-  if (mempool[id]) return res.json({ tx: mempool[id], blockHeight: null });\n-  res.status(404).json({ error: 'tx not found' });\n+  if (mempool[id]) return res.json({tx:mempool[id], blockHeight:null});\n+  res.status(404).json({error:'not found'});\n });\n \n-// submit transaction\n-app.post('/transactions', (req, res) => {\n+app.post('/transactions', (req,res)=> {\n   try {\n     const tx = req.body;\n     if (!tx.id) tx.id = txIdFor(tx);\n-    // don't accept if already in mempool or chain\n-    if (mempool[tx.id]) return res.status(400).json({ error: 'already in mempool' });\n-    // naive validation (uses current height)\n+    // validation against current UTXO/state\n     validateTx(tx, chain.length);\n+    if (mempool[tx.id]) return res.status(200).json({ ok:true, id: tx.id, note:'duplicate in mempool' });\n     mempool[tx.id] = tx;\n-    broadcast({ type: 'mempool_tx', tx });\n-    res.json({ ok: true, id: tx.id });\n-  } catch (e) {\n-    res.status(400).json({ error: e.message });\n+    seenTx.add(tx.id);\n+    log(`+ mempool tx ${tx.id.slice(0,16)}‚Ä¶`);\n+    // Gossip to peers\n+    p2pBroadcast({ type:'tx', tx });\n+    res.json({ ok:true, id: tx.id });\n+  } catch(e) {\n+    return res.status(400).json({ error: e.message });\n   }\n });\n \n-// submit block (from miner/peer)\n-app.post('/blocks', (req, res) => {\n+app.post('/blocks', (req,res)=> {\n   try {\n     const block = req.body;\n-    // ensure block.difficulty equals current config.difficulty (we allow equal)\n-    // validate against current UTXO set\n+    // recompute ids if missing\n+    for (const t of block.transactions) if (!t.id) t.id = txIdFor(t);\n+    // validate & apply\n     validateBlock(block);\n     applyBlock(block);\n     maybeRetarget();\n-    broadcast({ type: 'new_block', block });\n-    res.json({ ok: true, height: block.index });\n-  } catch (e) {\n-    res.status(400).json({ error: e.message });\n+    // gossip\n+    p2pBroadcast({ type:'block', block });\n+    res.json({ ok:true, height: block.index });\n+  } catch(e) {\n+    return res.status(400).json({ error: e.message });\n   }\n });\n \n-// HTTP server + WS upgrade\n-const server = app.listen(3000, () => {\n-  console.log('Blockchain node started on port 3000');\n+// block candidate for miners\n+app.get('/block/candidate/:address', (req,res)=> {\n+  try {\n+    const addr = req.params.address;\n+    const tip = chain[chain.length-1];\n+    const index = tip.index + 1;\n+    const previousHash = headerHash(tip);\n+\n+    // Build coinbase\n+    const txs = [];\n+    const coinbase = {\n+      isCoinbase: true,\n+      inputs: [],\n+      outputs: [{ address: addr, amount: getBlockReward(index) }],\n+      id: null\n+    };\n+\n+    // pick some mempool txs (no fee sorting here for brevity)\n+    const pool = Object.values(mempool).slice(0, config.maxBlockTx);\n+    // Compute fees to add to coinbase\n+    let fee = 0;\n+    for (const t of pool) {\n+      let inSum = 0, outSum = 0;\n+      for (const i of t.inputs) {\n+        const u = utxo.get(`${i.txid}:${i.index}`);\n+        if (u) inSum += u.amount;\n+      }\n+      for (const o of t.outputs) outSum += o.amount;\n+      if (inSum > outSum) fee += (inSum - outSum);\n+      txs.push(t);\n+    }\n+    coinbase.outputs[0].amount += fee;\n+\n+    // finalize ids\n+    coinbase.id = txIdFor(coinbase);\n+    const list = [coinbase, ...txs];\n+    list.forEach(t => { if (!t.id) t.id = txIdFor(t); });\n+\n+    const block = {\n+      index,\n+      previousHash,\n+      timestamp: Date.now(),\n+      transactions: list,\n+      merkleRoot: merkleRoot(list.map(t=>t.id)),\n+      nonce: 0,\n+      bits: config.bits\n+    };\n+    block.hash = headerHash(block);\n+    res.json(block);\n+  } catch(e) {\n+    res.status(500).json({ error: e.message });\n+  }\n+});\n+\n+// -------------------- Boot --------------------\n+const server = app.listen(config.httpPort, () => {\n+  log(`HTTP listening on ${config.httpPort}`);\n   loadBlocks();\n   if (chain.length === 0) {\n-    // create genesis\n     const genesis = {\n       index: 0,\n       previousHash: '0',\n       timestamp: Date.now(),\n@@ -371,80 +445,54 @@\n         outputs: [{ address: 'genesis', amount: 0 }]\n       }],\n       merkleRoot: merkleRoot(['genesis']),\n       nonce: 0,\n-      difficulty: config.difficulty\n+      bits: config.bits\n     };\n     genesis.hash = headerHash(genesis);\n+    saveBlock(genesis);\n     chain.push(genesis);\n-    saveBlock(genesis);\n+    seenBlockHash.add(headerHash(genesis));\n   }\n   rebuildUTXO();\n-  console.log(`Loaded ${chain.length} blocks. Chain tip #${chain.length - 1}`);\n+  log(`Loaded ${chain.length} blocks. Tip #${chain.length-1}`);\n });\n \n-server.on('upgrade', (req, socket, head) => {\n-  wss.handleUpgrade(req, socket, head, ws => {\n-    sockets.add(ws);\n-    ws.on('message', msg => {\n-      // ignore for now\n-    });\n-    ws.on('close', () => sockets.delete(ws));\n-    // send initial tip/config\n-    ws.send(JSON.stringify({ type: 'welcome', tip: chain[chain.length - 1] || null, config }));\n-  });\n-});\n+// -------------------- P2P Wiring --------------------\n+initP2P({ p2pPort: config.p2pPort, peers: config.peers, onOpen: () => {\n+  log(`P2P listening on ${config.p2pPort} peers=${config.peers.length}`);\n+}});\n \n-// internal utility: create a block candidate (used by miners remotely too)\n-function createBlockCandidate(coinbaseAddr, maxTx = config.maxBlockTx) {\n-  const tip = chain[chain.length - 1];\n-  const index = tip.index + 1;\n-  const previousHash = headerHash(tip);\n-  // select txs from mempool by fee-rate (not implemented: we assume fee included in outputs/in)\n-  const txs = [];\n-  // coinbase tx first\n-  const coinbase = {\n-    isCoinbase: true,\n-    inputs: [],\n-    outputs: [{ address: coinbaseAddr, amount: getBlockReward(index) }], // fee will be added after including txs\n-    id: null\n-  };\n-  // select txs up to max\n-  const pool = Object.values(mempool);\n-  // no fee-based sorting for simplicity: preserve insertion-like behavior\n-  for (const t of pool.slice(0, maxTx)) txs.push(t);\n-  // compute fee total and add to coinbase\n-  let feeTotal = 0;\n-  for (const tx of txs) {\n-    // compute fee (sum inputs from UTXO)\n-    let inSum = 0, outSum = 0;\n-    for (const inp of tx.inputs) {\n-      const entry = utxo.get(`${inp.txid}:${inp.index}`);\n-      if (entry) inSum += entry.amount;\n+// Incoming P2P messages\n+p2pOnMessage(async (msg) => {\n+  try {\n+    if (msg.type === 'tx') {\n+      const tx = msg.tx;\n+      if (!tx.id) tx.id = txIdFor(tx);\n+      if (seenTx.has(tx.id) || mempool[tx.id]) return;\n+      validateTx(tx, chain.length);\n+      mempool[tx.id] = tx;\n+      seenTx.add(tx.id);\n+      log(`[P2P] tx ${tx.id.slice(0,12)}‚Ä¶ added from peer`);\n+      // rebroadcast\n+      p2pBroadcast({ type:'tx', tx });\n+    } else if (msg.type === 'block') {\n+      const b = msg.block;\n+      const hh = headerHash(b);\n+      if (seenBlockHash.has(hh)) return;\n+      // ensure tx ids present\n+      for (const t of b.transactions) if (!t.id) t.id = txIdFor(t);\n+      validateBlock(b);\n+      applyBlock(b);\n+      maybeRetarget();\n+      log(`[P2P] block #${b.index} accepted from peer`);\n+      p2pBroadcast({ type:'block', block: b });\n+    } else if (msg.type === 'get_tip') {\n+      const tip = chain[chain.length-1];\n+      p2pBroadcast({ type:'tip', tip });\n+    } else if (msg.type === 'tip') {\n+      // could implement fork-choice here (highest cumulative work) ‚Äì omitted for brevity in this step\n     }\n-    for (const o of tx.outputs) outSum += o.amount;\n-    feeTotal += Math.max(0, inSum - outSum);\n-  }\n-  coinbase.outputs[0].amount += feeTotal;\n-  // finalize ids\n-  coinbase.id = txIdFor(coinbase);\n-  const finalTxs = [coinbase, ...txs];\n-  for (const t of finalTxs) if (!t.id) t.id = txIdFor(t);\n-  const merkle = merkleRoot(finalTxs.map(t => t.id));\n-  const candidate = {\n-    index, previousHash, timestamp: Date.now(), transactions: finalTxs,\n-    merkleRoot: merkle, nonce: 0, difficulty: config.difficulty\n-  };\n-  candidate.hash = headerHash(candidate);\n-  return candidate;\n-}\n-\n-// expose candidate endpoint for miners\n-app.get('/block/candidate/:address', (req, res) => {\n-  const addr = req.params.address;\n-  try {\n-    const cand = createBlockCandidate(addr);\n-    res.json(cand);\n   } catch (e) {\n-    res.status(500).json({ error: e.message });\n+    warn('[P2P msg error]', e.message);\n   }\n });\n"
                },
                {
                    "date": 1761996768347,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,8 @@\n const express = require('express');\n const bodyParser = require('body-parser');\n const fs = require('fs');\n const crypto = require('crypto');\n-const stableStringify = require('stable-stringify');\n const { initP2P, p2pBroadcast, p2pOnMessage } = require('../p2p');\n \n const log = (...a) => console.log('[NODE]', ...a);\n const warn = (...a) => console.warn('[NODE]', ...a);\n@@ -57,9 +56,9 @@\n   const copy = {\n     inputs: (tx.inputs || []).map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey })),\n     outputs: (tx.outputs || []).map(o => ({ address: o.address, amount: o.amount }))\n   };\n-  return sha256Hex(Buffer.from(stableStringify(copy)));\n+  return sha256Hex(Buffer.from(JSON.stringify(copy)));\n }\n \n function headerHash(block) {\n   const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`;\n"
                },
                {
                    "date": 1761996800452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,10 +154,10 @@\n   const pub = inp.pubKey;\n   const sigHex = inp.sig;\n   if (!pub || !sigHex) throw new Error('missing pubKey or sig');\n \n-  // Sighash (ALL): hash( stableStringify({inputs:[{txid,index}], outputs}) )\n-  const msg = sha256Hex(Buffer.from(stableStringify({\n+  // Sighash (ALL): hash( JSON.stringify({inputs:[{txid,index}], outputs}) )\n+  const msg = sha256Hex(Buffer.from(JSON.stringify({\n     inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n     outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n   })));\n \n"
                },
                {
                    "date": 1761998051984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n const express = require('express');\n const bodyParser = require('body-parser');\n const fs = require('fs');\n const crypto = require('crypto');\n-const { initP2P, p2pBroadcast, p2pOnMessage } = require('../p2p');\n+const { initP2P, p2pBroadcast, p2pOnMessage } = require('./p2p');\n \n const log = (...a) => console.log('[NODE]', ...a);\n const warn = (...a) => console.warn('[NODE]', ...a);\n \n"
                },
                {
                    "date": 1761999942921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n // -------------------- Config --------------------\n let config = {\n-  httpPort: 3000,\n+  httpPort: process.env.,\n   p2pPort: 3001,\n   peers: [], // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n   adjustEvery: 10,          // blocks per retarget\n   targetBlockTimeSec: 15,   // target block time\n"
                },
                {
                    "date": 1761999952810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,10 +21,10 @@\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n // -------------------- Config --------------------\n let config = {\n-  httpPort: process.env.,\n-  p2pPort: 3001,\n+  httpPort: process.env.PORT,\n+  p2pPort: process.env.PORT,\n   peers: [], // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n   adjustEvery: 10,          // blocks per retarget\n   targetBlockTimeSec: 15,   // target block time\n   blockSubsidy: 50,\n"
                },
                {
                    "date": 1761999980741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,10 +22,10 @@\n \n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n-  p2pPort: process.env.PORT,\n-  peers: [], // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n+  p2pPort: process.env.P2P_PORT,\n+  peers: process.env, // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n   adjustEvery: 10,          // blocks per retarget\n   targetBlockTimeSec: 15,   // target block time\n   blockSubsidy: 50,\n   halvingInterval: 100,     // in blocks\n"
                },
                {
                    "date": 1762000013905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n   p2pPort: process.env.P2P_PORT,\n-  peers: process.env, // e.g. [\"ws://localhost:4001\",\"ws://localhost:5001\"]\n+  peers: process.env.PEERS ? JSON.parse(process.env.PEERS) : [],\n   adjustEvery: 10,          // blocks per retarget\n   targetBlockTimeSec: 15,   // target block time\n   blockSubsidy: 50,\n   halvingInterval: 100,     // in blocks\n@@ -35,9 +35,9 @@\n   bits: 0x1f00ffff           // very easy default (increase difficulty by lowering exponent or mantissa)\n };\n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n-  try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch {}\n+  try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch { }\n } else {\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n }\n \n@@ -113,9 +113,9 @@\n   fs.writeFileSync(`${BLOCK_DIR}/block_${block.index}.json`, JSON.stringify(block, null, 2));\n }\n function loadBlocks() {\n   const files = fs.readdirSync(BLOCK_DIR).filter(f => f.startsWith('block_') && f.endsWith('.json'));\n-  files.sort((a,b)=> parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));\n+  files.sort((a, b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));\n   for (const f of files) {\n     const b = JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${f}`, 'utf8'));\n     chain.push(b);\n     seenBlockHash.add(headerHash(b));\n@@ -282,9 +282,9 @@\n   chain.push(block);\n   saveBlock(block);\n   seenBlockHash.add(headerHash(block));\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  log(`Accepted block #${block.index} hash=${headerHash(block).slice(0,16)}‚Ä¶ txs=${block.transactions.length}`);\n+  log(`Accepted block #${block.index} hash=${headerHash(block).slice(0, 16)}‚Ä¶ txs=${block.transactions.length}`);\n }\n \n function maybeRetarget() {\n   const h = chain.length;\n@@ -308,57 +308,57 @@\n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n }\n \n // -------------------- API --------------------\n-app.get('/config', (req,res)=> res.json(config));\n-app.get('/chain', (req,res)=> res.json(chain));\n-app.get('/tip', (req,res)=> res.json(chain[chain.length-1] || null));\n-app.get('/block/:h', (req,res)=> {\n+app.get('/config', (req, res) => res.json(config));\n+app.get('/chain', (req, res) => res.json(chain));\n+app.get('/tip', (req, res) => res.json(chain[chain.length - 1] || null));\n+app.get('/block/:h', (req, res) => {\n   const h = +req.params.h;\n-  if (Number.isNaN(h) || h<0 || h>=chain.length) return res.status(404).json({error:'not found'});\n+  if (Number.isNaN(h) || h < 0 || h >= chain.length) return res.status(404).json({ error: 'not found' });\n   res.json(chain[h]);\n });\n-app.get('/mempool', (req,res)=> res.json(Object.values(mempool)));\n-app.get('/utxos/:addr', (req,res)=> {\n+app.get('/mempool', (req, res) => res.json(Object.values(mempool)));\n+app.get('/utxos/:addr', (req, res) => {\n   const addr = req.params.addr;\n   const out = [];\n-  for (const [k,v] of utxo.entries()) {\n+  for (const [k, v] of utxo.entries()) {\n     if (v.address === addr) {\n-      const [txid,idx]=k.split(':');\n-      out.push({txid,index:+idx,amount:v.amount,blockHeight:v.blockHeight,isCoinbase:v.isCoinbase});\n+      const [txid, idx] = k.split(':');\n+      out.push({ txid, index: +idx, amount: v.amount, blockHeight: v.blockHeight, isCoinbase: v.isCoinbase });\n     }\n   }\n-  res.json({utxos: out});\n+  res.json({ utxos: out });\n });\n-app.get('/tx/:id', (req,res)=> {\n+app.get('/tx/:id', (req, res) => {\n   const id = req.params.id;\n   for (const b of chain) {\n-    const t = b.transactions.find(x=>x.id===id);\n-    if (t) return res.json({tx:t, blockHeight: b.index});\n+    const t = b.transactions.find(x => x.id === id);\n+    if (t) return res.json({ tx: t, blockHeight: b.index });\n   }\n-  if (mempool[id]) return res.json({tx:mempool[id], blockHeight:null});\n-  res.status(404).json({error:'not found'});\n+  if (mempool[id]) return res.json({ tx: mempool[id], blockHeight: null });\n+  res.status(404).json({ error: 'not found' });\n });\n \n-app.post('/transactions', (req,res)=> {\n+app.post('/transactions', (req, res) => {\n   try {\n     const tx = req.body;\n     if (!tx.id) tx.id = txIdFor(tx);\n     // validation against current UTXO/state\n     validateTx(tx, chain.length);\n-    if (mempool[tx.id]) return res.status(200).json({ ok:true, id: tx.id, note:'duplicate in mempool' });\n+    if (mempool[tx.id]) return res.status(200).json({ ok: true, id: tx.id, note: 'duplicate in mempool' });\n     mempool[tx.id] = tx;\n     seenTx.add(tx.id);\n-    log(`+ mempool tx ${tx.id.slice(0,16)}‚Ä¶`);\n+    log(`+ mempool tx ${tx.id.slice(0, 16)}‚Ä¶`);\n     // Gossip to peers\n-    p2pBroadcast({ type:'tx', tx });\n-    res.json({ ok:true, id: tx.id });\n-  } catch(e) {\n+    p2pBroadcast({ type: 'tx', tx });\n+    res.json({ ok: true, id: tx.id });\n+  } catch (e) {\n     return res.status(400).json({ error: e.message });\n   }\n });\n \n-app.post('/blocks', (req,res)=> {\n+app.post('/blocks', (req, res) => {\n   try {\n     const block = req.body;\n     // recompute ids if missing\n     for (const t of block.transactions) if (!t.id) t.id = txIdFor(t);\n@@ -366,20 +366,20 @@\n     validateBlock(block);\n     applyBlock(block);\n     maybeRetarget();\n     // gossip\n-    p2pBroadcast({ type:'block', block });\n-    res.json({ ok:true, height: block.index });\n-  } catch(e) {\n+    p2pBroadcast({ type: 'block', block });\n+    res.json({ ok: true, height: block.index });\n+  } catch (e) {\n     return res.status(400).json({ error: e.message });\n   }\n });\n \n // block candidate for miners\n-app.get('/block/candidate/:address', (req,res)=> {\n+app.get('/block/candidate/:address', (req, res) => {\n   try {\n     const addr = req.params.address;\n-    const tip = chain[chain.length-1];\n+    const tip = chain[chain.length - 1];\n     const index = tip.index + 1;\n     const previousHash = headerHash(tip);\n \n     // Build coinbase\n@@ -416,15 +416,15 @@\n       index,\n       previousHash,\n       timestamp: Date.now(),\n       transactions: list,\n-      merkleRoot: merkleRoot(list.map(t=>t.id)),\n+      merkleRoot: merkleRoot(list.map(t => t.id)),\n       nonce: 0,\n       bits: config.bits\n     };\n     block.hash = headerHash(block);\n     res.json(block);\n-  } catch(e) {\n+  } catch (e) {\n     res.status(500).json({ error: e.message });\n   }\n });\n \n@@ -452,15 +452,17 @@\n     chain.push(genesis);\n     seenBlockHash.add(headerHash(genesis));\n   }\n   rebuildUTXO();\n-  log(`Loaded ${chain.length} blocks. Tip #${chain.length-1}`);\n+  log(`Loaded ${chain.length} blocks. Tip #${chain.length - 1}`);\n });\n \n // -------------------- P2P Wiring --------------------\n-initP2P({ p2pPort: config.p2pPort, peers: config.peers, onOpen: () => {\n-  log(`P2P listening on ${config.p2pPort} peers=${config.peers.length}`);\n-}});\n+initP2P({\n+  p2pPort: config.p2pPort, peers: config.peers, onOpen: () => {\n+    log(`P2P listening on ${config.p2pPort} peers=${config.peers.length}`);\n+  }\n+});\n \n // Incoming P2P messages\n p2pOnMessage(async (msg) => {\n   try {\n@@ -470,11 +472,11 @@\n       if (seenTx.has(tx.id) || mempool[tx.id]) return;\n       validateTx(tx, chain.length);\n       mempool[tx.id] = tx;\n       seenTx.add(tx.id);\n-      log(`[P2P] tx ${tx.id.slice(0,12)}‚Ä¶ added from peer`);\n+      log(`[P2P] tx ${tx.id.slice(0, 12)}‚Ä¶ added from peer`);\n       // rebroadcast\n-      p2pBroadcast({ type:'tx', tx });\n+      p2pBroadcast({ type: 'tx', tx });\n     } else if (msg.type === 'block') {\n       const b = msg.block;\n       const hh = headerHash(b);\n       if (seenBlockHash.has(hh)) return;\n@@ -483,12 +485,12 @@\n       validateBlock(b);\n       applyBlock(b);\n       maybeRetarget();\n       log(`[P2P] block #${b.index} accepted from peer`);\n-      p2pBroadcast({ type:'block', block: b });\n+      p2pBroadcast({ type: 'block', block: b });\n     } else if (msg.type === 'get_tip') {\n-      const tip = chain[chain.length-1];\n-      p2pBroadcast({ type:'tip', tip });\n+      const tip = chain[chain.length - 1];\n+      p2pBroadcast({ type: 'tip', tip });\n     } else if (msg.type === 'tip') {\n       // could implement fork-choice here (highest cumulative work) ‚Äì omitted for brevity in this step\n     }\n   } catch (e) {\n"
                },
                {
                    "date": 1762000265744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,9 @@\n   targetBlockTimeSec: 15,   // target block time\n   blockSubsidy: 50,\n   halvingInterval: 100,     // in blocks\n   coinbaseMaturity: 10,\n-  maxBlockTx: 100,\n-  // Compact difficulty bits (Bitcoin-like): 0x1eXXXXXX ~ easy; 0x1dXXXXXX is BTC-ish\n+  maxBlockTx: 100,  // Compact difficulty bits (Bitcoin-like): 0x1eXXXXXX ~ easy; 0x1dXXXXXX is BTC-ish\n   bits: 0x1f00ffff           // very easy default (increase difficulty by lowering exponent or mantissa)\n };\n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n"
                },
                {
                    "date": 1762001401885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n const BLOCK_DIR = DATA_DIR + '/blocks';\n if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n+console.log(process.env)\n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n   p2pPort: process.env.P2P_PORT,\n"
                },
                {
                    "date": 1762001485748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n const BLOCK_DIR = DATA_DIR + '/blocks';\n if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n-console.log(process.env)\n+console.log(process.env.PEERS)\n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n   p2pPort: process.env.P2P_PORT,\n"
                },
                {
                    "date": 1762001524712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n const BLOCK_DIR = DATA_DIR + '/blocks';\n if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n-console.log(process.env.PEERS)\n+console.log('---------------', process.env.PEERS)\n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n   p2pPort: process.env.P2P_PORT,\n"
                },
                {
                    "date": 1762001552169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,8 @@\n const BLOCK_DIR = DATA_DIR + '/blocks';\n if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n-console.log('---------------', process.env.PEERS)\n // -------------------- Config --------------------\n let config = {\n   httpPort: process.env.PORT,\n   p2pPort: process.env.P2P_PORT,\n"
                },
                {
                    "date": 1762001916289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,12 +20,13 @@\n if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n \n // -------------------- Config --------------------\n+const HTTP_PORT = process.env.PORT;\n+const P2P_PORT = process.env.P2P_PORT;\n+const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n+\n let config = {\n-  httpPort: process.env.PORT,\n-  p2pPort: process.env.P2P_PORT,\n-  peers: process.env.PEERS ? JSON.parse(process.env.PEERS) : [],\n   adjustEvery: 10,          // blocks per retarget\n   targetBlockTimeSec: 15,   // target block time\n   blockSubsidy: 50,\n   halvingInterval: 100,     // in blocks\n@@ -427,10 +428,10 @@\n   }\n });\n \n // -------------------- Boot --------------------\n-const server = app.listen(config.httpPort, () => {\n-  log(`HTTP listening on ${config.httpPort}`);\n+const server = app.listen(HTTP_PORT, () => {\n+  log(`HTTP listening on ${HTTP_PORT}`);\n   loadBlocks();\n   if (chain.length === 0) {\n     const genesis = {\n       index: 0,\n@@ -456,10 +457,10 @@\n });\n \n // -------------------- P2P Wiring --------------------\n initP2P({\n-  p2pPort: config.p2pPort, peers: config.peers, onOpen: () => {\n-    log(`P2P listening on ${config.p2pPort} peers=${config.peers.length}`);\n+  p2pPort: P2P_PORT, peers: PEERS, onOpen: () => {\n+    log(`P2P listening on ${P2P_PORT} peers=${PEERS.length}`);\n   }\n });\n \n // Incoming P2P messages\n"
                },
                {
                    "date": 1762003288699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,11 +26,11 @@\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n   adjustEvery: 10,          // blocks per retarget\n-  targetBlockTimeSec: 15,   // target block time\n+  targetBlockTimeSec: 30,   // target block time\n   blockSubsidy: 50,\n-  halvingInterval: 100,     // in blocks\n+  halvingInterval: 200,     // in blocks\n   coinbaseMaturity: 10,\n   maxBlockTx: 100,  // Compact difficulty bits (Bitcoin-like): 0x1eXXXXXX ~ easy; 0x1dXXXXXX is BTC-ish\n   bits: 0x1f00ffff           // very easy default (increase difficulty by lowering exponent or mantissa)\n };\n"
                },
                {
                    "date": 1762004075219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,16 +25,17 @@\n const P2P_PORT = process.env.P2P_PORT;\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n-  adjustEvery: 10,          // blocks per retarget\n-  targetBlockTimeSec: 30,   // target block time\n-  blockSubsidy: 50,\n-  halvingInterval: 200,     // in blocks\n-  coinbaseMaturity: 10,\n-  maxBlockTx: 100,  // Compact difficulty bits (Bitcoin-like): 0x1eXXXXXX ~ easy; 0x1dXXXXXX is BTC-ish\n-  bits: 0x1f00ffff           // very easy default (increase difficulty by lowering exponent or mantissa)\n+  adjustEvery: 2016,        // Bitcoin adjusts difficulty every 2016 blocks (~2 weeks)\n+  targetBlockTimeSec: 600,  // Target block time: 10 minutes (600 seconds)\n+  blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n+  halvingInterval: 210000,  // Reward halving occurs every 210,000 blocks (~4 years)\n+  coinbaseMaturity: 100,    // Coinbase rewards can be spent only after 100 confirmations\n+  maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n+  bits: 0x1d00ffff          // Initial network difficulty (Bitcoin mainnet genesis)\n };\n+\n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n   try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch { }\n } else {\n"
                },
                {
                    "date": 1762004234314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n const P2P_PORT = process.env.P2P_PORT;\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n-  adjustEvery: 2016,        // Bitcoin adjusts difficulty every 2016 blocks (~2 weeks)\n+  adjustEvery: 100,        // Bitcoin adjusts difficulty every 2016 blocks (~2 weeks)\n   targetBlockTimeSec: 600,  // Target block time: 10 minutes (600 seconds)\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 210000,  // Reward halving occurs every 210,000 blocks (~4 years)\n   coinbaseMaturity: 100,    // Coinbase rewards can be spent only after 100 confirmations\n"
                },
                {
                    "date": 1762004245364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,14 +26,14 @@\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n   adjustEvery: 100,        // Bitcoin adjusts difficulty every 2016 blocks (~2 weeks)\n-  targetBlockTimeSec: 600,  // Target block time: 10 minutes (600 seconds)\n+  targetBlockTimeSec: 60,  // Target block time: 10 minutes (600 seconds)\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 210000,  // Reward halving occurs every 210,000 blocks (~4 years)\n   coinbaseMaturity: 100,    // Coinbase rewards can be spent only after 100 confirmations\n   maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n-  bits: 0x1d00ffff          // Initial network difficulty (Bitcoin mainnet genesis)\n+  bits: 0x1e00ffff          // Initial network difficulty (Bitcoin mainnet genesis)\n };\n \n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n"
                },
                {
                    "date": 1762004549822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n const P2P_PORT = process.env.P2P_PORT;\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n-  adjustEvery: 100,        // Bitcoin adjusts difficulty every 2016 blocks (~2 weeks)\n+  adjustEvery: 10,        // Bitcoin adjusts difficulty every 10 blocks\n   targetBlockTimeSec: 60,  // Target block time: 10 minutes (600 seconds)\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 210000,  // Reward halving occurs every 210,000 blocks (~4 years)\n   coinbaseMaturity: 100,    // Coinbase rewards can be spent only after 100 confirmations\n"
                },
                {
                    "date": 1762004604526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,15 +25,15 @@\n const P2P_PORT = process.env.P2P_PORT;\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n-  adjustEvery: 10,        // Bitcoin adjusts difficulty every 10 blocks\n-  targetBlockTimeSec: 60,  // Target block time: 10 minutes (600 seconds)\n+  adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n+  targetBlockTimeSec: 60,   // Target block time: 1 minutes (60 seconds)\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n-  halvingInterval: 210000,  // Reward halving occurs every 210,000 blocks (~4 years)\n-  coinbaseMaturity: 100,    // Coinbase rewards can be spent only after 100 confirmations\n+  halvingInterval: 500,     // Reward halving occurs every 500\n+  coinbaseMaturity: 5,      // Coinbase rewards can be spent only after 100 confirmations\n   maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n-  bits: 0x1e00ffff          // Initial network difficulty (Bitcoin mainnet genesis)\n+  bits: 0x1e00ffff          // Initial network difficulty\n };\n \n const CONFIG_FILE = DATA_DIR + '/config.json';\n if (fs.existsSync(CONFIG_FILE)) {\n"
                },
                {
                    "date": 1762004664046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,500 @@\n+// apps/blockchain/server.js\n+// Mini Bitcoin-like Full Node (ECDSA verify + P2P + Compact Target Bits)\n+// Run: node apps/blockchain/server.js\n+\n+const express = require('express');\n+const bodyParser = require('body-parser');\n+const fs = require('fs');\n+const crypto = require('crypto');\n+const { initP2P, p2pBroadcast, p2pOnMessage } = require('./p2p');\n+\n+const log = (...a) => console.log('[NODE]', ...a);\n+const warn = (...a) => console.warn('[NODE]', ...a);\n+\n+const app = express();\n+app.use(bodyParser.json({ limit: '2mb' }));\n+\n+// -------------------- Directories --------------------\n+const DATA_DIR = __dirname + '/data';\n+const BLOCK_DIR = DATA_DIR + '/blocks';\n+if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n+if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n+\n+// -------------------- Config --------------------\n+const HTTP_PORT = process.env.PORT;\n+const P2P_PORT = process.env.P2P_PORT;\n+const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n+\n+let config = {\n+  adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n+  targetBlockTimeSec: 30,   // Target block time: 30 seconds\n+  blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n+  halvingInterval: 500,     // Reward halving occurs every 500\n+  coinbaseMaturity: 5,      // Coinbase rewards can be spent only after 100 confirmations\n+  maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n+  bits: 0x1e00ffff          // Initial network difficulty\n+};\n+\n+const CONFIG_FILE = DATA_DIR + '/config.json';\n+if (fs.existsSync(CONFIG_FILE)) {\n+  try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch { }\n+} else {\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+}\n+\n+// -------------------- State --------------------\n+let chain = [];             // array of blocks\n+let mempool = {};           // txid -> tx\n+let utxo = new Map();       // `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n+let seenTx = new Set();     // prevent gossip loops\n+let seenBlockHash = new Set();\n+\n+// -------------------- Utils --------------------\n+const sha256Hex = (buf) => crypto.createHash('sha256').update(buf).digest('hex');\n+\n+function txIdFor(tx) {\n+  // deterministic id without sig variability: inputs(txid,index,pubKey) + outputs\n+  const copy = {\n+    inputs: (tx.inputs || []).map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey })),\n+    outputs: (tx.outputs || []).map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256Hex(Buffer.from(JSON.stringify(copy)));\n+}\n+\n+function headerHash(block) {\n+  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`;\n+  return sha256Hex(Buffer.from(header));\n+}\n+\n+function merkleRoot(txids) {\n+  if (!txids.length) return sha256Hex(Buffer.from(''));\n+  let nodes = txids.map(t => Buffer.from(t, 'hex'));\n+  while (nodes.length > 1) {\n+    if (nodes.length % 2 === 1) nodes.push(nodes[nodes.length - 1]);\n+    const next = [];\n+    for (let i = 0; i < nodes.length; i += 2) {\n+      next.push(Buffer.from(sha256Hex(Buffer.concat([nodes[i], nodes[i + 1]])), 'hex'));\n+    }\n+    nodes = next;\n+  }\n+  return nodes[0].toString('hex');\n+}\n+\n+// --- Compact Target Bits (Bitcoin-like) ---\n+function bitsToTarget(bits) {\n+  const exp = (bits >>> 24) & 0xff;\n+  let mant = BigInt(bits & 0x007fffff);\n+  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n+  // target = mantissa * 256^(exp-3)\n+  const shift = BigInt(8 * (exp - 3));\n+  return mant << shift;\n+}\n+function targetToBits(target) {\n+  // convert BigInt target to compact\n+  let hex = target.toString(16);\n+  if (hex.length % 2) hex = '0' + hex;\n+  const size = Math.ceil(hex.length / 2);\n+  let mant;\n+  if (size <= 3) {\n+    mant = BigInt('0x' + hex.padEnd(6, '0'));\n+  } else {\n+    mant = BigInt('0x' + hex.slice(0, 6));\n+  }\n+  let bits = (size << 24) | Number(mant & 0x007fffff);\n+  return bits >>> 0;\n+}\n+function hashMeetsBits(hexHash, bits) {\n+  const h = BigInt('0x' + hexHash);\n+  const target = bitsToTarget(bits);\n+  return h <= target;\n+}\n+\n+// -------------------- Persistence --------------------\n+function saveBlock(block) {\n+  fs.writeFileSync(`${BLOCK_DIR}/block_${block.index}.json`, JSON.stringify(block, null, 2));\n+}\n+function loadBlocks() {\n+  const files = fs.readdirSync(BLOCK_DIR).filter(f => f.startsWith('block_') && f.endsWith('.json'));\n+  files.sort((a, b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));\n+  for (const f of files) {\n+    const b = JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${f}`, 'utf8'));\n+    chain.push(b);\n+    seenBlockHash.add(headerHash(b));\n+  }\n+}\n+function rebuildUTXO() {\n+  utxo = new Map();\n+  for (const b of chain) {\n+    for (const tx of b.transactions) {\n+      // spend inputs\n+      for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n+      // add outputs\n+      tx.outputs.forEach((o, idx) => {\n+        utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: b.index, isCoinbase: !!tx.isCoinbase });\n+      });\n+    }\n+  }\n+}\n+\n+// -------------------- Consensus Rules --------------------\n+function getBlockReward(height) {\n+  const halvings = Math.floor(height / config.halvingInterval);\n+  const r = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n+  return Math.max(r, 0);\n+}\n+\n+function pubKeyToAddress(pubKeyHex) {\n+  // address = RIPEMD160(SHA256(pubKey))\n+  const sha = crypto.createHash('sha256').update(Buffer.from(pubKeyHex, 'hex')).digest();\n+  return crypto.createHash('ripemd160').update(sha).digest('hex');\n+}\n+\n+function verifyInputSig(tx, inputIndex) {\n+  const ec = new (require('elliptic').ec)('secp256k1');\n+  const inp = tx.inputs[inputIndex];\n+  const pub = inp.pubKey;\n+  const sigHex = inp.sig;\n+  if (!pub || !sigHex) throw new Error('missing pubKey or sig');\n+\n+  // Sighash (ALL): hash( JSON.stringify({inputs:[{txid,index}], outputs}) )\n+  const msg = sha256Hex(Buffer.from(JSON.stringify({\n+    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  })));\n+\n+  const key = ec.keyFromPublic(pub, 'hex');\n+  const sig = Buffer.from(sigHex, 'hex');\n+  let ok = false;\n+  try { ok = key.verify(msg, sig); } catch { ok = false; }\n+  if (!ok) throw new Error('bad signature');\n+  return true;\n+}\n+\n+function validateTx(tx, currentHeight) {\n+  if (!tx || !Array.isArray(tx.inputs) || !Array.isArray(tx.outputs)) throw new Error('invalid tx format');\n+\n+  if (tx.isCoinbase) {\n+    if (tx.inputs.length !== 0) throw new Error('coinbase must have no inputs');\n+    tx.outputs.forEach(o => { if (o.amount <= 0) throw new Error('coinbase bad amount'); });\n+    return true;\n+  }\n+\n+  let inSum = 0, outSum = 0;\n+  const used = new Set();\n+\n+  // check inputs exist & mature & signatures correct & address matches pubKey\n+  for (let idx = 0; idx < tx.inputs.length; idx++) {\n+    const i = tx.inputs[idx];\n+    const key = `${i.txid}:${i.index}`;\n+    if (used.has(key)) throw new Error('double spend in tx');\n+    used.add(key);\n+\n+    const entry = utxo.get(key);\n+    if (!entry) throw new Error('missing UTXO ' + key);\n+    if (entry.isCoinbase && (currentHeight - entry.blockHeight) < config.coinbaseMaturity)\n+      throw new Error('coinbase not mature');\n+\n+    // verify signature\n+    verifyInputSig(tx, idx);\n+\n+    // verify that provided pubKey actually controls the referenced output address\n+    const addr = pubKeyToAddress(i.pubKey);\n+    if (addr !== entry.address) throw new Error('pubKey does not match UTXO address');\n+\n+    inSum += entry.amount;\n+  }\n+\n+  for (const o of tx.outputs) {\n+    if (o.amount <= 0) throw new Error('output <= 0');\n+    outSum += o.amount;\n+  }\n+  if (inSum < outSum) throw new Error('inputs < outputs');\n+  return true;\n+}\n+\n+function validateBlock(block) {\n+  const tip = chain[chain.length - 1];\n+  if (chain.length === 0) {\n+    if (block.index !== 0) throw new Error('genesis index must be 0');\n+  } else {\n+    if (block.index !== tip.index + 1) throw new Error('bad index');\n+    if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n+  }\n+\n+  // basic header checks\n+  const txids = block.transactions.map(t => t.id);\n+  if (merkleRoot(txids) !== block.merkleRoot) throw new Error('merkle mismatch');\n+  const hh = headerHash(block);\n+  if (!hashMeetsBits(hh, block.bits)) throw new Error('insufficient PoW');\n+\n+  // tx rules\n+  let coinbaseCount = 0;\n+  let feeTotal = 0;\n+\n+  // temp UTXO (for intra-block spends)\n+  const temp = new Map(utxo);\n+  for (const tx of block.transactions) {\n+    if (tx.isCoinbase) {\n+      coinbaseCount++;\n+      if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n+      // add outputs\n+      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: true }));\n+    } else {\n+      // spend\n+      let inSum = 0, outSum = 0;\n+      for (let idx = 0; idx < tx.inputs.length; idx++) {\n+        const i = tx.inputs[idx];\n+        const key = `${i.txid}:${i.index}`;\n+        const ent = temp.get(key);\n+        if (!ent) throw new Error('missing input ' + key);\n+        // signature check against original tx object (already contains sigs)\n+        verifyInputSig(tx, idx);\n+        // pubKey matches address\n+        const addr = pubKeyToAddress(i.pubKey);\n+        if (addr !== ent.address) throw new Error('pubKey!=address');\n+        inSum += ent.amount;\n+        temp.delete(key);\n+      }\n+      tx.outputs.forEach(o => outSum += o.amount);\n+      if (inSum < outSum) throw new Error('tx spends more than inputs');\n+      feeTotal += (inSum - outSum);\n+      // add outputs\n+      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: false }));\n+    }\n+  }\n+  if (coinbaseCount !== 1) throw new Error('block must have exactly 1 coinbase');\n+\n+  // coinbase value <= subsidy + fees\n+  const expected = getBlockReward(block.index) + feeTotal;\n+  const coinbase = block.transactions.find(t => t.isCoinbase);\n+  const cbOut = coinbase.outputs.reduce((s, o) => s + o.amount, 0);\n+  if (cbOut > expected) throw new Error(`coinbase too large: ${cbOut} > ${expected}`);\n+\n+  return true;\n+}\n+\n+function applyBlock(block) {\n+  // spend & create\n+  for (const tx of block.transactions) {\n+    for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n+    tx.outputs.forEach((o, idx) => utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase }));\n+    if (mempool[tx.id]) delete mempool[tx.id];\n+  }\n+  chain.push(block);\n+  saveBlock(block);\n+  seenBlockHash.add(headerHash(block));\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+  log(`Accepted block #${block.index} hash=${headerHash(block).slice(0, 16)}‚Ä¶ txs=${block.transactions.length}`);\n+}\n+\n+function maybeRetarget() {\n+  const h = chain.length;\n+  if (h === 0 || h % config.adjustEvery !== 0) return;\n+  const last = chain[h - 1];\n+  const first = chain[h - config.adjustEvery];\n+  const actual = (last.timestamp - first.timestamp) / 1000;\n+  const expected = config.adjustEvery * config.targetBlockTimeSec;\n+  let ratio = expected / (actual || 1);\n+  // clamp (like BTC caps to 4x)\n+  const minR = 0.25, maxR = 4;\n+  if (ratio < minR) ratio = minR;\n+  if (ratio > maxR) ratio = maxR;\n+\n+  const curTarget = bitsToTarget(config.bits);\n+  let newTarget = BigInt(curTarget / BigInt(Math.round(1 / ratio * 1e6))) * BigInt(1e6); // smooth-ish\n+  if (newTarget <= 0n) newTarget = 1n;\n+  const newBits = targetToBits(newTarget);\n+  log(`Retarget @${h}: actual=${actual.toFixed(2)}s expected=${expected}s ratio=${ratio.toFixed(3)} bits ${config.bits.toString(16)} -> ${newBits.toString(16)}`);\n+  config.bits = newBits >>> 0;\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+}\n+\n+// -------------------- API --------------------\n+app.get('/config', (req, res) => res.json(config));\n+app.get('/chain', (req, res) => res.json(chain));\n+app.get('/tip', (req, res) => res.json(chain[chain.length - 1] || null));\n+app.get('/block/:h', (req, res) => {\n+  const h = +req.params.h;\n+  if (Number.isNaN(h) || h < 0 || h >= chain.length) return res.status(404).json({ error: 'not found' });\n+  res.json(chain[h]);\n+});\n+app.get('/mempool', (req, res) => res.json(Object.values(mempool)));\n+app.get('/utxos/:addr', (req, res) => {\n+  const addr = req.params.addr;\n+  const out = [];\n+  for (const [k, v] of utxo.entries()) {\n+    if (v.address === addr) {\n+      const [txid, idx] = k.split(':');\n+      out.push({ txid, index: +idx, amount: v.amount, blockHeight: v.blockHeight, isCoinbase: v.isCoinbase });\n+    }\n+  }\n+  res.json({ utxos: out });\n+});\n+app.get('/tx/:id', (req, res) => {\n+  const id = req.params.id;\n+  for (const b of chain) {\n+    const t = b.transactions.find(x => x.id === id);\n+    if (t) return res.json({ tx: t, blockHeight: b.index });\n+  }\n+  if (mempool[id]) return res.json({ tx: mempool[id], blockHeight: null });\n+  res.status(404).json({ error: 'not found' });\n+});\n+\n+app.post('/transactions', (req, res) => {\n+  try {\n+    const tx = req.body;\n+    if (!tx.id) tx.id = txIdFor(tx);\n+    // validation against current UTXO/state\n+    validateTx(tx, chain.length);\n+    if (mempool[tx.id]) return res.status(200).json({ ok: true, id: tx.id, note: 'duplicate in mempool' });\n+    mempool[tx.id] = tx;\n+    seenTx.add(tx.id);\n+    log(`+ mempool tx ${tx.id.slice(0, 16)}‚Ä¶`);\n+    // Gossip to peers\n+    p2pBroadcast({ type: 'tx', tx });\n+    res.json({ ok: true, id: tx.id });\n+  } catch (e) {\n+    return res.status(400).json({ error: e.message });\n+  }\n+});\n+\n+app.post('/blocks', (req, res) => {\n+  try {\n+    const block = req.body;\n+    // recompute ids if missing\n+    for (const t of block.transactions) if (!t.id) t.id = txIdFor(t);\n+    // validate & apply\n+    validateBlock(block);\n+    applyBlock(block);\n+    maybeRetarget();\n+    // gossip\n+    p2pBroadcast({ type: 'block', block });\n+    res.json({ ok: true, height: block.index });\n+  } catch (e) {\n+    return res.status(400).json({ error: e.message });\n+  }\n+});\n+\n+// block candidate for miners\n+app.get('/block/candidate/:address', (req, res) => {\n+  try {\n+    const addr = req.params.address;\n+    const tip = chain[chain.length - 1];\n+    const index = tip.index + 1;\n+    const previousHash = headerHash(tip);\n+\n+    // Build coinbase\n+    const txs = [];\n+    const coinbase = {\n+      isCoinbase: true,\n+      inputs: [],\n+      outputs: [{ address: addr, amount: getBlockReward(index) }],\n+      id: null\n+    };\n+\n+    // pick some mempool txs (no fee sorting here for brevity)\n+    const pool = Object.values(mempool).slice(0, config.maxBlockTx);\n+    // Compute fees to add to coinbase\n+    let fee = 0;\n+    for (const t of pool) {\n+      let inSum = 0, outSum = 0;\n+      for (const i of t.inputs) {\n+        const u = utxo.get(`${i.txid}:${i.index}`);\n+        if (u) inSum += u.amount;\n+      }\n+      for (const o of t.outputs) outSum += o.amount;\n+      if (inSum > outSum) fee += (inSum - outSum);\n+      txs.push(t);\n+    }\n+    coinbase.outputs[0].amount += fee;\n+\n+    // finalize ids\n+    coinbase.id = txIdFor(coinbase);\n+    const list = [coinbase, ...txs];\n+    list.forEach(t => { if (!t.id) t.id = txIdFor(t); });\n+\n+    const block = {\n+      index,\n+      previousHash,\n+      timestamp: Date.now(),\n+      transactions: list,\n+      merkleRoot: merkleRoot(list.map(t => t.id)),\n+      nonce: 0,\n+      bits: config.bits\n+    };\n+    block.hash = headerHash(block);\n+    res.json(block);\n+  } catch (e) {\n+    res.status(500).json({ error: e.message });\n+  }\n+});\n+\n+// -------------------- Boot --------------------\n+const server = app.listen(HTTP_PORT, () => {\n+  log(`HTTP listening on ${HTTP_PORT}`);\n+  loadBlocks();\n+  if (chain.length === 0) {\n+    const genesis = {\n+      index: 0,\n+      previousHash: '0',\n+      timestamp: Date.now(),\n+      transactions: [{\n+        id: 'genesis',\n+        isCoinbase: true,\n+        inputs: [],\n+        outputs: [{ address: 'genesis', amount: 0 }]\n+      }],\n+      merkleRoot: merkleRoot(['genesis']),\n+      nonce: 0,\n+      bits: config.bits\n+    };\n+    genesis.hash = headerHash(genesis);\n+    saveBlock(genesis);\n+    chain.push(genesis);\n+    seenBlockHash.add(headerHash(genesis));\n+  }\n+  rebuildUTXO();\n+  log(`Loaded ${chain.length} blocks. Tip #${chain.length - 1}`);\n+});\n+\n+// -------------------- P2P Wiring --------------------\n+initP2P({\n+  p2pPort: P2P_PORT, peers: PEERS, onOpen: () => {\n+    log(`P2P listening on ${P2P_PORT} peers=${PEERS.length}`);\n+  }\n+});\n+\n+// Incoming P2P messages\n+p2pOnMessage(async (msg) => {\n+  try {\n+    if (msg.type === 'tx') {\n+      const tx = msg.tx;\n+      if (!tx.id) tx.id = txIdFor(tx);\n+      if (seenTx.has(tx.id) || mempool[tx.id]) return;\n+      validateTx(tx, chain.length);\n+      mempool[tx.id] = tx;\n+      seenTx.add(tx.id);\n+      log(`[P2P] tx ${tx.id.slice(0, 12)}‚Ä¶ added from peer`);\n+      // rebroadcast\n+      p2pBroadcast({ type: 'tx', tx });\n+    } else if (msg.type === 'block') {\n+      const b = msg.block;\n+      const hh = headerHash(b);\n+      if (seenBlockHash.has(hh)) return;\n+      // ensure tx ids present\n+      for (const t of b.transactions) if (!t.id) t.id = txIdFor(t);\n+      validateBlock(b);\n+      applyBlock(b);\n+      maybeRetarget();\n+      log(`[P2P] block #${b.index} accepted from peer`);\n+      p2pBroadcast({ type: 'block', block: b });\n+    } else if (msg.type === 'get_tip') {\n+      const tip = chain[chain.length - 1];\n+      p2pBroadcast({ type: 'tip', tip });\n+    } else if (msg.type === 'tip') {\n+      // could implement fork-choice here (highest cumulative work) ‚Äì omitted for brevity in this step\n+    }\n+  } catch (e) {\n+    warn('[P2P msg error]', e.message);\n+  }\n+});\n"
                },
                {
                    "date": 1762004690197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n   targetBlockTimeSec: 30,   // Target block time: 30 seconds\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 500,     // Reward halving occurs every 500\n   coinbaseMaturity: 5,      // Coinbase rewards can be spent only after 100 confirmations\n-  maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n+  maxBlockTx: 100,          // Larger block capacity to simulate realistic blocks\n   bits: 0x1e00ffff          // Initial network difficulty\n };\n \n const CONFIG_FILE = DATA_DIR + '/config.json';\n@@ -497,504 +497,4 @@\n   } catch (e) {\n     warn('[P2P msg error]', e.message);\n   }\n });\n-// apps/blockchain/server.js\n-// Mini Bitcoin-like Full Node (ECDSA verify + P2P + Compact Target Bits)\n-// Run: node apps/blockchain/server.js\n-\n-const express = require('express');\n-const bodyParser = require('body-parser');\n-const fs = require('fs');\n-const crypto = require('crypto');\n-const { initP2P, p2pBroadcast, p2pOnMessage } = require('./p2p');\n-\n-const log = (...a) => console.log('[NODE]', ...a);\n-const warn = (...a) => console.warn('[NODE]', ...a);\n-\n-const app = express();\n-app.use(bodyParser.json({ limit: '2mb' }));\n-\n-// -------------------- Directories --------------------\n-const DATA_DIR = __dirname + '/data';\n-const BLOCK_DIR = DATA_DIR + '/blocks';\n-if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });\n-if (!fs.existsSync(BLOCK_DIR)) fs.mkdirSync(BLOCK_DIR, { recursive: true });\n-\n-// -------------------- Config --------------------\n-const HTTP_PORT = process.env.PORT;\n-const P2P_PORT = process.env.P2P_PORT;\n-const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n-\n-let config = {\n-  adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n-  targetBlockTimeSec: 60,   // Target block time: 1 minutes (60 seconds)\n-  blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n-  halvingInterval: 500,     // Reward halving occurs every 500\n-  coinbaseMaturity: 5,      // Coinbase rewards can be spent only after 100 confirmations\n-  maxBlockTx: 2000,         // Larger block capacity to simulate realistic blocks\n-  bits: 0x1e00ffff          // Initial network difficulty\n-};\n-\n-const CONFIG_FILE = DATA_DIR + '/config.json';\n-if (fs.existsSync(CONFIG_FILE)) {\n-  try { Object.assign(config, JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'))); } catch { }\n-} else {\n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-}\n-\n-// -------------------- State --------------------\n-let chain = [];             // array of blocks\n-let mempool = {};           // txid -> tx\n-let utxo = new Map();       // `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n-let seenTx = new Set();     // prevent gossip loops\n-let seenBlockHash = new Set();\n-\n-// -------------------- Utils --------------------\n-const sha256Hex = (buf) => crypto.createHash('sha256').update(buf).digest('hex');\n-\n-function txIdFor(tx) {\n-  // deterministic id without sig variability: inputs(txid,index,pubKey) + outputs\n-  const copy = {\n-    inputs: (tx.inputs || []).map(i => ({ txid: i.txid, index: i.index, pubKey: i.pubKey })),\n-    outputs: (tx.outputs || []).map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256Hex(Buffer.from(JSON.stringify(copy)));\n-}\n-\n-function headerHash(block) {\n-  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`;\n-  return sha256Hex(Buffer.from(header));\n-}\n-\n-function merkleRoot(txids) {\n-  if (!txids.length) return sha256Hex(Buffer.from(''));\n-  let nodes = txids.map(t => Buffer.from(t, 'hex'));\n-  while (nodes.length > 1) {\n-    if (nodes.length % 2 === 1) nodes.push(nodes[nodes.length - 1]);\n-    const next = [];\n-    for (let i = 0; i < nodes.length; i += 2) {\n-      next.push(Buffer.from(sha256Hex(Buffer.concat([nodes[i], nodes[i + 1]])), 'hex'));\n-    }\n-    nodes = next;\n-  }\n-  return nodes[0].toString('hex');\n-}\n-\n-// --- Compact Target Bits (Bitcoin-like) ---\n-function bitsToTarget(bits) {\n-  const exp = (bits >>> 24) & 0xff;\n-  let mant = BigInt(bits & 0x007fffff);\n-  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n-  // target = mantissa * 256^(exp-3)\n-  const shift = BigInt(8 * (exp - 3));\n-  return mant << shift;\n-}\n-function targetToBits(target) {\n-  // convert BigInt target to compact\n-  let hex = target.toString(16);\n-  if (hex.length % 2) hex = '0' + hex;\n-  const size = Math.ceil(hex.length / 2);\n-  let mant;\n-  if (size <= 3) {\n-    mant = BigInt('0x' + hex.padEnd(6, '0'));\n-  } else {\n-    mant = BigInt('0x' + hex.slice(0, 6));\n-  }\n-  let bits = (size << 24) | Number(mant & 0x007fffff);\n-  return bits >>> 0;\n-}\n-function hashMeetsBits(hexHash, bits) {\n-  const h = BigInt('0x' + hexHash);\n-  const target = bitsToTarget(bits);\n-  return h <= target;\n-}\n-\n-// -------------------- Persistence --------------------\n-function saveBlock(block) {\n-  fs.writeFileSync(`${BLOCK_DIR}/block_${block.index}.json`, JSON.stringify(block, null, 2));\n-}\n-function loadBlocks() {\n-  const files = fs.readdirSync(BLOCK_DIR).filter(f => f.startsWith('block_') && f.endsWith('.json'));\n-  files.sort((a, b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));\n-  for (const f of files) {\n-    const b = JSON.parse(fs.readFileSync(`${BLOCK_DIR}/${f}`, 'utf8'));\n-    chain.push(b);\n-    seenBlockHash.add(headerHash(b));\n-  }\n-}\n-function rebuildUTXO() {\n-  utxo = new Map();\n-  for (const b of chain) {\n-    for (const tx of b.transactions) {\n-      // spend inputs\n-      for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n-      // add outputs\n-      tx.outputs.forEach((o, idx) => {\n-        utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: b.index, isCoinbase: !!tx.isCoinbase });\n-      });\n-    }\n-  }\n-}\n-\n-// -------------------- Consensus Rules --------------------\n-function getBlockReward(height) {\n-  const halvings = Math.floor(height / config.halvingInterval);\n-  const r = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n-  return Math.max(r, 0);\n-}\n-\n-function pubKeyToAddress(pubKeyHex) {\n-  // address = RIPEMD160(SHA256(pubKey))\n-  const sha = crypto.createHash('sha256').update(Buffer.from(pubKeyHex, 'hex')).digest();\n-  return crypto.createHash('ripemd160').update(sha).digest('hex');\n-}\n-\n-function verifyInputSig(tx, inputIndex) {\n-  const ec = new (require('elliptic').ec)('secp256k1');\n-  const inp = tx.inputs[inputIndex];\n-  const pub = inp.pubKey;\n-  const sigHex = inp.sig;\n-  if (!pub || !sigHex) throw new Error('missing pubKey or sig');\n-\n-  // Sighash (ALL): hash( JSON.stringify({inputs:[{txid,index}], outputs}) )\n-  const msg = sha256Hex(Buffer.from(JSON.stringify({\n-    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  })));\n-\n-  const key = ec.keyFromPublic(pub, 'hex');\n-  const sig = Buffer.from(sigHex, 'hex');\n-  let ok = false;\n-  try { ok = key.verify(msg, sig); } catch { ok = false; }\n-  if (!ok) throw new Error('bad signature');\n-  return true;\n-}\n-\n-function validateTx(tx, currentHeight) {\n-  if (!tx || !Array.isArray(tx.inputs) || !Array.isArray(tx.outputs)) throw new Error('invalid tx format');\n-\n-  if (tx.isCoinbase) {\n-    if (tx.inputs.length !== 0) throw new Error('coinbase must have no inputs');\n-    tx.outputs.forEach(o => { if (o.amount <= 0) throw new Error('coinbase bad amount'); });\n-    return true;\n-  }\n-\n-  let inSum = 0, outSum = 0;\n-  const used = new Set();\n-\n-  // check inputs exist & mature & signatures correct & address matches pubKey\n-  for (let idx = 0; idx < tx.inputs.length; idx++) {\n-    const i = tx.inputs[idx];\n-    const key = `${i.txid}:${i.index}`;\n-    if (used.has(key)) throw new Error('double spend in tx');\n-    used.add(key);\n-\n-    const entry = utxo.get(key);\n-    if (!entry) throw new Error('missing UTXO ' + key);\n-    if (entry.isCoinbase && (currentHeight - entry.blockHeight) < config.coinbaseMaturity)\n-      throw new Error('coinbase not mature');\n-\n-    // verify signature\n-    verifyInputSig(tx, idx);\n-\n-    // verify that provided pubKey actually controls the referenced output address\n-    const addr = pubKeyToAddress(i.pubKey);\n-    if (addr !== entry.address) throw new Error('pubKey does not match UTXO address');\n-\n-    inSum += entry.amount;\n-  }\n-\n-  for (const o of tx.outputs) {\n-    if (o.amount <= 0) throw new Error('output <= 0');\n-    outSum += o.amount;\n-  }\n-  if (inSum < outSum) throw new Error('inputs < outputs');\n-  return true;\n-}\n-\n-function validateBlock(block) {\n-  const tip = chain[chain.length - 1];\n-  if (chain.length === 0) {\n-    if (block.index !== 0) throw new Error('genesis index must be 0');\n-  } else {\n-    if (block.index !== tip.index + 1) throw new Error('bad index');\n-    if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n-  }\n-\n-  // basic header checks\n-  const txids = block.transactions.map(t => t.id);\n-  if (merkleRoot(txids) !== block.merkleRoot) throw new Error('merkle mismatch');\n-  const hh = headerHash(block);\n-  if (!hashMeetsBits(hh, block.bits)) throw new Error('insufficient PoW');\n-\n-  // tx rules\n-  let coinbaseCount = 0;\n-  let feeTotal = 0;\n-\n-  // temp UTXO (for intra-block spends)\n-  const temp = new Map(utxo);\n-  for (const tx of block.transactions) {\n-    if (tx.isCoinbase) {\n-      coinbaseCount++;\n-      if (tx.inputs.length !== 0) throw new Error('coinbase has inputs');\n-      // add outputs\n-      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: true }));\n-    } else {\n-      // spend\n-      let inSum = 0, outSum = 0;\n-      for (let idx = 0; idx < tx.inputs.length; idx++) {\n-        const i = tx.inputs[idx];\n-        const key = `${i.txid}:${i.index}`;\n-        const ent = temp.get(key);\n-        if (!ent) throw new Error('missing input ' + key);\n-        // signature check against original tx object (already contains sigs)\n-        verifyInputSig(tx, idx);\n-        // pubKey matches address\n-        const addr = pubKeyToAddress(i.pubKey);\n-        if (addr !== ent.address) throw new Error('pubKey!=address');\n-        inSum += ent.amount;\n-        temp.delete(key);\n-      }\n-      tx.outputs.forEach(o => outSum += o.amount);\n-      if (inSum < outSum) throw new Error('tx spends more than inputs');\n-      feeTotal += (inSum - outSum);\n-      // add outputs\n-      tx.outputs.forEach((o, idx) => temp.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: false }));\n-    }\n-  }\n-  if (coinbaseCount !== 1) throw new Error('block must have exactly 1 coinbase');\n-\n-  // coinbase value <= subsidy + fees\n-  const expected = getBlockReward(block.index) + feeTotal;\n-  const coinbase = block.transactions.find(t => t.isCoinbase);\n-  const cbOut = coinbase.outputs.reduce((s, o) => s + o.amount, 0);\n-  if (cbOut > expected) throw new Error(`coinbase too large: ${cbOut} > ${expected}`);\n-\n-  return true;\n-}\n-\n-function applyBlock(block) {\n-  // spend & create\n-  for (const tx of block.transactions) {\n-    for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n-    tx.outputs.forEach((o, idx) => utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase }));\n-    if (mempool[tx.id]) delete mempool[tx.id];\n-  }\n-  chain.push(block);\n-  saveBlock(block);\n-  seenBlockHash.add(headerHash(block));\n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  log(`Accepted block #${block.index} hash=${headerHash(block).slice(0, 16)}‚Ä¶ txs=${block.transactions.length}`);\n-}\n-\n-function maybeRetarget() {\n-  const h = chain.length;\n-  if (h === 0 || h % config.adjustEvery !== 0) return;\n-  const last = chain[h - 1];\n-  const first = chain[h - config.adjustEvery];\n-  const actual = (last.timestamp - first.timestamp) / 1000;\n-  const expected = config.adjustEvery * config.targetBlockTimeSec;\n-  let ratio = expected / (actual || 1);\n-  // clamp (like BTC caps to 4x)\n-  const minR = 0.25, maxR = 4;\n-  if (ratio < minR) ratio = minR;\n-  if (ratio > maxR) ratio = maxR;\n-\n-  const curTarget = bitsToTarget(config.bits);\n-  let newTarget = BigInt(curTarget / BigInt(Math.round(1 / ratio * 1e6))) * BigInt(1e6); // smooth-ish\n-  if (newTarget <= 0n) newTarget = 1n;\n-  const newBits = targetToBits(newTarget);\n-  log(`Retarget @${h}: actual=${actual.toFixed(2)}s expected=${expected}s ratio=${ratio.toFixed(3)} bits ${config.bits.toString(16)} -> ${newBits.toString(16)}`);\n-  config.bits = newBits >>> 0;\n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-}\n-\n-// -------------------- API --------------------\n-app.get('/config', (req, res) => res.json(config));\n-app.get('/chain', (req, res) => res.json(chain));\n-app.get('/tip', (req, res) => res.json(chain[chain.length - 1] || null));\n-app.get('/block/:h', (req, res) => {\n-  const h = +req.params.h;\n-  if (Number.isNaN(h) || h < 0 || h >= chain.length) return res.status(404).json({ error: 'not found' });\n-  res.json(chain[h]);\n-});\n-app.get('/mempool', (req, res) => res.json(Object.values(mempool)));\n-app.get('/utxos/:addr', (req, res) => {\n-  const addr = req.params.addr;\n-  const out = [];\n-  for (const [k, v] of utxo.entries()) {\n-    if (v.address === addr) {\n-      const [txid, idx] = k.split(':');\n-      out.push({ txid, index: +idx, amount: v.amount, blockHeight: v.blockHeight, isCoinbase: v.isCoinbase });\n-    }\n-  }\n-  res.json({ utxos: out });\n-});\n-app.get('/tx/:id', (req, res) => {\n-  const id = req.params.id;\n-  for (const b of chain) {\n-    const t = b.transactions.find(x => x.id === id);\n-    if (t) return res.json({ tx: t, blockHeight: b.index });\n-  }\n-  if (mempool[id]) return res.json({ tx: mempool[id], blockHeight: null });\n-  res.status(404).json({ error: 'not found' });\n-});\n-\n-app.post('/transactions', (req, res) => {\n-  try {\n-    const tx = req.body;\n-    if (!tx.id) tx.id = txIdFor(tx);\n-    // validation against current UTXO/state\n-    validateTx(tx, chain.length);\n-    if (mempool[tx.id]) return res.status(200).json({ ok: true, id: tx.id, note: 'duplicate in mempool' });\n-    mempool[tx.id] = tx;\n-    seenTx.add(tx.id);\n-    log(`+ mempool tx ${tx.id.slice(0, 16)}‚Ä¶`);\n-    // Gossip to peers\n-    p2pBroadcast({ type: 'tx', tx });\n-    res.json({ ok: true, id: tx.id });\n-  } catch (e) {\n-    return res.status(400).json({ error: e.message });\n-  }\n-});\n-\n-app.post('/blocks', (req, res) => {\n-  try {\n-    const block = req.body;\n-    // recompute ids if missing\n-    for (const t of block.transactions) if (!t.id) t.id = txIdFor(t);\n-    // validate & apply\n-    validateBlock(block);\n-    applyBlock(block);\n-    maybeRetarget();\n-    // gossip\n-    p2pBroadcast({ type: 'block', block });\n-    res.json({ ok: true, height: block.index });\n-  } catch (e) {\n-    return res.status(400).json({ error: e.message });\n-  }\n-});\n-\n-// block candidate for miners\n-app.get('/block/candidate/:address', (req, res) => {\n-  try {\n-    const addr = req.params.address;\n-    const tip = chain[chain.length - 1];\n-    const index = tip.index + 1;\n-    const previousHash = headerHash(tip);\n-\n-    // Build coinbase\n-    const txs = [];\n-    const coinbase = {\n-      isCoinbase: true,\n-      inputs: [],\n-      outputs: [{ address: addr, amount: getBlockReward(index) }],\n-      id: null\n-    };\n-\n-    // pick some mempool txs (no fee sorting here for brevity)\n-    const pool = Object.values(mempool).slice(0, config.maxBlockTx);\n-    // Compute fees to add to coinbase\n-    let fee = 0;\n-    for (const t of pool) {\n-      let inSum = 0, outSum = 0;\n-      for (const i of t.inputs) {\n-        const u = utxo.get(`${i.txid}:${i.index}`);\n-        if (u) inSum += u.amount;\n-      }\n-      for (const o of t.outputs) outSum += o.amount;\n-      if (inSum > outSum) fee += (inSum - outSum);\n-      txs.push(t);\n-    }\n-    coinbase.outputs[0].amount += fee;\n-\n-    // finalize ids\n-    coinbase.id = txIdFor(coinbase);\n-    const list = [coinbase, ...txs];\n-    list.forEach(t => { if (!t.id) t.id = txIdFor(t); });\n-\n-    const block = {\n-      index,\n-      previousHash,\n-      timestamp: Date.now(),\n-      transactions: list,\n-      merkleRoot: merkleRoot(list.map(t => t.id)),\n-      nonce: 0,\n-      bits: config.bits\n-    };\n-    block.hash = headerHash(block);\n-    res.json(block);\n-  } catch (e) {\n-    res.status(500).json({ error: e.message });\n-  }\n-});\n-\n-// -------------------- Boot --------------------\n-const server = app.listen(HTTP_PORT, () => {\n-  log(`HTTP listening on ${HTTP_PORT}`);\n-  loadBlocks();\n-  if (chain.length === 0) {\n-    const genesis = {\n-      index: 0,\n-      previousHash: '0',\n-      timestamp: Date.now(),\n-      transactions: [{\n-        id: 'genesis',\n-        isCoinbase: true,\n-        inputs: [],\n-        outputs: [{ address: 'genesis', amount: 0 }]\n-      }],\n-      merkleRoot: merkleRoot(['genesis']),\n-      nonce: 0,\n-      bits: config.bits\n-    };\n-    genesis.hash = headerHash(genesis);\n-    saveBlock(genesis);\n-    chain.push(genesis);\n-    seenBlockHash.add(headerHash(genesis));\n-  }\n-  rebuildUTXO();\n-  log(`Loaded ${chain.length} blocks. Tip #${chain.length - 1}`);\n-});\n-\n-// -------------------- P2P Wiring --------------------\n-initP2P({\n-  p2pPort: P2P_PORT, peers: PEERS, onOpen: () => {\n-    log(`P2P listening on ${P2P_PORT} peers=${PEERS.length}`);\n-  }\n-});\n-\n-// Incoming P2P messages\n-p2pOnMessage(async (msg) => {\n-  try {\n-    if (msg.type === 'tx') {\n-      const tx = msg.tx;\n-      if (!tx.id) tx.id = txIdFor(tx);\n-      if (seenTx.has(tx.id) || mempool[tx.id]) return;\n-      validateTx(tx, chain.length);\n-      mempool[tx.id] = tx;\n-      seenTx.add(tx.id);\n-      log(`[P2P] tx ${tx.id.slice(0, 12)}‚Ä¶ added from peer`);\n-      // rebroadcast\n-      p2pBroadcast({ type: 'tx', tx });\n-    } else if (msg.type === 'block') {\n-      const b = msg.block;\n-      const hh = headerHash(b);\n-      if (seenBlockHash.has(hh)) return;\n-      // ensure tx ids present\n-      for (const t of b.transactions) if (!t.id) t.id = txIdFor(t);\n-      validateBlock(b);\n-      applyBlock(b);\n-      maybeRetarget();\n-      log(`[P2P] block #${b.index} accepted from peer`);\n-      p2pBroadcast({ type: 'block', block: b });\n-    } else if (msg.type === 'get_tip') {\n-      const tip = chain[chain.length - 1];\n-      p2pBroadcast({ type: 'tip', tip });\n-    } else if (msg.type === 'tip') {\n-      // could implement fork-choice here (highest cumulative work) ‚Äì omitted for brevity in this step\n-    }\n-  } catch (e) {\n-    warn('[P2P msg error]', e.message);\n-  }\n-});\n"
                },
                {
                    "date": 1762004972410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n   adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n   targetBlockTimeSec: 30,   // Target block time: 30 seconds\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 500,     // Reward halving occurs every 500\n-  coinbaseMaturity: 5,      // Coinbase rewards can be spent only after 100 confirmations\n+  coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 100 confirmations\n   maxBlockTx: 100,          // Larger block capacity to simulate realistic blocks\n   bits: 0x1e00ffff          // Initial network difficulty\n };\n \n"
                },
                {
                    "date": 1762006215111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n   adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n   targetBlockTimeSec: 30,   // Target block time: 30 seconds\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 500,     // Reward halving occurs every 500\n-  coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 100 confirmations\n+  coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 2 confirmations\n   maxBlockTx: 100,          // Larger block capacity to simulate realistic blocks\n   bits: 0x1e00ffff          // Initial network difficulty\n };\n \n"
                },
                {
                    "date": 1762006658452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n const PEERS = process.env.PEERS ? JSON.parse(process.env.PEERS) : []\n \n let config = {\n   adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n-  targetBlockTimeSec: 30,   // Target block time: 30 seconds\n+  targetBlockTimeSec: 10,   // Target block time: 30 seconds\n   blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n   halvingInterval: 500,     // Reward halving occurs every 500\n   coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 2 confirmations\n   maxBlockTx: 100,          // Larger block capacity to simulate realistic blocks\n"
                },
                {
                    "date": 1762006710739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,12 +27,12 @@\n \n let config = {\n   adjustEvery: 10,          // Bitcoin adjusts difficulty every 10 blocks\n   targetBlockTimeSec: 10,   // Target block time: 30 seconds\n-  blockSubsidy: 50,         // Initial mining reward: 50 BTC (halves over time)\n-  halvingInterval: 500,     // Reward halving occurs every 500\n+  blockSubsidy: 5,          // Initial mining reward: 5 BTC\n+  halvingInterval: 100,     // Reward halving occurs every 500\n   coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 2 confirmations\n-  maxBlockTx: 100,          // Larger block capacity to simulate realistic blocks\n+  maxBlockTx: 25,          // Larger block capacity to simulate realistic blocks\n   bits: 0x1e00ffff          // Initial network difficulty\n };\n \n const CONFIG_FILE = DATA_DIR + '/config.json';\n"
                },
                {
                    "date": 1762006926596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,8 +47,9 @@\n let mempool = {};           // txid -> tx\n let utxo = new Map();       // `${txid}:${index}` -> { amount, address, blockHeight, isCoinbase }\n let seenTx = new Set();     // prevent gossip loops\n let seenBlockHash = new Set();\n+let mempoolSpent = new Set(); // 'txid:index'\n \n // -------------------- Utils --------------------\n const sha256Hex = (buf) => crypto.createHash('sha256').update(buf).digest('hex');\n \n"
                },
                {
                    "date": 1762007041933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n   targetBlockTimeSec: 10,   // Target block time: 30 seconds\n   blockSubsidy: 5,          // Initial mining reward: 5 BTC\n   halvingInterval: 100,     // Reward halving occurs every 500\n   coinbaseMaturity: 2,      // Coinbase rewards can be spent only after 2 confirmations\n-  maxBlockTx: 25,          // Larger block capacity to simulate realistic blocks\n+  maxBlockTx: 25,           // Larger block capacity to simulate realistic blocks\n   bits: 0x1e00ffff          // Initial network difficulty\n };\n \n const CONFIG_FILE = DATA_DIR + '/config.json';\n"
                },
                {
                    "date": 1762007183224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,8 +248,12 @@\n         const key = `${i.txid}:${i.index}`;\n         const ent = temp.get(key);\n         if (!ent) throw new Error('missing input ' + key);\n         // signature check against original tx object (already contains sigs)\n+        // enforce coinbase maturity\n+        if (ent.isCoinbase && (block.index - ent.blockHeight) < config.coinbaseMaturity) {\n+          throw new Error('coinbase not mature');\n+        }\n         verifyInputSig(tx, idx);\n         // pubKey matches address\n         const addr = pubKeyToAddress(i.pubKey);\n         if (addr !== ent.address) throw new Error('pubKey!=address');\n"
                },
                {
                    "date": 1762007235042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,10 +350,20 @@\n     const tx = req.body;\n     if (!tx.id) tx.id = txIdFor(tx);\n     // validation against current UTXO/state\n     validateTx(tx, chain.length);\n+\n+    // prevent mempool double spend\n+    for (const i of tx.inputs) {\n+      const key = `${i.txid}:${i.index}`;\n+      if (mempoolSpent.has(key)) throw new Error('mempool double spend');\n+    }\n+\n     if (mempool[tx.id]) return res.status(200).json({ ok: true, id: tx.id, note: 'duplicate in mempool' });\n+\n     mempool[tx.id] = tx;\n+    for (const i of tx.inputs) mempoolSpent.add(`${i.txid}:${i.index}`);\n+\n     seenTx.add(tx.id);\n     log(`+ mempool tx ${tx.id.slice(0, 16)}‚Ä¶`);\n     // Gossip to peers\n     p2pBroadcast({ type: 'tx', tx });\n"
                },
                {
                    "date": 1762007297722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,9 +282,12 @@\n   // spend & create\n   for (const tx of block.transactions) {\n     for (const i of tx.inputs || []) utxo.delete(`${i.txid}:${i.index}`);\n     tx.outputs.forEach((o, idx) => utxo.set(`${tx.id}:${idx}`, { amount: o.amount, address: o.address, blockHeight: block.index, isCoinbase: !!tx.isCoinbase }));\n-    if (mempool[tx.id]) delete mempool[tx.id];\n+    if (mempool[tx.id]) {\n+      for (const i of (tx.inputs || [])) mempoolSpent.delete(`${i.txid}:${i.index}`);\n+      delete mempool[tx.id];\n+    }\n   }\n   chain.push(block);\n   saveBlock(block);\n   seenBlockHash.add(headerHash(block));\n"
                },
                {
                    "date": 1762007323091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,15 @@\n       const tx = msg.tx;\n       if (!tx.id) tx.id = txIdFor(tx);\n       if (seenTx.has(tx.id) || mempool[tx.id]) return;\n       validateTx(tx, chain.length);\n+      for (const i of tx.inputs) {\n+        const k = `${i.txid}:${i.index}`;\n+        if (mempoolSpent.has(k)) throw new Error('mempool double spend');\n+      }\n       mempool[tx.id] = tx;\n+      for (const i of tx.inputs) mempoolSpent.add(`${i.txid}:${i.index}`);\n+\n       seenTx.add(tx.id);\n       log(`[P2P] tx ${tx.id.slice(0, 12)}‚Ä¶ added from peer`);\n       // rebroadcast\n       p2pBroadcast({ type: 'tx', tx });\n"
                },
                {
                    "date": 1762007341492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,29 +82,40 @@\n }\n \n // --- Compact Target Bits (Bitcoin-like) ---\n function bitsToTarget(bits) {\n-  const exp = (bits >>> 24) & 0xff;\n+  const size = (bits >>> 24) & 0xff;\n   let mant = BigInt(bits & 0x007fffff);\n-  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n-  // target = mantissa * 256^(exp-3)\n-  const shift = BigInt(8 * (exp - 3));\n-  return mant << shift;\n+  let target;\n+  if (size <= 3) {\n+    const shift = 8n * (3n - BigInt(size));\n+    target = mant >> shift;\n+  } else {\n+    const shift = 8n * (BigInt(size) - 3n);\n+    target = mant << shift;\n+  }\n+  return target;\n }\n+\n function targetToBits(target) {\n-  // convert BigInt target to compact\n+  if (target <= 0n) return 0;\n   let hex = target.toString(16);\n   if (hex.length % 2) hex = '0' + hex;\n-  const size = Math.ceil(hex.length / 2);\n-  let mant;\n+  let size = Math.ceil(hex.length / 2);\n+  let mantBytes;\n   if (size <= 3) {\n-    mant = BigInt('0x' + hex.padEnd(6, '0'));\n+    mantBytes = hex.padStart(6, '0');\n   } else {\n-    mant = BigInt('0x' + hex.slice(0, 6));\n+    mantBytes = hex.slice(0, 6);\n+    if (parseInt(mantBytes.slice(0, 2), 16) & 0x80) {\n+      mantBytes = ('00' + mantBytes.slice(0, 4));\n+      size += 1;\n+    }\n   }\n-  let bits = (size << 24) | Number(mant & 0x007fffff);\n-  return bits >>> 0;\n+  let mant = parseInt(mantBytes, 16) & 0x007fffff;\n+  return ((size << 24) | mant) >>> 0;\n }\n+\n function hashMeetsBits(hexHash, bits) {\n   const h = BigInt('0x' + hexHash);\n   const target = bitsToTarget(bits);\n   return h <= target;\n"
                },
                {
                    "date": 1762007373422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,40 +82,29 @@\n }\n \n // --- Compact Target Bits (Bitcoin-like) ---\n function bitsToTarget(bits) {\n-  const size = (bits >>> 24) & 0xff;\n+  const exp = (bits >>> 24) & 0xff;\n   let mant = BigInt(bits & 0x007fffff);\n-  let target;\n-  if (size <= 3) {\n-    const shift = 8n * (3n - BigInt(size));\n-    target = mant >> shift;\n-  } else {\n-    const shift = 8n * (BigInt(size) - 3n);\n-    target = mant << shift;\n-  }\n-  return target;\n+  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n+  // target = mantissa * 256^(exp-3)\n+  const shift = BigInt(8 * (exp - 3));\n+  return mant << shift;\n }\n-\n function targetToBits(target) {\n-  if (target <= 0n) return 0;\n+  // convert BigInt target to compact\n   let hex = target.toString(16);\n   if (hex.length % 2) hex = '0' + hex;\n-  let size = Math.ceil(hex.length / 2);\n-  let mantBytes;\n+  const size = Math.ceil(hex.length / 2);\n+  let mant;\n   if (size <= 3) {\n-    mantBytes = hex.padStart(6, '0');\n+    mant = BigInt('0x' + hex.padEnd(6, '0'));\n   } else {\n-    mantBytes = hex.slice(0, 6);\n-    if (parseInt(mantBytes.slice(0, 2), 16) & 0x80) {\n-      mantBytes = ('00' + mantBytes.slice(0, 4));\n-      size += 1;\n-    }\n+    mant = BigInt('0x' + hex.slice(0, 6));\n   }\n-  let mant = parseInt(mantBytes, 16) & 0x007fffff;\n-  return ((size << 24) | mant) >>> 0;\n+  let bits = (size << 24) | Number(mant & 0x007fffff);\n+  return bits >>> 0;\n }\n-\n function hashMeetsBits(hexHash, bits) {\n   const h = BigInt('0x' + hexHash);\n   const target = bitsToTarget(bits);\n   return h <= target;\n"
                },
                {
                    "date": 1762007416501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,29 +82,40 @@\n }\n \n // --- Compact Target Bits (Bitcoin-like) ---\n function bitsToTarget(bits) {\n-  const exp = (bits >>> 24) & 0xff;\n+  const size = (bits >>> 24) & 0xff;\n   let mant = BigInt(bits & 0x007fffff);\n-  if (bits & 0x00800000) mant = mant | (1n << 23n); // sign bit not used; keep positive\n-  // target = mantissa * 256^(exp-3)\n-  const shift = BigInt(8 * (exp - 3));\n-  return mant << shift;\n+  let target;\n+  if (size <= 3) {\n+    const shift = 8n * (3n - BigInt(size));\n+    target = mant >> shift;\n+  } else {\n+    const shift = 8n * (BigInt(size) - 3n);\n+    target = mant << shift;\n+  }\n+  return target;\n }\n+\n function targetToBits(target) {\n-  // convert BigInt target to compact\n+  if (target <= 0n) return 0;\n   let hex = target.toString(16);\n   if (hex.length % 2) hex = '0' + hex;\n-  const size = Math.ceil(hex.length / 2);\n-  let mant;\n+  let size = Math.ceil(hex.length / 2);\n+  let mantBytes;\n   if (size <= 3) {\n-    mant = BigInt('0x' + hex.padEnd(6, '0'));\n+    mantBytes = hex.padStart(6, '0');\n   } else {\n-    mant = BigInt('0x' + hex.slice(0, 6));\n+    mantBytes = hex.slice(0, 6);\n+    if (parseInt(mantBytes.slice(0, 2), 16) & 0x80) {\n+      mantBytes = ('00' + mantBytes.slice(0, 4));\n+      size += 1;\n+    }\n   }\n-  let bits = (size << 24) | Number(mant & 0x007fffff);\n-  return bits >>> 0;\n+  let mant = parseInt(mantBytes, 16) & 0x007fffff;\n+  return ((size << 24) | mant) >>> 0;\n }\n+\n function hashMeetsBits(hexHash, bits) {\n   const h = BigInt('0x' + hexHash);\n   const target = bitsToTarget(bits);\n   return h <= target;\n@@ -219,8 +230,11 @@\n     if (block.index !== 0) throw new Error('genesis index must be 0');\n   } else {\n     if (block.index !== tip.index + 1) throw new Error('bad index');\n     if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n+    const MAX_FUTURE = 2 * 60 * 60 * 1000; // 2 hours\n+    if (block.timestamp > Date.now() + MAX_FUTURE)\n+      throw new Error('timestamp too far in future');\n   }\n \n   // basic header checks\n   const txids = block.transactions.map(t => t.id);\n"
                },
                {
                    "date": 1762007439566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -230,11 +230,8 @@\n     if (block.index !== 0) throw new Error('genesis index must be 0');\n   } else {\n     if (block.index !== tip.index + 1) throw new Error('bad index');\n     if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n-    const MAX_FUTURE = 2 * 60 * 60 * 1000; // 2 hours\n-    if (block.timestamp > Date.now() + MAX_FUTURE)\n-      throw new Error('timestamp too far in future');\n   }\n \n   // basic header checks\n   const txids = block.transactions.map(t => t.id);\n"
                },
                {
                    "date": 1762007489414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -232,8 +232,13 @@\n     if (block.index !== tip.index + 1) throw new Error('bad index');\n     if (block.previousHash !== headerHash(tip)) throw new Error('prev hash mismatch');\n   }\n \n+  // timestamp sanity check\n+  const MAX_FUTURE = 2 * 60 * 60 * 1000; // 2 hours\n+  if (block.timestamp > Date.now() + MAX_FUTURE)\n+    throw new Error('timestamp too far in future');\n+\n   // basic header checks\n   const txids = block.transactions.map(t => t.id);\n   if (merkleRoot(txids) !== block.merkleRoot) throw new Error('merkle mismatch');\n   const hh = headerHash(block);\n"
                }
            ],
            "date": 1761990495129,
            "name": "Commit-0",
            "content": "/**\n * üß± Minimal Blockchain Full Node (Final)\n * ------------------------------------------------------------\n * - UTXO validation\n * - Deterministic TX IDs\n * - Numeric PoW: BigInt(hash) < target\n * - Merkle root + canonical header hashing\n * - Halving-based block reward\n * - Difficulty adjustment\n * - File-based block persistence\n * - REST + WebSocket miner interface\n * ------------------------------------------------------------\n */\n\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst EC = require('elliptic').ec;\nconst ec = new EC('secp256k1');\nconst http = require('http');\nconst { WebSocketServer } = require('ws');\n\nconst app = express();\napp.use(bodyParser.json());\nconst PORT = 3000;\n\n// ----------------------\n// Directories & Config\n// ----------------------\nconst BLOCKS_DIR = path.join(__dirname, 'blocks');\nif (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n\nconst MEMPOOL_MAX = 1000;\nconst CONFIG_FILE = path.join(__dirname, 'config.json');\nlet config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n\n// ----------------------\n// In-memory state\n// ----------------------\nlet chain = [];\nlet mempool = [];\nlet UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n\n// ----------------------\n// Crypto Utils\n// ----------------------\nconst sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\nconst sha256 = d => crypto.createHash('sha256').update(d).digest();\nconst ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n\nfunction pubKeyToAddress(pubKeyHex) {\n  return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n}\n\nfunction txHashForSigning(tx) {\n  const slim = {\n    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n  };\n  return sha256hex(JSON.stringify(slim));\n}\n\n// ----------------------------------------------------\n// Proof-of-Work target (Bitcoin-style): target = MAX / difficulty\n// ----------------------------------------------------\nfunction getTarget(difficulty) {\n  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n  return maxTarget / BigInt(difficulty);\n}\n\n// ----------------------\n// Helpers\n// ----------------------\nfunction conflictsWithMempool(tx) {\n  if (!tx.inputs) return false;\n  const spent = new Set();\n  for (const t of mempool)\n    for (const i of (t.inputs || []))\n      spent.add(`${i.txid}:${i.index}`);\n  return tx.inputs.some(i => spent.has(`${i.txid}:${i.index}`));\n}\n\nfunction stableStringify(obj) {\n  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n}\n\nfunction computeTxId(tx) {\n  const idShape = {\n    inputs: (tx.inputs || []).map(i => ({\n      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n    })),\n    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n  };\n  return sha256hex(stableStringify(idShape));\n}\n\n// Merkle root over txids (binary concatenation)\nfunction merkleRoot(txids) {\n  if (txids.length === 0) return sha256hex('');\n  let layer = txids.map(x => Buffer.from(x, 'hex'));\n  while (layer.length > 1) {\n    const next = [];\n    for (let i = 0; i < layer.length; i += 2) {\n      const left = layer[i];\n      const right = layer[i + 1] || left; // duplicate last if odd\n      next.push(sha256(Buffer.concat([left, right])));\n    }\n    layer = next;\n  }\n  return layer[0].toString('hex');\n}\n\n// Canonical header hashing (no JSON, deterministic order)\nfunction headerHash(header) {\n  const data = [\n    String(header.index),\n    header.previousHash,\n    String(header.timestamp),\n    header.merkleRoot,\n    String(header.nonce),\n    String(header.difficulty)\n  ].join('|');\n  return sha256hex(data);\n}\n\n// ----------------------\n// Halving-based reward\n// ----------------------\nfunction getBlockReward(height) {\n  const interval = config.halvingInterval || Infinity;\n  const halvings = Math.floor(height / interval);\n  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n  return reward > 0 ? reward : 0;\n}\n\n// ----------------------\n// Chain init\n// ----------------------\nfunction applyTxToUTXO(tx) {\n  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n}\n\nfunction rebuildUTXO() {\n  UTXO.clear();\n  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n}\n\nfunction createGenesisBlock() {\n  const g = {\n    index: 0,\n    timestamp: new Date().toISOString(),\n    transactions: [],\n    previousHash: '0',\n    nonce: 0,\n    difficulty: config.difficulty\n  };\n  const root = merkleRoot([]);\n  const header = { ...g, merkleRoot: root };\n  g.hash = headerHash(header);\n  return g;\n}\n\nfunction loadChain() {\n  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n  if (files.length === 0) {\n    const g = createGenesisBlock();\n    chain.push(g);\n    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n    console.log('üß± Genesis block created');\n  } else {\n    for (const f of files)\n      chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n    console.log(`üì¶ Loaded ${chain.length} blocks from disk`);\n  }\n  rebuildUTXO();\n  console.log(`‚õìÔ∏è  Tip: #${chain[chain.length - 1].index}, hash=${chain[chain.length - 1].hash.slice(0, 12)}...`);\n}\nloadChain();\n\n// ----------------------\n// Validation\n// ----------------------\nfunction validateTx(tx, utxoSet = UTXO) {\n  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n\n  if (isCoinbase) {\n    for (const o of tx.outputs)\n      if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n        return { ok: false, error: 'invalid output' };\n    return { ok: true, fee: 0 };\n  }\n\n  const seen = new Set();\n  let inSum = 0, outSum = 0;\n  const msgHash = txHashForSigning(tx);\n\n  for (const inp of tx.inputs) {\n    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number')\n      return { ok: false, error: 'bad input format' };\n\n    const key = `${inp.txid}:${inp.index}`;\n    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n    seen.add(key);\n\n    const u = utxoSet.get(key);\n    if (!u) return { ok: false, error: `missing utxo ${key}` };\n\n    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n    const addr = pubKeyToAddress(inp.pubKey);\n    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n\n    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n\n    inSum += u.amount;\n  }\n\n  for (const o of tx.outputs) {\n    if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n      return { ok: false, error: 'invalid output' };\n    outSum += o.amount;\n  }\n\n  const fee = inSum - outSum;\n  if (fee < 0) return { ok: false, error: 'negative fee' };\n\n  return { ok: true, fee };\n}\n\nfunction validateBlock(block) {\n  const last = chain[chain.length - 1];\n\n  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n\n  // Timestamp sanity (+2 min skew window)\n  const t = new Date(block.timestamp).getTime();\n  const now = Date.now();\n  const lastT = new Date(last.timestamp).getTime();\n  if (!(t >= lastT && t <= now + 2 * 60 * 1000))\n    return { ok: false, error: 'bad timestamp' };\n\n  // Recompute header hash & PoW\n  const root = merkleRoot(block.transactions.map(tx => tx.id));\n  const header = {\n    index: block.index,\n    previousHash: block.previousHash,\n    timestamp: block.timestamp,\n    merkleRoot: root,\n    nonce: block.nonce,\n    difficulty: block.difficulty\n  };\n  const h = headerHash(header);\n  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n\n  const target = getTarget(block.difficulty);\n  const hashInt = BigInt('0x' + block.hash);\n  if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n  console.log(`üîç PoW OK: target‚âà0x${target.toString(16).slice(0, 16)}...`);\n\n  // TXs + temp UTXO\n  const temp = new Map(UTXO);\n  let seenTxIds = new Set();\n  let coinbaseCount = 0;\n  let feeTotal = 0;\n\n  for (const tx of block.transactions) {\n    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n    seenTxIds.add(tx.id);\n\n    const v = validateTx(tx, temp);\n    if (!v.ok) return v;\n\n    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n    feeTotal += v.fee;\n\n    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n  }\n\n  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n\n  // Enforce coinbase amount (‚â§ subsidy+fees)\n  const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n  const expectedReward = getBlockReward(block.index) + feeTotal;\n  if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n    return { ok: false, error: 'coinbase reward too high' };\n\n  return { ok: true };\n}\n\n// ----------------------\n// Difficulty Adjustment\n// ----------------------\nfunction adjustDifficulty(tipIndex) {\n  const n = config.adjustEvery;\n  if (chain.length <= n || n < 2) return;\n\n  const lastN = chain.slice(-n);\n  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a, b) => a - b);\n  const duration = (times[times.length - 1] - times[0]) / 1000;\n  const avgTime = duration / (n - 1);\n  const target = config.targetBlockTimeSec;\n  const ratio = avgTime / target;\n\n  const oldDiff = config.difficulty;\n  if (ratio < 0.9) config.difficulty++;\n  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n\n  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n  console.log(`‚öôÔ∏è Difficulty adjust ‚Üí old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n  wsBroadcast({ type: 'config_update', config });\n\n  const height = typeof tipIndex === 'number' ? tipIndex : (chain.length - 1);\n  const currentReward = getBlockReward(height);\n  const nextHalving = Math.ceil((Math.floor(height / (config.halvingInterval || Infinity)) + 1) * (config.halvingInterval || Infinity));\n  if (isFinite(nextHalving)) {\n    console.log(`üíé Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n  } else {\n    console.log(`üíé Block reward: ${currentReward} | Halving disabled`);\n  }\n}\n\n// ----------------------\n// REST API\n// ----------------------\napp.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\napp.get('/mempool', (req, res) => res.json({ mempool }));\napp.get('/config', (req, res) => res.json(config));\n\napp.post('/transactions', (req, res) => {\n  const tx = req.body;\n\n  if (mempool.length >= MEMPOOL_MAX)\n    return res.status(400).json({ error: 'mempool full' });\n\n  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n    return res.status(400).json({ error: 'missing outputs' });\n\n  tx.id = computeTxId(tx);\n\n  const v = validateTx(tx);\n  if (!v.ok) return res.status(400).json({ error: v.error });\n  tx.fee = v.fee;\n\n  if (conflictsWithMempool(tx))\n    return res.status(400).json({ error: 'mempool double-spend' });\n\n  mempool.push(tx);\n  console.log(`üí∞ TX accepted: ${tx.id.slice(0, 12)}... | fee=${tx.fee}`);\n  wsBroadcast({ type: 'mempool_tx', tx });\n  res.json({ status: 'added', id: tx.id });\n});\n\napp.post('/blocks', (req, res) => {\n  const block = req.body;\n  const v = validateBlock(block);\n  if (!v.ok) return res.status(400).json({ error: v.error });\n\n  const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n  if (fs.existsSync(filePath))\n    return res.status(400).json({ error: 'block file already exists' });\n\n  fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n  chain.push(block);\n\n  for (const tx of block.transactions) applyTxToUTXO(tx);\n  const ids = new Set(block.transactions.map(t => t.id));\n  mempool = mempool.filter(t => !ids.has(t.id));\n\n  console.log(`üß± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n  wsBroadcast({\n    type: 'new_block',\n    header: {\n      index: block.index,\n      hash: block.hash,\n      difficulty: block.difficulty,\n      txs: block.transactions.length\n    }\n  });\n\n  adjustDifficulty(block.index);\n  res.json({ status: 'block accepted', index: block.index });\n});\n\n// ----------------------\n// WebSocket Server\n// ----------------------\nconst server = http.createServer(app);\nconst wss = new WebSocketServer({ server });\n\nfunction wsBroadcast(obj) {\n  const msg = JSON.stringify(obj);\n  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n}\n\nwss.on('connection', (ws) => {\n  console.log('üîå Miner connected');\n  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n});\n\n// ----------------------\n// Start\n// ----------------------\nserver.listen(PORT, () => console.log(`üöÄ Node running on http://localhost:${PORT}`));\n"
        }
    ]
}