{
    "sourceFile": "apps/miner/server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 29,
            "patches": [
                {
                    "date": 1761988261380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761988319069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,19 +19,8 @@\n // üîπ Hash & Target Utilities\n //-----------------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n \n-function blockHash(b) {\n-  return sha256hex(\n-    b.index +\n-    b.previousHash +\n-    b.timestamp +\n-    JSON.stringify(b.transactions) +\n-    b.nonce +\n-    b.difficulty\n-  );\n-}\n-\n // Convert difficulty ‚Üí numeric PoW target\n function getTarget(difficulty) {\n   const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n   return maxTarget / BigInt(difficulty);\n@@ -52,8 +41,17 @@\n   }\n   return layer[0].toString('hex');\n }\n \n+// Canonical block header hashing (deterministic)\n+function headerHash(header) {\n+  const data = [\n+    String(header.index), header.previousHash, String(header.timestamp),\n+    header.merkleRoot, String(header.nonce), String(header.difficulty)\n+  ].join('|');\n+  return sha256hex(data);\n+}\n+\n //-----------------------------------------------\n // üîπ Global mining state\n //-----------------------------------------------\n let abortFlag = false;\n"
                },
                {
                    "date": 1761988342710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,9 +110,9 @@\n       let hashesTried = 0;\n \n       while (!abortFlag) {\n         const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n-        hash = blockHash(block);\n+        hash = headerHash(block);\n         hashesTried++;\n \n         // Measure hashrate every 1M tries\n         if (hashesTried % 1_000_000 === 0) {\n"
                },
                {
                    "date": 1761988382323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,8 +110,16 @@\n       let hashesTried = 0;\n \n       while (!abortFlag) {\n         const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n+        const header = {\n+          index: block.index,\n+          previousHash: block.previousHash,\n+          timestamp: block.timestamp,\n+          merkleRoot: root,\n+          nonce: block.nonce,\n+          difficulty: block.difficulty\n+        };\n         hash = headerHash(block);\n         hashesTried++;\n \n         // Measure hashrate every 1M tries\n"
                },
                {
                    "date": 1761988392425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,8 +109,9 @@\n       let lastHashCheck = start;\n       let hashesTried = 0;\n \n       while (!abortFlag) {\n+        const root = merkleRoot(block.transactions.map(tx => tx.id));\n         const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n         const header = {\n           index: block.index,\n           previousHash: block.previousHash,\n"
                },
                {
                    "date": 1761988421834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,19 +109,19 @@\n       let lastHashCheck = start;\n       let hashesTried = 0;\n \n       while (!abortFlag) {\n+        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n         const root = merkleRoot(block.transactions.map(tx => tx.id));\n-        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n         const header = {\n           index: block.index,\n           previousHash: block.previousHash,\n           timestamp: block.timestamp,\n           merkleRoot: root,\n           nonce: block.nonce,\n           difficulty: block.difficulty\n         };\n-        hash = headerHash(block);\n+        hash = headerHash(header);\n         hashesTried++;\n \n         // Measure hashrate every 1M tries\n         if (hashesTried % 1_000_000 === 0) {\n"
                },
                {
                    "date": 1761988511580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,9 @@\n //-----------------------------------------------\n // üîπ Hash & Target Utilities\n //-----------------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n+const sha256 = d => crypto.createHash('sha256').update(d).digest();\n \n // Convert difficulty ‚Üí numeric PoW target\n function getTarget(difficulty) {\n   const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n"
                },
                {
                    "date": 1761989080470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,21 @@\n   ].join('|');\n   return sha256hex(data);\n }\n \n+function calcFee(tx, utxoSet) {\n+  if (!tx.inputs || tx.inputs.length === 0) return 0;\n+  let inSum = 0, outSum = 0;\n+  for (const inp of tx.inputs) {\n+    const key = `${inp.txid}:${inp.index}`;\n+    const u = utxoSet[key];\n+    if (u) inSum += u.amount;\n+  }\n+  outSum = tx.outputs.reduce((a, o) => a + o.amount, 0);\n+  return inSum - outSum;\n+}\n+\n+\n //-----------------------------------------------\n // üîπ Global mining state\n //-----------------------------------------------\n let abortFlag = false;\n"
                },
                {
                    "date": 1761989180721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,8 +72,9 @@\n let totalMined = 0;\n let currentDiff = 1;\n let blockTimes = [];\n let hashrateWindow = [];\n+let UTXO = new Map(); // local copy of unspent outputs\n \n //-----------------------------------------------\n // üîπ Fetch block template from node\n //-----------------------------------------------\n"
                },
                {
                    "date": 1761989197306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,21 +51,30 @@\n   ].join('|');\n   return sha256hex(data);\n }\n \n-function calcFee(tx, utxoSet) {\n-  if (!tx.inputs || tx.inputs.length === 0) return 0;\n-  let inSum = 0, outSum = 0;\n-  for (const inp of tx.inputs) {\n-    const key = `${inp.txid}:${inp.index}`;\n-    const u = utxoSet[key];\n-    if (u) inSum += u.amount;\n+async function rebuildUTXO() {\n+  const { data: chainData } = await axios.get(`${NODE_HTTP}/chain`);\n+  const chain = chainData.chain;\n+\n+  UTXO.clear();\n+\n+  for (const block of chain) {\n+    for (const tx of block.transactions) {\n+      // remove spent inputs\n+      for (const inp of tx.inputs || [])\n+        UTXO.delete(`${inp.txid}:${inp.index}`);\n+\n+      // add outputs\n+      tx.outputs.forEach((o, i) => {\n+        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n+      });\n+    }\n   }\n-  outSum = tx.outputs.reduce((a, o) => a + o.amount, 0);\n-  return inSum - outSum;\n+\n+  console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n }\n \n-\n //-----------------------------------------------\n // üîπ Global mining state\n //-----------------------------------------------\n let abortFlag = false;\n"
                },
                {
                    "date": 1761989206408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,8 +73,22 @@\n \n   console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n }\n \n+function calcFee(tx) {\n+  if (!tx.inputs || tx.inputs.length === 0) return 0; // coinbase\n+  let inSum = 0, outSum = 0;\n+  for (const inp of tx.inputs) {\n+    const key = `${inp.txid}:${inp.index}`;\n+    const u = UTXO.get(key);\n+    if (!u) return 0; // skip if unknown input\n+    inSum += u.amount;\n+  }\n+  for (const o of tx.outputs) outSum += o.amount;\n+  const fee = inSum - outSum;\n+  return Math.max(0, fee);\n+}\n+\n //-----------------------------------------------\n // üîπ Global mining state\n //-----------------------------------------------\n let abortFlag = false;\n"
                },
                {
                    "date": 1761989237571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,9 +112,10 @@\n   const mempool = memData.mempool || [];\n   currentDiff = conf.difficulty;\n \n   const reward = conf.blockSubsidy;\n-  const fees = mempool.reduce((a, t) => a + (t.fee || 0), 0);\n+  let fees = 0;\n+  for (const tx of mempool) fees += calcFee(tx);\n   const last = chain[chain.length - 1];\n   const index = chain.length;\n   const previousHash = last.hash;\n   const timestamp = new Date().toISOString();\n"
                },
                {
                    "date": 1761989254708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,8 +132,9 @@\n //-----------------------------------------------\n // üîπ Main mining loop (with target-based PoW)\n //-----------------------------------------------\n async function mineLoop() {\n+  await rebuildUTXO();\n   while (true) {\n     try {\n       const tpl = await buildTemplate();\n       const { index, previousHash, timestamp, txs, diff } = tpl;\n"
                },
                {
                    "date": 1761989296053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,11 +111,12 @@\n   const chain = chainData.chain;\n   const mempool = memData.mempool || [];\n   currentDiff = conf.difficulty;\n \n-  const reward = conf.blockSubsidy;\n   let fees = 0;\n   for (const tx of mempool) fees += calcFee(tx);\n+\n+  const reward = conf.blockSubsidy;\n   const last = chain[chain.length - 1];\n   const index = chain.length;\n   const previousHash = last.hash;\n   const timestamp = new Date().toISOString();\n"
                },
                {
                    "date": 1761989301261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,8 +111,9 @@\n   const chain = chainData.chain;\n   const mempool = memData.mempool || [];\n   currentDiff = conf.difficulty;\n \n+  // üîπ Compute fees from real UTXO set\n   let fees = 0;\n   for (const tx of mempool) fees += calcFee(tx);\n \n   const reward = conf.blockSubsidy;\n"
                },
                {
                    "date": 1761990009781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,8 +73,9 @@\n \n   console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n }\n \n+\n function calcFee(tx) {\n   if (!tx.inputs || tx.inputs.length === 0) return 0; // coinbase\n   let inSum = 0, outSum = 0;\n   for (const inp of tx.inputs) {\n"
                },
                {
                    "date": 1761990040251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,253 @@\n+// miner.js - Full Bitcoin-like miner (Target-based PoW + Live Stats)\n+//-----------------------------------------------------------\n+const axios = require('axios');\n+const crypto = require('crypto');\n+const WebSocket = require('ws');\n+const argv = require('minimist')(process.argv.slice(2));\n+\n+if (!argv.address) {\n+  console.error('Usage: node miner.js --address <ADDRESS>');\n+  process.exit(1);\n+}\n+\n+// Node endpoints\n+const NODE_HTTP = 'http://localhost:3000';\n+const NODE_WS = 'ws://localhost:3000';\n+const ADDRESS = argv.address;\n+\n+//-----------------------------------------------\n+// üîπ Hash & Target Utilities\n+//-----------------------------------------------\n+const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n+const sha256 = d => crypto.createHash('sha256').update(d).digest();\n+\n+// Convert difficulty ‚Üí numeric PoW target\n+function getTarget(difficulty) {\n+  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n+  return maxTarget / BigInt(difficulty);\n+}\n+\n+// Build Merkle root from transaction IDs\n+function merkleRoot(txids) {\n+  if (txids.length === 0) return sha256hex('');\n+  let layer = txids.map(x => Buffer.from(x, 'hex'));\n+  while (layer.length > 1) {\n+    const next = [];\n+    for (let i = 0; i < layer.length; i += 2) {\n+      const left = layer[i];\n+      const right = layer[i + 1] || left; // duplicate last if odd\n+      next.push(sha256(Buffer.concat([left, right])));\n+    }\n+    layer = next;\n+  }\n+  return layer[0].toString('hex');\n+}\n+\n+// Canonical block header hashing (deterministic)\n+function headerHash(header) {\n+  const data = [\n+    String(header.index), header.previousHash, String(header.timestamp),\n+    header.merkleRoot, String(header.nonce), String(header.difficulty)\n+  ].join('|');\n+  return sha256hex(data);\n+}\n+\n+async function rebuildUTXO() {\n+  const { data: chainData } = await axios.get(`${NODE_HTTP}/chain`);\n+  const chain = chainData.chain;\n+\n+  UTXO.clear();\n+\n+  for (const block of chain) {\n+    for (const tx of block.transactions) {\n+      // remove spent inputs\n+      for (const inp of tx.inputs || [])\n+        UTXO.delete(`${inp.txid}:${inp.index}`);\n+\n+      // add outputs\n+      tx.outputs.forEach((o, i) => {\n+        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n+      });\n+    }\n+  }\n+\n+  console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n+}\n+\n+function getBlockReward(height, config) {\n+  const interval = config.halvingInterval || Infinity; // ÿß⁄Øÿ± ŸÜÿ®ŸàÿØÿå ŸáÿßŸà€åŸÜ⁄Ø ÿ∫€åÿ±ŸÅÿπÿßŸÑ\n+  const halvings = Math.floor(height / interval);\n+  const base = BigInt(config.blockSubsidy);\n+  const reward = base >> BigInt(halvings); // ÿ™ŸÇÿ≥€åŸÖ ÿ®ÿ± 2^halvings\n+  return Number(reward > 0n ? reward : 0n);\n+}\n+\n+function calcFee(tx) {\n+  if (!tx.inputs || tx.inputs.length === 0) return 0; // coinbase\n+  let inSum = 0, outSum = 0;\n+  for (const inp of tx.inputs) {\n+    const key = `${inp.txid}:${inp.index}`;\n+    const u = UTXO.get(key);\n+    if (!u) return 0; // skip if unknown input\n+    inSum += u.amount;\n+  }\n+  for (const o of tx.outputs) outSum += o.amount;\n+  const fee = inSum - outSum;\n+  return Math.max(0, fee);\n+}\n+\n+//-----------------------------------------------\n+// üîπ Global mining state\n+//-----------------------------------------------\n+let abortFlag = false;\n+let totalMined = 0;\n+let currentDiff = 1;\n+let blockTimes = [];\n+let hashrateWindow = [];\n+let UTXO = new Map(); // local copy of unspent outputs\n+\n+//-----------------------------------------------\n+// üîπ Fetch block template from node\n+//-----------------------------------------------\n+async function buildTemplate() {\n+  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n+    axios.get(`${NODE_HTTP}/chain`),\n+    axios.get(`${NODE_HTTP}/mempool`),\n+    axios.get(`${NODE_HTTP}/config`)\n+  ]);\n+\n+  const chain = chainData.chain;\n+  const mempool = memData.mempool || [];\n+  currentDiff = conf.difficulty;\n+\n+  // üîπ Compute fees from real UTXO set\n+  let fees = 0;\n+  for (const tx of mempool) fees += calcFee(tx);\n+\n+  const subsidy = getBlockReward(index, conf);\n+  const reward = conf.blockSubsidy;\n+  const last = chain[chain.length - 1];\n+  const index = chain.length;\n+  const previousHash = last.hash;\n+  const timestamp = new Date().toISOString();\n+\n+  const coinbase = {\n+    id: sha256hex('coinbase' + Date.now()),\n+    inputs: [],\n+    outputs: [{ address: ADDRESS, amount: reward + fees }]\n+  };\n+\n+  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n+}\n+\n+//-----------------------------------------------\n+// üîπ Main mining loop (with target-based PoW)\n+//-----------------------------------------------\n+async function mineLoop() {\n+  await rebuildUTXO();\n+  while (true) {\n+    try {\n+      const tpl = await buildTemplate();\n+      const { index, previousHash, timestamp, txs, diff } = tpl;\n+      abortFlag = false;\n+\n+      const target = getTarget(diff);\n+      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n+\n+      let nonce = 0;\n+      let hash;\n+      const start = Date.now();\n+      let lastHashCheck = start;\n+      let hashesTried = 0;\n+\n+      while (!abortFlag) {\n+        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n+        const root = merkleRoot(block.transactions.map(tx => tx.id));\n+        const header = {\n+          index: block.index,\n+          previousHash: block.previousHash,\n+          timestamp: block.timestamp,\n+          merkleRoot: root,\n+          nonce: block.nonce,\n+          difficulty: block.difficulty\n+        };\n+        hash = headerHash(header);\n+        hashesTried++;\n+\n+        // Measure hashrate every 1M tries\n+        if (hashesTried % 1_000_000 === 0) {\n+          const now = Date.now();\n+          const elapsedSec = (now - lastHashCheck) / 1000;\n+          const hashrate = (1_000_000 / elapsedSec) / 1_000_000; // MH/s\n+          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n+          hashrateWindow.push(hashrate);\n+          if (hashrateWindow.length > 10) hashrateWindow.shift();\n+          lastHashCheck = now;\n+        }\n+\n+        // ‚úÖ Real Proof-of-Work check (numeric comparison)\n+        const hashInt = BigInt('0x' + hash);\n+        if (hashInt < target) {\n+          const took = (Date.now() - start) / 1000;\n+          block.hash = hash;\n+          totalMined++;\n+\n+          blockTimes.push(took);\n+          if (blockTimes.length > 10) blockTimes.shift();\n+\n+          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n+          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / hashrateWindow.length || 0;\n+\n+          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n+          console.log(`üìä Stats ‚Üí Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n+          console.log(`üî¢ hash = ${hash}`);\n+          console.log(`üéØ target = ${target.toString(16).slice(0, 16)}...`);\n+\n+          try {\n+            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n+            console.log('üì¶ Submitted:', res.data);\n+          } catch (e) {\n+            console.error('‚ùå Submit error:', e.response?.data || e.message);\n+          }\n+\n+          break; // break inner loop ‚Üí new template\n+        }\n+\n+        nonce++;\n+      }\n+    } catch (e) {\n+      console.error('‚ö†Ô∏è Miner error:', e.message);\n+      await new Promise(r => setTimeout(r, 2000));\n+    }\n+  }\n+}\n+\n+//-----------------------------------------------\n+// üîπ WebSocket listener (react to network updates)\n+//-----------------------------------------------\n+function startWS() {\n+  const ws = new WebSocket(NODE_WS);\n+  ws.on('open', () => console.log('üîå Connected to node'));\n+  ws.on('message', buf => {\n+    try {\n+      const msg = JSON.parse(buf.toString());\n+      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n+        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n+        abortFlag = true;\n+      }\n+    } catch (e) {\n+      console.error('‚ö†Ô∏è WS parse error:', e.message);\n+    }\n+  });\n+  ws.on('close', () => {\n+    console.log('üîÑ WS closed ‚Üí reconnecting...');\n+    setTimeout(startWS, 3000);\n+  });\n+}\n+\n+//-----------------------------------------------\n+// üîπ Start miner\n+//-----------------------------------------------\n+console.log('üöÄ Full-featured Bitcoin-like miner started');\n+startWS();\n+mineLoop();\n"
                },
                {
                    "date": 1761990105820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-// miner.js - Full Bitcoin-like miner (Target-based PoW + Live Stats)\n+// miner.js - Bitcoin-like miner with UTXO tracking & halving\n //-----------------------------------------------------------\n const axios = require('axios');\n const crypto = require('crypto');\n const WebSocket = require('ws');\n@@ -9,353 +9,128 @@\n   console.error('Usage: node miner.js --address <ADDRESS>');\n   process.exit(1);\n }\n \n-// Node endpoints\n+//-----------------------------------------------\n+// üîß Node configuration\n+//-----------------------------------------------\n const NODE_HTTP = 'http://localhost:3000';\n const NODE_WS = 'ws://localhost:3000';\n const ADDRESS = argv.address;\n \n //-----------------------------------------------\n-// üîπ Hash & Target Utilities\n+// üîπ Hashing utilities\n //-----------------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n const sha256 = d => crypto.createHash('sha256').update(d).digest();\n \n-// Convert difficulty ‚Üí numeric PoW target\n+//-----------------------------------------------\n+// üîπ Target & Merkle\n+//-----------------------------------------------\n function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n+  const maxTarget = BigInt('0x' + 'f'.repeat(64));\n   return maxTarget / BigInt(difficulty);\n }\n \n-// Build Merkle root from transaction IDs\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n       const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate last if odd\n+      const right = layer[i + 1] || left;\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n   }\n   return layer[0].toString('hex');\n }\n \n-// Canonical block header hashing (deterministic)\n function headerHash(header) {\n   const data = [\n-    String(header.index), header.previousHash, String(header.timestamp),\n-    header.merkleRoot, String(header.nonce), String(header.difficulty)\n+    String(header.index),\n+    header.previousHash,\n+    String(header.timestamp),\n+    header.merkleRoot,\n+    String(header.nonce),\n+    String(header.difficulty)\n   ].join('|');\n   return sha256hex(data);\n }\n \n-async function rebuildUTXO() {\n-  const { data: chainData } = await axios.get(`${NODE_HTTP}/chain`);\n-  const chain = chainData.chain;\n+//-----------------------------------------------\n+// üîπ Global state\n+//-----------------------------------------------\n+let abortFlag = false;\n+let currentDiff = 1;\n+let totalMined = 0;\n+let blockTimes = [];\n+let hashrateWindow = [];\n+let UTXO = new Map(); // local UTXO snapshot\n \n+//-----------------------------------------------\n+// üîπ Rebuild UTXO from chain\n+//-----------------------------------------------\n+async function rebuildUTXOFromChain() {\n+  const { data } = await axios.get(`${NODE_HTTP}/chain`);\n+  const chain = data.chain;\n   UTXO.clear();\n-\n   for (const block of chain) {\n     for (const tx of block.transactions) {\n-      // remove spent inputs\n-      for (const inp of tx.inputs || [])\n+      for (const inp of (tx.inputs || []))\n         UTXO.delete(`${inp.txid}:${inp.index}`);\n-\n-      // add outputs\n       tx.outputs.forEach((o, i) => {\n         UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n       });\n     }\n   }\n-\n-  console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n+  console.log(`üîÅ UTXO rebuilt from chain: ${UTXO.size} entries`);\n }\n \n+//-----------------------------------------------\n+// üîπ Halving logic\n+//-----------------------------------------------\n function getBlockReward(height, config) {\n-  const interval = config.halvingInterval || Infinity; // ÿß⁄Øÿ± ŸÜÿ®ŸàÿØÿå ŸáÿßŸà€åŸÜ⁄Ø ÿ∫€åÿ±ŸÅÿπÿßŸÑ\n+  const interval = config.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n   const base = BigInt(config.blockSubsidy);\n-  const reward = base >> BigInt(halvings); // ÿ™ŸÇÿ≥€åŸÖ ÿ®ÿ± 2^halvings\n+  const reward = base >> BigInt(halvings);\n   return Number(reward > 0n ? reward : 0n);\n }\n \n-function calcFee(tx) {\n-  if (!tx.inputs || tx.inputs.length === 0) return 0; // coinbase\n-  let inSum = 0, outSum = 0;\n-  for (const inp of tx.inputs) {\n-    const key = `${inp.txid}:${inp.index}`;\n-    const u = UTXO.get(key);\n-    if (!u) return 0; // skip if unknown input\n-    inSum += u.amount;\n-  }\n-  for (const o of tx.outputs) outSum += o.amount;\n-  const fee = inSum - outSum;\n-  return Math.max(0, fee);\n-}\n-\n //-----------------------------------------------\n-// üîπ Global mining state\n+// üîπ Fee calculation like node\n //-----------------------------------------------\n-let abortFlag = false;\n-let totalMined = 0;\n-let currentDiff = 1;\n-let blockTimes = [];\n-let hashrateWindow = [];\n-let UTXO = new Map(); // local copy of unspent outputs\n-\n-//-----------------------------------------------\n-// üîπ Fetch block template from node\n-//-----------------------------------------------\n-async function buildTemplate() {\n-  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n-    axios.get(`${NODE_HTTP}/chain`),\n-    axios.get(`${NODE_HTTP}/mempool`),\n-    axios.get(`${NODE_HTTP}/config`)\n-  ]);\n-\n-  const chain = chainData.chain;\n-  const mempool = memData.mempool || [];\n-  currentDiff = conf.difficulty;\n-\n-  // üîπ Compute fees from real UTXO set\n+function calcFeesForBlockOrder(mempool, utxoSnapshot) {\n+  const temp = new Map(utxoSnapshot);\n   let fees = 0;\n-  for (const tx of mempool) fees += calcFee(tx);\n \n-  const subsidy = getBlockReward(index, conf);\n-  const reward = conf.blockSubsidy;\n-  const last = chain[chain.length - 1];\n-  const index = chain.length;\n-  const previousHash = last.hash;\n-  const timestamp = new Date().toISOString();\n+  for (const tx of mempool) {\n+    if (!tx.inputs || tx.inputs.length === 0) continue; // skip coinbase\n+    let inSum = 0, outSum = 0, ok = true;\n \n-  const coinbase = {\n-    id: sha256hex('coinbase' + Date.now()),\n-    inputs: [],\n-    outputs: [{ address: ADDRESS, amount: reward + fees }]\n-  };\n-\n-  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n-}\n-\n-//-----------------------------------------------\n-// üîπ Main mining loop (with target-based PoW)\n-//-----------------------------------------------\n-async function mineLoop() {\n-  await rebuildUTXO();\n-  while (true) {\n-    try {\n-      const tpl = await buildTemplate();\n-      const { index, previousHash, timestamp, txs, diff } = tpl;\n-      abortFlag = false;\n-\n-      const target = getTarget(diff);\n-      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n-\n-      let nonce = 0;\n-      let hash;\n-      const start = Date.now();\n-      let lastHashCheck = start;\n-      let hashesTried = 0;\n-\n-      while (!abortFlag) {\n-        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n-        const root = merkleRoot(block.transactions.map(tx => tx.id));\n-        const header = {\n-          index: block.index,\n-          previousHash: block.previousHash,\n-          timestamp: block.timestamp,\n-          merkleRoot: root,\n-          nonce: block.nonce,\n-          difficulty: block.difficulty\n-        };\n-        hash = headerHash(header);\n-        hashesTried++;\n-\n-        // Measure hashrate every 1M tries\n-        if (hashesTried % 1_000_000 === 0) {\n-          const now = Date.now();\n-          const elapsedSec = (now - lastHashCheck) / 1000;\n-          const hashrate = (1_000_000 / elapsedSec) / 1_000_000; // MH/s\n-          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n-          hashrateWindow.push(hashrate);\n-          if (hashrateWindow.length > 10) hashrateWindow.shift();\n-          lastHashCheck = now;\n-        }\n-\n-        // ‚úÖ Real Proof-of-Work check (numeric comparison)\n-        const hashInt = BigInt('0x' + hash);\n-        if (hashInt < target) {\n-          const took = (Date.now() - start) / 1000;\n-          block.hash = hash;\n-          totalMined++;\n-\n-          blockTimes.push(took);\n-          if (blockTimes.length > 10) blockTimes.shift();\n-\n-          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n-          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / hashrateWindow.length || 0;\n-\n-          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n-          console.log(`üìä Stats ‚Üí Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n-          console.log(`üî¢ hash = ${hash}`);\n-          console.log(`üéØ target = ${target.toString(16).slice(0, 16)}...`);\n-\n-          try {\n-            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n-            console.log('üì¶ Submitted:', res.data);\n-          } catch (e) {\n-            console.error('‚ùå Submit error:', e.response?.data || e.message);\n-          }\n-\n-          break; // break inner loop ‚Üí new template\n-        }\n-\n-        nonce++;\n-      }\n-    } catch (e) {\n-      console.error('‚ö†Ô∏è Miner error:', e.message);\n-      await new Promise(r => setTimeout(r, 2000));\n+    for (const inp of tx.inputs) {\n+      const u = temp.get(`${inp.txid}:${inp.index}`);\n+      if (!u) { ok = false; break; }\n+      inSum += u.amount;\n     }\n-  }\n-}\n+    if (!ok) continue;\n \n-//-----------------------------------------------\n-// üîπ WebSocket listener (react to network updates)\n-//-----------------------------------------------\n-function startWS() {\n-  const ws = new WebSocket(NODE_WS);\n-  ws.on('open', () => console.log('üîå Connected to node'));\n-  ws.on('message', buf => {\n-    try {\n-      const msg = JSON.parse(buf.toString());\n-      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n-        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n-        abortFlag = true;\n-      }\n-    } catch (e) {\n-      console.error('‚ö†Ô∏è WS parse error:', e.message);\n-    }\n-  });\n-  ws.on('close', () => {\n-    console.log('üîÑ WS closed ‚Üí reconnecting...');\n-    setTimeout(startWS, 3000);\n-  });\n-}\n+    for (const o of tx.outputs) outSum += o.amount;\n+    fees += (inSum - outSum);\n \n-//-----------------------------------------------\n-// üîπ Start miner\n-//-----------------------------------------------\n-console.log('üöÄ Full-featured Bitcoin-like miner started');\n-startWS();\n-mineLoop();\n-// miner.js - Full Bitcoin-like miner (Target-based PoW + Live Stats)\n-//-----------------------------------------------------------\n-const axios = require('axios');\n-const crypto = require('crypto');\n-const WebSocket = require('ws');\n-const argv = require('minimist')(process.argv.slice(2));\n-\n-if (!argv.address) {\n-  console.error('Usage: node miner.js --address <ADDRESS>');\n-  process.exit(1);\n-}\n-\n-// Node endpoints\n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n-const ADDRESS = argv.address;\n-\n-//-----------------------------------------------\n-// üîπ Hash & Target Utilities\n-//-----------------------------------------------\n-const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256 = d => crypto.createHash('sha256').update(d).digest();\n-\n-// Convert difficulty ‚Üí numeric PoW target\n-function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n-  return maxTarget / BigInt(difficulty);\n-}\n-\n-// Build Merkle root from transaction IDs\n-function merkleRoot(txids) {\n-  if (txids.length === 0) return sha256hex('');\n-  let layer = txids.map(x => Buffer.from(x, 'hex'));\n-  while (layer.length > 1) {\n-    const next = [];\n-    for (let i = 0; i < layer.length; i += 2) {\n-      const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate last if odd\n-      next.push(sha256(Buffer.concat([left, right])));\n-    }\n-    layer = next;\n+    // update temp UTXO like node\n+    for (const inp of tx.inputs) temp.delete(`${inp.txid}:${inp.index}`);\n+    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n-  return layer[0].toString('hex');\n-}\n \n-// Canonical block header hashing (deterministic)\n-function headerHash(header) {\n-  const data = [\n-    String(header.index), header.previousHash, String(header.timestamp),\n-    header.merkleRoot, String(header.nonce), String(header.difficulty)\n-  ].join('|');\n-  return sha256hex(data);\n+  return fees;\n }\n \n-async function rebuildUTXO() {\n-  const { data: chainData } = await axios.get(`${NODE_HTTP}/chain`);\n-  const chain = chainData.chain;\n-\n-  UTXO.clear();\n-\n-  for (const block of chain) {\n-    for (const tx of block.transactions) {\n-      // remove spent inputs\n-      for (const inp of tx.inputs || [])\n-        UTXO.delete(`${inp.txid}:${inp.index}`);\n-\n-      // add outputs\n-      tx.outputs.forEach((o, i) => {\n-        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n-      });\n-    }\n-  }\n-\n-  console.log(`üîÅ Rebuilt UTXO set from chain: ${UTXO.size} entries`);\n-}\n-\n-\n-function calcFee(tx) {\n-  if (!tx.inputs || tx.inputs.length === 0) return 0; // coinbase\n-  let inSum = 0, outSum = 0;\n-  for (const inp of tx.inputs) {\n-    const key = `${inp.txid}:${inp.index}`;\n-    const u = UTXO.get(key);\n-    if (!u) return 0; // skip if unknown input\n-    inSum += u.amount;\n-  }\n-  for (const o of tx.outputs) outSum += o.amount;\n-  const fee = inSum - outSum;\n-  return Math.max(0, fee);\n-}\n-\n //-----------------------------------------------\n-// üîπ Global mining state\n+// üîπ Build block template (like node)\n //-----------------------------------------------\n-let abortFlag = false;\n-let totalMined = 0;\n-let currentDiff = 1;\n-let blockTimes = [];\n-let hashrateWindow = [];\n-let UTXO = new Map(); // local copy of unspent outputs\n-\n-//-----------------------------------------------\n-// üîπ Fetch block template from node\n-//-----------------------------------------------\n async function buildTemplate() {\n   const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n     axios.get(`${NODE_HTTP}/chain`),\n     axios.get(`${NODE_HTTP}/mempool`),\n@@ -365,32 +140,37 @@\n   const chain = chainData.chain;\n   const mempool = memData.mempool || [];\n   currentDiff = conf.difficulty;\n \n-  // üîπ Compute fees from real UTXO set\n-  let fees = 0;\n-  for (const tx of mempool) fees += calcFee(tx);\n-\n-  const reward = conf.blockSubsidy;\n+  const index = chain.length;\n   const last = chain[chain.length - 1];\n-  const index = chain.length;\n   const previousHash = last.hash;\n   const timestamp = new Date().toISOString();\n \n+  // üßÆ Sync UTXO\n+  await rebuildUTXOFromChain();\n+\n+  // üí∞ Calculate fees exactly like node\n+  const fees = calcFeesForBlockOrder(mempool, UTXO);\n+\n+  // üéÅ Calculate block reward (with halving)\n+  const subsidy = getBlockReward(index, conf);\n+  const rewardTotal = subsidy + fees;\n+\n+  // ü™ô Coinbase transaction\n   const coinbase = {\n     id: sha256hex('coinbase' + Date.now()),\n     inputs: [],\n-    outputs: [{ address: ADDRESS, amount: reward + fees }]\n+    outputs: [{ address: ADDRESS, amount: rewardTotal }]\n   };\n \n   return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n }\n \n //-----------------------------------------------\n-// üîπ Main mining loop (with target-based PoW)\n+// üîπ Main mining loop (target-based PoW)\n //-----------------------------------------------\n async function mineLoop() {\n-  await rebuildUTXO();\n   while (true) {\n     try {\n       const tpl = await buildTemplate();\n       const { index, previousHash, timestamp, txs, diff } = tpl;\n@@ -401,62 +181,59 @@\n \n       let nonce = 0;\n       let hash;\n       const start = Date.now();\n-      let lastHashCheck = start;\n       let hashesTried = 0;\n+      let lastStat = start;\n \n       while (!abortFlag) {\n-        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n-        const root = merkleRoot(block.transactions.map(tx => tx.id));\n+        const root = merkleRoot(txs.map(tx => tx.id));\n         const header = {\n-          index: block.index,\n-          previousHash: block.previousHash,\n-          timestamp: block.timestamp,\n-          merkleRoot: root,\n-          nonce: block.nonce,\n-          difficulty: block.difficulty\n+          index, previousHash, timestamp,\n+          merkleRoot: root, nonce, difficulty: diff\n         };\n         hash = headerHash(header);\n         hashesTried++;\n \n-        // Measure hashrate every 1M tries\n+        // measure hashrate periodically\n         if (hashesTried % 1_000_000 === 0) {\n           const now = Date.now();\n-          const elapsedSec = (now - lastHashCheck) / 1000;\n-          const hashrate = (1_000_000 / elapsedSec) / 1_000_000; // MH/s\n+          const elapsed = (now - lastStat) / 1000;\n+          const hashrate = (1_000_000 / elapsed) / 1_000_000;\n           process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n           hashrateWindow.push(hashrate);\n           if (hashrateWindow.length > 10) hashrateWindow.shift();\n-          lastHashCheck = now;\n+          lastStat = now;\n         }\n \n-        // ‚úÖ Real Proof-of-Work check (numeric comparison)\n         const hashInt = BigInt('0x' + hash);\n         if (hashInt < target) {\n           const took = (Date.now() - start) / 1000;\n-          block.hash = hash;\n-          totalMined++;\n+          const avgTime = (blockTimes.reduce((a, b) => a + b, 0) + took) / (blockTimes.length + 1);\n+          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n \n           blockTimes.push(took);\n           if (blockTimes.length > 10) blockTimes.shift();\n \n-          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n-          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / hashrateWindow.length || 0;\n-\n           console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n-          console.log(`üìä Stats ‚Üí Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n-          console.log(`üî¢ hash = ${hash}`);\n-          console.log(`üéØ target = ${target.toString(16).slice(0, 16)}...`);\n+          console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n+          console.log(`üî¢ hash=${hash}`);\n+          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n \n+          const block = {\n+            index, previousHash, timestamp,\n+            transactions: txs, nonce, difficulty: diff, hash\n+          };\n+\n           try {\n             const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n             console.log('üì¶ Submitted:', res.data);\n           } catch (e) {\n             console.error('‚ùå Submit error:', e.response?.data || e.message);\n           }\n \n-          break; // break inner loop ‚Üí new template\n+          totalMined++;\n+          break; // restart mining with new template\n         }\n \n         nonce++;\n       }\n@@ -467,9 +244,9 @@\n   }\n }\n \n //-----------------------------------------------\n-// üîπ WebSocket listener (react to network updates)\n+// üîπ WebSocket: abort when network updates\n //-----------------------------------------------\n function startWS() {\n   const ws = new WebSocket(NODE_WS);\n   ws.on('open', () => console.log('üîå Connected to node'));\n@@ -490,9 +267,9 @@\n   });\n }\n \n //-----------------------------------------------\n-// üîπ Start miner\n+// üöÄ Start miner\n //-----------------------------------------------\n-console.log('üöÄ Full-featured Bitcoin-like miner started');\n+console.log('üöÄ Miner started | Real UTXO + Halving + Target-based PoW');\n startWS();\n mineLoop();\n"
                },
                {
                    "date": 1761991178997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n-// miner.js - Bitcoin-like miner with UTXO tracking & halving\n+// miner.js - Bitcoin-like miner (UTXO-aware + Halving + Numeric PoW)\n+\n //-----------------------------------------------------------\n const axios = require('axios');\n const crypto = require('crypto');\n const WebSocket = require('ws');\n@@ -9,44 +10,41 @@\n   console.error('Usage: node miner.js --address <ADDRESS>');\n   process.exit(1);\n }\n \n-//-----------------------------------------------\n-// üîß Node configuration\n-//-----------------------------------------------\n const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n-const ADDRESS = argv.address;\n+const NODE_WS   = 'ws://localhost:3000';\n+const ADDRESS   = argv.address;\n \n-//-----------------------------------------------\n-// üîπ Hashing utilities\n-//-----------------------------------------------\n+// ------------------------------------\n+// Hash utils (match server.js exactly)\n+// ------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256 = d => crypto.createHash('sha256').update(d).digest();\n+const sha256    = d => crypto.createHash('sha256').update(d).digest();\n \n-//-----------------------------------------------\n-// üîπ Target & Merkle\n-//-----------------------------------------------\n+// target = (2^256-1) / difficulty\n function getTarget(difficulty) {\n   const maxTarget = BigInt('0x' + 'f'.repeat(64));\n   return maxTarget / BigInt(difficulty);\n }\n \n+// Merkle over txids (binary concat) ‚Äî same as server.js\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n-      const left = layer[i];\n+      const left  = layer[i];\n       const right = layer[i + 1] || left;\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n   }\n   return layer[0].toString('hex');\n }\n \n+// Canonical header hash ‚Äî same fields/order as server.js\n function headerHash(header) {\n   const data = [\n     String(header.index),\n     header.previousHash,\n@@ -57,24 +55,20 @@\n   ].join('|');\n   return sha256hex(data);\n }\n \n-//-----------------------------------------------\n-// üîπ Global state\n-//-----------------------------------------------\n+// ------------------------\n+// Miner state\n+// ------------------------\n let abortFlag = false;\n-let currentDiff = 1;\n-let totalMined = 0;\n let blockTimes = [];\n let hashrateWindow = [];\n-let UTXO = new Map(); // local UTXO snapshot\n+let UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n \n-//-----------------------------------------------\n-// üîπ Rebuild UTXO from chain\n-//-----------------------------------------------\n-async function rebuildUTXOFromChain() {\n-  const { data } = await axios.get(`${NODE_HTTP}/chain`);\n-  const chain = data.chain;\n+// ------------------------------------\n+// UTXO snapshot from full chain\n+// ------------------------------------\n+async function rebuildUTXOFromChain(chain) {\n   UTXO.clear();\n   for (const block of chain) {\n     for (const tx of block.transactions) {\n       for (const inp of (tx.inputs || []))\n@@ -83,93 +77,109 @@\n         UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n       });\n     }\n   }\n-  console.log(`üîÅ UTXO rebuilt from chain: ${UTXO.size} entries`);\n }\n \n-//-----------------------------------------------\n-// üîπ Halving logic\n-//-----------------------------------------------\n-function getBlockReward(height, config) {\n-  const interval = config.halvingInterval || Infinity;\n+// ------------------------------------\n+// Halving (mirror of server.getBlockReward)\n+// ------------------------------------\n+function getBlockReward(height, conf) {\n+  const interval = conf.halvingInterval || Infinity;\n   const halvings = Math.floor(height / interval);\n-  const base = BigInt(config.blockSubsidy);\n-  const reward = base >> BigInt(halvings);\n-  return Number(reward > 0n ? reward : 0n);\n+  const base = Number(conf.blockSubsidy) || 0;\n+  const reward = Math.floor(base / Math.pow(2, halvings));\n+  return reward > 0 ? reward : 0;\n }\n \n-//-----------------------------------------------\n-// üîπ Fee calculation like node\n-//-----------------------------------------------\n-function calcFeesForBlockOrder(mempool, utxoSnapshot) {\n+// ----------------------------------------------------\n+// Filter mempool like node: accept only txs resolvable\n+// by current temp-UTXO (in order), and compute total fees\n+// ----------------------------------------------------\n+function selectTxsAndCalcFees(mempool, utxoSnapshot) {\n   const temp = new Map(utxoSnapshot);\n+  const accepted = [];\n   let fees = 0;\n \n   for (const tx of mempool) {\n-    if (!tx.inputs || tx.inputs.length === 0) continue; // skip coinbase\n+    // skip coinbase-style txs in mempool (shouldn't exist)\n+    if (!tx.inputs || tx.inputs.length === 0) continue;\n+\n     let inSum = 0, outSum = 0, ok = true;\n \n+    // resolve inputs from temp-UTXO\n     for (const inp of tx.inputs) {\n       const u = temp.get(`${inp.txid}:${inp.index}`);\n       if (!u) { ok = false; break; }\n-      inSum += u.amount;\n+      inSum += Number(u.amount) || 0;\n     }\n+    if (!ok) continue; // can't resolve ‚Üí skip tx\n+\n+    for (const o of tx.outputs) {\n+      const v = Number(o.amount);\n+      if (!Number.isSafeInteger(v) || v <= 0) { ok = false; break; }\n+      outSum += v;\n+    }\n     if (!ok) continue;\n \n-    for (const o of tx.outputs) outSum += o.amount;\n-    fees += (inSum - outSum);\n+    const fee = inSum - outSum;\n+    if (fee < 0) continue; // invalid economics\n \n-    // update temp UTXO like node\n+    // accept this tx; apply to temp (like node)\n+    accepted.push(tx);\n+    fees += fee;\n+\n     for (const inp of tx.inputs) temp.delete(`${inp.txid}:${inp.index}`);\n     tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n \n-  return fees;\n+  return { fees, acceptedTxs: accepted };\n }\n \n-//-----------------------------------------------\n-// üîπ Build block template (like node)\n-//-----------------------------------------------\n+// ------------------------------------\n+// Build block template aligned with server.js\n+// ------------------------------------\n async function buildTemplate() {\n   const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n     axios.get(`${NODE_HTTP}/chain`),\n     axios.get(`${NODE_HTTP}/mempool`),\n     axios.get(`${NODE_HTTP}/config`)\n   ]);\n \n-  const chain = chainData.chain;\n+  const chain   = chainData.chain || [];\n   const mempool = memData.mempool || [];\n-  currentDiff = conf.difficulty;\n-\n-  const index = chain.length;\n-  const last = chain[chain.length - 1];\n+  const index   = chain.length;\n+  const last    = chain[chain.length - 1];\n   const previousHash = last.hash;\n-  const timestamp = new Date().toISOString();\n+  const timestamp    = new Date().toISOString();\n+  const diff         = conf.difficulty;\n \n-  // üßÆ Sync UTXO\n-  await rebuildUTXOFromChain();\n+  // UTXO snapshot from chain\n+  await rebuildUTXOFromChain(chain);\n \n-  // üí∞ Calculate fees exactly like node\n-  const fees = calcFeesForBlockOrder(mempool, UTXO);\n+  // choose valid txs (like node) and compute fees\n+  const { fees, acceptedTxs } = selectTxsAndCalcFees(mempool, UTXO);\n \n-  // üéÅ Calculate block reward (with halving)\n-  const subsidy = getBlockReward(index, conf);\n-  const rewardTotal = subsidy + fees;\n+  // reward with halving + fees\n+  const subsidy     = getBlockReward(index, conf);\n+  const rewardTotal = subsidy + fees; // Number\n \n-  // ü™ô Coinbase transaction\n+  // coinbase first\n   const coinbase = {\n     id: sha256hex('coinbase' + Date.now()),\n     inputs: [],\n     outputs: [{ address: ADDRESS, amount: rewardTotal }]\n   };\n \n-  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n+  // final tx list for block\n+  const txs = [coinbase, ...acceptedTxs];\n+\n+  return { index, previousHash, timestamp, txs, diff };\n }\n \n-//-----------------------------------------------\n-// üîπ Main mining loop (target-based PoW)\n-//-----------------------------------------------\n+// ------------------------------------\n+// Mining loop (numeric PoW)\n+// ------------------------------------\n async function mineLoop() {\n   while (true) {\n     try {\n       const tpl = await buildTemplate();\n@@ -184,41 +194,37 @@\n       const start = Date.now();\n       let hashesTried = 0;\n       let lastStat = start;\n \n+      const txids = txs.map(tx => tx.id);\n+      const root  = merkleRoot(txids);\n+\n       while (!abortFlag) {\n-        const root = merkleRoot(txs.map(tx => tx.id));\n-        const header = {\n-          index, previousHash, timestamp,\n-          merkleRoot: root, nonce, difficulty: diff\n-        };\n+        const header = { index, previousHash, timestamp, merkleRoot: root, nonce, difficulty: diff };\n         hash = headerHash(header);\n         hashesTried++;\n \n-        // measure hashrate periodically\n+        // stats\n         if (hashesTried % 1_000_000 === 0) {\n           const now = Date.now();\n           const elapsed = (now - lastStat) / 1000;\n-          const hashrate = (1_000_000 / elapsed) / 1_000_000;\n-          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n-          hashrateWindow.push(hashrate);\n+          const mhps = (1_000_000 / elapsed) / 1_000_000;\n+          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${mhps.toFixed(2)} MH/s`);\n+          hashrateWindow.push(mhps);\n           if (hashrateWindow.length > 10) hashrateWindow.shift();\n           lastStat = now;\n         }\n \n-        const hashInt = BigInt('0x' + hash);\n-        if (hashInt < target) {\n+        if (BigInt('0x' + hash) < target) {\n           const took = (Date.now() - start) / 1000;\n-          const avgTime = (blockTimes.reduce((a, b) => a + b, 0) + took) / (blockTimes.length + 1);\n-          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n+          blockTimes.push(took); if (blockTimes.length > 10) blockTimes.shift();\n+          const avgTime = blockTimes.reduce((a,b)=>a+b,0)/blockTimes.length;\n+          const avgHashrate = hashrateWindow.reduce((a,b)=>a+b,0)/(hashrateWindow.length||1);\n \n-          blockTimes.push(took);\n-          if (blockTimes.length > 10) blockTimes.shift();\n-\n           console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n           console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n           console.log(`üî¢ hash=${hash}`);\n-          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n+          console.log(`üéØ target‚âà0x${target.toString(16).slice(0,16)}...`);\n \n           const block = {\n             index, previousHash, timestamp,\n             transactions: txs, nonce, difficulty: diff, hash\n@@ -229,47 +235,43 @@\n             console.log('üì¶ Submitted:', res.data);\n           } catch (e) {\n             console.error('‚ùå Submit error:', e.response?.data || e.message);\n           }\n-\n-          totalMined++;\n-          break; // restart mining with new template\n+          break; // rebuild a new template\n         }\n \n         nonce++;\n       }\n     } catch (e) {\n       console.error('‚ö†Ô∏è Miner error:', e.message);\n-      await new Promise(r => setTimeout(r, 2000));\n+      await new Promise(r => setTimeout(r, 1500));\n     }\n   }\n }\n \n-//-----------------------------------------------\n-// üîπ WebSocket: abort when network updates\n-//-----------------------------------------------\n+// ------------------------------------\n+// WS: abort on network updates\n+// ------------------------------------\n function startWS() {\n   const ws = new WebSocket(NODE_WS);\n   ws.on('open', () => console.log('üîå Connected to node'));\n   ws.on('message', buf => {\n     try {\n       const msg = JSON.parse(buf.toString());\n-      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n+      if (['new_block','mempool_tx','config_update'].includes(msg.type)) {\n         console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n         abortFlag = true;\n       }\n-    } catch (e) {\n-      console.error('‚ö†Ô∏è WS parse error:', e.message);\n-    }\n+    } catch {}\n   });\n   ws.on('close', () => {\n     console.log('üîÑ WS closed ‚Üí reconnecting...');\n     setTimeout(startWS, 3000);\n   });\n }\n \n-//-----------------------------------------------\n-// üöÄ Start miner\n-//-----------------------------------------------\n-console.log('üöÄ Miner started | Real UTXO + Halving + Target-based PoW');\n+// ------------------------------------\n+// Start miner\n+// ------------------------------------\n+console.log('üöÄ Miner started | UTXO-aware + Halving + Numeric PoW');\n startWS();\n mineLoop();\n"
                },
                {
                    "date": 1761991580442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,16 +11,16 @@\n   process.exit(1);\n }\n \n const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS   = 'ws://localhost:3000';\n-const ADDRESS   = argv.address;\n+const NODE_WS = 'ws://localhost:3000';\n+const ADDRESS = argv.address;\n \n // ------------------------------------\n // Hash utils (match server.js exactly)\n // ------------------------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256    = d => crypto.createHash('sha256').update(d).digest();\n+const sha256 = d => crypto.createHash('sha256').update(d).digest();\n \n // target = (2^256-1) / difficulty\n function getTarget(difficulty) {\n   const maxTarget = BigInt('0x' + 'f'.repeat(64));\n@@ -33,9 +33,9 @@\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n-      const left  = layer[i];\n+      const left = layer[i];\n       const right = layer[i + 1] || left;\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n@@ -144,24 +144,24 @@\n     axios.get(`${NODE_HTTP}/mempool`),\n     axios.get(`${NODE_HTTP}/config`)\n   ]);\n \n-  const chain   = chainData.chain || [];\n+  const chain = chainData.chain || [];\n   const mempool = memData.mempool || [];\n-  const index   = chain.length;\n-  const last    = chain[chain.length - 1];\n+  const index = chain.length;\n+  const last = chain[chain.length - 1];\n   const previousHash = last.hash;\n-  const timestamp    = new Date().toISOString();\n-  const diff         = conf.difficulty;\n+  const timestamp = new Date().toISOString();\n+  const diff = conf.difficulty;\n \n   // UTXO snapshot from chain\n   await rebuildUTXOFromChain(chain);\n \n   // choose valid txs (like node) and compute fees\n   const { fees, acceptedTxs } = selectTxsAndCalcFees(mempool, UTXO);\n \n   // reward with halving + fees\n-  const subsidy     = getBlockReward(index, conf);\n+  const subsidy = getBlockReward(index, conf);\n   const rewardTotal = subsidy + fees; // Number\n \n   // coinbase first\n   const coinbase = {\n@@ -195,9 +195,9 @@\n       let hashesTried = 0;\n       let lastStat = start;\n \n       const txids = txs.map(tx => tx.id);\n-      const root  = merkleRoot(txids);\n+      const root = merkleRoot(txids);\n \n       while (!abortFlag) {\n         const header = { index, previousHash, timestamp, merkleRoot: root, nonce, difficulty: diff };\n         hash = headerHash(header);\n@@ -216,15 +216,15 @@\n \n         if (BigInt('0x' + hash) < target) {\n           const took = (Date.now() - start) / 1000;\n           blockTimes.push(took); if (blockTimes.length > 10) blockTimes.shift();\n-          const avgTime = blockTimes.reduce((a,b)=>a+b,0)/blockTimes.length;\n-          const avgHashrate = hashrateWindow.reduce((a,b)=>a+b,0)/(hashrateWindow.length||1);\n+          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n+          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n \n           console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n           console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n           console.log(`üî¢ hash=${hash}`);\n-          console.log(`üéØ target‚âà0x${target.toString(16).slice(0,16)}...`);\n+          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n \n           const block = {\n             index, previousHash, timestamp,\n             transactions: txs, nonce, difficulty: diff, hash\n@@ -256,13 +256,13 @@\n   ws.on('open', () => console.log('üîå Connected to node'));\n   ws.on('message', buf => {\n     try {\n       const msg = JSON.parse(buf.toString());\n-      if (['new_block','mempool_tx','config_update'].includes(msg.type)) {\n+      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n         console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n         abortFlag = true;\n       }\n-    } catch {}\n+    } catch { }\n   });\n   ws.on('close', () => {\n     console.log('üîÑ WS closed ‚Üí reconnecting...');\n     setTimeout(startWS, 3000);\n"
                },
                {
                    "date": 1761991629881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,19 +158,25 @@\n \n   // choose valid txs (like node) and compute fees\n   const { fees, acceptedTxs } = selectTxsAndCalcFees(mempool, UTXO);\n \n-  // reward with halving + fees\n-  const subsidy = getBlockReward(index, conf);\n-  const rewardTotal = subsidy + fees; // Number\n+// reward with halving + fees (safe integer)\n+const subsidy = Number(getBlockReward(index, conf)) || 0;\n+const feeInt  = Number.isFinite(fees) ? Math.floor(fees) : 0;\n+const rewardTotal = Math.floor(subsidy + feeInt);\n \n-  // coinbase first\n-  const coinbase = {\n-    id: sha256hex('coinbase' + Date.now()),\n-    inputs: [],\n-    outputs: [{ address: ADDRESS, amount: rewardTotal }]\n-  };\n+if (!Number.isSafeInteger(rewardTotal) || rewardTotal <= 0) {\n+  console.warn(`‚ö†Ô∏è Invalid rewardTotal=${rewardTotal} ‚Äî resetting to subsidy`);\n+}\n \n+// coinbase tx\n+const coinbase = {\n+  id: sha256hex('coinbase' + Date.now()),\n+  inputs: [],\n+  outputs: [{ address: ADDRESS, amount: Math.max(subsidy, 1) }]\n+};\n+\n+\n   // final tx list for block\n   const txs = [coinbase, ...acceptedTxs];\n \n   return { index, previousHash, timestamp, txs, diff };\n"
                },
                {
                    "date": 1761991636285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,23 +158,23 @@\n \n   // choose valid txs (like node) and compute fees\n   const { fees, acceptedTxs } = selectTxsAndCalcFees(mempool, UTXO);\n \n-// reward with halving + fees (safe integer)\n-const subsidy = Number(getBlockReward(index, conf)) || 0;\n-const feeInt  = Number.isFinite(fees) ? Math.floor(fees) : 0;\n-const rewardTotal = Math.floor(subsidy + feeInt);\n+  // reward with halving + fees (safe integer)\n+  const subsidy = Number(getBlockReward(index, conf)) || 0;\n+  const feeInt = Number.isFinite(fees) ? Math.floor(fees) : 0;\n+  const rewardTotal = Math.floor(subsidy + feeInt);\n \n-if (!Number.isSafeInteger(rewardTotal) || rewardTotal <= 0) {\n-  console.warn(`‚ö†Ô∏è Invalid rewardTotal=${rewardTotal} ‚Äî resetting to subsidy`);\n-}\n+  if (!Number.isSafeInteger(rewardTotal) || rewardTotal <= 0) {\n+    console.warn(`‚ö†Ô∏è Invalid rewardTotal=${rewardTotal} ‚Äî resetting to subsidy`);\n+  }\n \n-// coinbase tx\n-const coinbase = {\n-  id: sha256hex('coinbase' + Date.now()),\n-  inputs: [],\n-  outputs: [{ address: ADDRESS, amount: Math.max(subsidy, 1) }]\n-};\n+  // coinbase tx\n+  const coinbase = {\n+    id: sha256hex('coinbase' + Date.now()),\n+    inputs: [],\n+    outputs: [{ address: ADDRESS, amount: Math.max(subsidy, 1) }]\n+  };\n \n \n   // final tx list for block\n   const txs = [coinbase, ...acceptedTxs];\n"
                },
                {
                    "date": 1761994920376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,9 +219,9 @@\n           if (hashrateWindow.length > 10) hashrateWindow.shift();\n           lastStat = now;\n         }\n \n-        if (BigInt('0x' + hash) < target) {\n+        if (hash.startsWith('0'.repeat(diff))) {\n           const took = (Date.now() - start) / 1000;\n           blockTimes.push(took); if (blockTimes.length > 10) blockTimes.shift();\n           const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n           const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n"
                },
                {
                    "date": 1761995395987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,283 +1,101 @@\n-// miner.js - Bitcoin-like miner (UTXO-aware + Halving + Numeric PoW)\n+// apps/miner/server.js\n+// Simple miner that requests block candidate from node and searches nonce\n+// Run: node apps/miner/server.js --address <ADDRESS>\n \n-//-----------------------------------------------------------\n const axios = require('axios');\n const crypto = require('crypto');\n const WebSocket = require('ws');\n+\n const argv = require('minimist')(process.argv.slice(2));\n-\n-if (!argv.address) {\n-  console.error('Usage: node miner.js --address <ADDRESS>');\n+const minerAddress = argv.address || argv.a;\n+if (!minerAddress) {\n+  console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n   process.exit(1);\n }\n \n const NODE_HTTP = 'http://localhost:3000';\n const NODE_WS = 'ws://localhost:3000';\n-const ADDRESS = argv.address;\n \n-// ------------------------------------\n-// Hash utils (match server.js exactly)\n-// ------------------------------------\n-const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256 = d => crypto.createHash('sha256').update(d).digest();\n-\n-// target = (2^256-1) / difficulty\n-function getTarget(difficulty) {\n-  const maxTarget = BigInt('0x' + 'f'.repeat(64));\n-  return maxTarget / BigInt(difficulty);\n+function sha256Hex(buf) {\n+  return crypto.createHash('sha256').update(buf).digest('hex');\n }\n \n-// Merkle over txids (binary concat) ‚Äî same as server.js\n-function merkleRoot(txids) {\n-  if (txids.length === 0) return sha256hex('');\n-  let layer = txids.map(x => Buffer.from(x, 'hex'));\n-  while (layer.length > 1) {\n-    const next = [];\n-    for (let i = 0; i < layer.length; i += 2) {\n-      const left = layer[i];\n-      const right = layer[i + 1] || left;\n-      next.push(sha256(Buffer.concat([left, right])));\n-    }\n-    layer = next;\n-  }\n-  return layer[0].toString('hex');\n+function headerHash(block) {\n+  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.difficulty}`;\n+  return sha256Hex(Buffer.from(header));\n }\n \n-// Canonical header hash ‚Äî same fields/order as server.js\n-function headerHash(header) {\n-  const data = [\n-    String(header.index),\n-    header.previousHash,\n-    String(header.timestamp),\n-    header.merkleRoot,\n-    String(header.nonce),\n-    String(header.difficulty)\n-  ].join('|');\n-  return sha256hex(data);\n+function hashMeetsDifficulty(hexHash, difficulty) {\n+  return hexHash.startsWith('0'.repeat(difficulty));\n }\n \n-// ------------------------\n-// Miner state\n-// ------------------------\n-let abortFlag = false;\n-let blockTimes = [];\n-let hashrateWindow = [];\n-let UTXO = new Map(); // key: \"txid:index\" -> { address, amount }\n-\n-// ------------------------------------\n-// UTXO snapshot from full chain\n-// ------------------------------------\n-async function rebuildUTXOFromChain(chain) {\n-  UTXO.clear();\n-  for (const block of chain) {\n-    for (const tx of block.transactions) {\n-      for (const inp of (tx.inputs || []))\n-        UTXO.delete(`${inp.txid}:${inp.index}`);\n-      tx.outputs.forEach((o, i) => {\n-        UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount });\n-      });\n-    }\n+async function main() {\n+  console.log('Miner starting. Miner address:', minerAddress);\n+  // connect ws for notifications\n+  try {\n+    const ws = new WebSocket(NODE_WS);\n+    ws.on('open', () => {\n+      console.log('WS connected to node');\n+    });\n+    ws.on('message', (m) => {\n+      const msg = JSON.parse(m.toString());\n+      if (msg.type === 'new_block') {\n+        console.log('Node broadcast: new block', msg.block.index);\n+      } else if (msg.type === 'mempool_tx') {\n+        // could reprioritize\n+      }\n+    });\n+  } catch(e) {\n+    console.warn('WS connect failed:', e.message);\n   }\n-}\n \n-// ------------------------------------\n-// Halving (mirror of server.getBlockReward)\n-// ------------------------------------\n-function getBlockReward(height, conf) {\n-  const interval = conf.halvingInterval || Infinity;\n-  const halvings = Math.floor(height / interval);\n-  const base = Number(conf.blockSubsidy) || 0;\n-  const reward = Math.floor(base / Math.pow(2, halvings));\n-  return reward > 0 ? reward : 0;\n-}\n-\n-// ----------------------------------------------------\n-// Filter mempool like node: accept only txs resolvable\n-// by current temp-UTXO (in order), and compute total fees\n-// ----------------------------------------------------\n-function selectTxsAndCalcFees(mempool, utxoSnapshot) {\n-  const temp = new Map(utxoSnapshot);\n-  const accepted = [];\n-  let fees = 0;\n-\n-  for (const tx of mempool) {\n-    // skip coinbase-style txs in mempool (shouldn't exist)\n-    if (!tx.inputs || tx.inputs.length === 0) continue;\n-\n-    let inSum = 0, outSum = 0, ok = true;\n-\n-    // resolve inputs from temp-UTXO\n-    for (const inp of tx.inputs) {\n-      const u = temp.get(`${inp.txid}:${inp.index}`);\n-      if (!u) { ok = false; break; }\n-      inSum += Number(u.amount) || 0;\n-    }\n-    if (!ok) continue; // can't resolve ‚Üí skip tx\n-\n-    for (const o of tx.outputs) {\n-      const v = Number(o.amount);\n-      if (!Number.isSafeInteger(v) || v <= 0) { ok = false; break; }\n-      outSum += v;\n-    }\n-    if (!ok) continue;\n-\n-    const fee = inSum - outSum;\n-    if (fee < 0) continue; // invalid economics\n-\n-    // accept this tx; apply to temp (like node)\n-    accepted.push(tx);\n-    fees += fee;\n-\n-    for (const inp of tx.inputs) temp.delete(`${inp.txid}:${inp.index}`);\n-    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n-  }\n-\n-  return { fees, acceptedTxs: accepted };\n-}\n-\n-// ------------------------------------\n-// Build block template aligned with server.js\n-// ------------------------------------\n-async function buildTemplate() {\n-  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n-    axios.get(`${NODE_HTTP}/chain`),\n-    axios.get(`${NODE_HTTP}/mempool`),\n-    axios.get(`${NODE_HTTP}/config`)\n-  ]);\n-\n-  const chain = chainData.chain || [];\n-  const mempool = memData.mempool || [];\n-  const index = chain.length;\n-  const last = chain[chain.length - 1];\n-  const previousHash = last.hash;\n-  const timestamp = new Date().toISOString();\n-  const diff = conf.difficulty;\n-\n-  // UTXO snapshot from chain\n-  await rebuildUTXOFromChain(chain);\n-\n-  // choose valid txs (like node) and compute fees\n-  const { fees, acceptedTxs } = selectTxsAndCalcFees(mempool, UTXO);\n-\n-  // reward with halving + fees (safe integer)\n-  const subsidy = Number(getBlockReward(index, conf)) || 0;\n-  const feeInt = Number.isFinite(fees) ? Math.floor(fees) : 0;\n-  const rewardTotal = Math.floor(subsidy + feeInt);\n-\n-  if (!Number.isSafeInteger(rewardTotal) || rewardTotal <= 0) {\n-    console.warn(`‚ö†Ô∏è Invalid rewardTotal=${rewardTotal} ‚Äî resetting to subsidy`);\n-  }\n-\n-  // coinbase tx\n-  const coinbase = {\n-    id: sha256hex('coinbase' + Date.now()),\n-    inputs: [],\n-    outputs: [{ address: ADDRESS, amount: Math.max(subsidy, 1) }]\n-  };\n-\n-\n-  // final tx list for block\n-  const txs = [coinbase, ...acceptedTxs];\n-\n-  return { index, previousHash, timestamp, txs, diff };\n-}\n-\n-// ------------------------------------\n-// Mining loop (numeric PoW)\n-// ------------------------------------\n-async function mineLoop() {\n   while (true) {\n     try {\n-      const tpl = await buildTemplate();\n-      const { index, previousHash, timestamp, txs, diff } = tpl;\n-      abortFlag = false;\n-\n-      const target = getTarget(diff);\n-      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n-\n+      // request a block candidate\n+      const r = await axios.get(`${NODE_HTTP}/block/candidate/${minerAddress}`);\n+      let block = r.data;\n+      // mining loop: iterate nonces\n+      const startTs = Date.now();\n       let nonce = 0;\n-      let hash;\n-      const start = Date.now();\n-      let hashesTried = 0;\n-      let lastStat = start;\n-\n-      const txids = txs.map(tx => tx.id);\n-      const root = merkleRoot(txids);\n-\n-      while (!abortFlag) {\n-        const header = { index, previousHash, timestamp, merkleRoot: root, nonce, difficulty: diff };\n-        hash = headerHash(header);\n-        hashesTried++;\n-\n-        // stats\n-        if (hashesTried % 1_000_000 === 0) {\n-          const now = Date.now();\n-          const elapsed = (now - lastStat) / 1000;\n-          const mhps = (1_000_000 / elapsed) / 1_000_000;\n-          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${mhps.toFixed(2)} MH/s`);\n-          hashrateWindow.push(mhps);\n-          if (hashrateWindow.length > 10) hashrateWindow.shift();\n-          lastStat = now;\n-        }\n-\n-        if (hash.startsWith('0'.repeat(diff))) {\n-          const took = (Date.now() - start) / 1000;\n-          blockTimes.push(took); if (blockTimes.length > 10) blockTimes.shift();\n-          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n-          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / (hashrateWindow.length || 1);\n-\n-          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n-          console.log(`üìä Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n-          console.log(`üî¢ hash=${hash}`);\n-          console.log(`üéØ target‚âà0x${target.toString(16).slice(0, 16)}...`);\n-\n-          const block = {\n-            index, previousHash, timestamp,\n-            transactions: txs, nonce, difficulty: diff, hash\n-          };\n-\n-          try {\n-            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n-            console.log('üì¶ Submitted:', res.data);\n-          } catch (e) {\n-            console.error('‚ùå Submit error:', e.response?.data || e.message);\n+      let found = false;\n+      // we will try in batches then re-fetch candidate periodically to avoid wasted work\n+      while (!found) {\n+        // try a batch of nonces\n+        for (let i = 0; i < 5000; i++) {\n+          block.nonce = nonce++;\n+          block.timestamp = Date.now(); // allow timestamp change\n+          block.hash = headerHash(block);\n+          if (hashMeetsDifficulty(block.hash, block.difficulty)) {\n+            found = true;\n+            break;\n           }\n-          break; // rebuild a new template\n         }\n-\n-        nonce++;\n+        if (found) break;\n+        // small sleep to avoid pegging CPU fully and give chance to node updates\n+        await new Promise(r => setTimeout(r, 10));\n+        // occasionally refresh candidate (if new block added)\n+        const now = Date.now();\n+        if ((now - startTs) > 2000) {\n+          // refresh candidate to pick new mempool/chain tip\n+          break;\n+        }\n       }\n+      if (!found) continue;\n+      console.log(`Mined block! index=${block.index} nonce=${block.nonce} hash=${block.hash}`);\n+      // submit to node\n+      try {\n+        const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n+        console.log('Node accepted block:', res.data);\n+      } catch (e) {\n+        console.error('Node rejected block:', e.response ? e.response.data : e.message);\n+      }\n+      // after success small wait\n+      await new Promise(r => setTimeout(r, 200));\n     } catch (e) {\n-      console.error('‚ö†Ô∏è Miner error:', e.message);\n-      await new Promise(r => setTimeout(r, 1500));\n+      console.error('Miner error:', e.message);\n+      await new Promise(r => setTimeout(r, 1000));\n     }\n   }\n }\n \n-// ------------------------------------\n-// WS: abort on network updates\n-// ------------------------------------\n-function startWS() {\n-  const ws = new WebSocket(NODE_WS);\n-  ws.on('open', () => console.log('üîå Connected to node'));\n-  ws.on('message', buf => {\n-    try {\n-      const msg = JSON.parse(buf.toString());\n-      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n-        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n-        abortFlag = true;\n-      }\n-    } catch { }\n-  });\n-  ws.on('close', () => {\n-    console.log('üîÑ WS closed ‚Üí reconnecting...');\n-    setTimeout(startWS, 3000);\n-  });\n-}\n-\n-// ------------------------------------\n-// Start miner\n-// ------------------------------------\n-console.log('üöÄ Miner started | UTXO-aware + Halving + Numeric PoW');\n-startWS();\n-mineLoop();\n+main();\n"
                },
                {
                    "date": 1761996729424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,101 +1,91 @@\n // apps/miner/server.js\n-// Simple miner that requests block candidate from node and searches nonce\n-// Run: node apps/miner/server.js --address <ADDRESS>\n+// PoW miner with compact target bits & polite CPU usage + logs\n+// Run: node apps/miner/server.js --address <ADDRESS> [--node http://host:3000]\n \n const axios = require('axios');\n const crypto = require('crypto');\n const WebSocket = require('ws');\n+const argv = require('minimist')(process.argv.slice(2));\n \n-const argv = require('minimist')(process.argv.slice(2));\n const minerAddress = argv.address || argv.a;\n if (!minerAddress) {\n-  console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n+  console.error('Usage: node apps/miner/server.js --address <ADDRESS> [--node http://localhost:3000]');\n   process.exit(1);\n }\n+const NODE = argv.node || 'http://localhost:3000';\n+const NODE_WS = 'ws://' + NODE.replace(/^https?:\\/\\//,'').replace(/\\/$/,'');\n \n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n+const log = (...a)=>console.log('[MINER]',...a);\n \n-function sha256Hex(buf) {\n-  return crypto.createHash('sha256').update(buf).digest('hex');\n-}\n+const sha256Hex = (b)=> crypto.createHash('sha256').update(b).digest('hex');\n+const headerHash = (block) => sha256Hex(Buffer.from(`${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`));\n+const bitsToTarget = (bits)=>{\n+  const exp = (bits>>>24)&0xff;\n+  let mant = BigInt(bits & 0x007fffff);\n+  if (bits & 0x00800000) mant = mant | (1n<<23n);\n+  const shift = BigInt(8*(exp-3));\n+  return mant << shift;\n+};\n \n-function headerHash(block) {\n-  const header = `${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.difficulty}`;\n-  return sha256Hex(Buffer.from(header));\n+function meets(hexHash, bits) {\n+  return BigInt('0x'+hexHash) <= bitsToTarget(bits);\n }\n \n-function hashMeetsDifficulty(hexHash, difficulty) {\n-  return hexHash.startsWith('0'.repeat(difficulty));\n+async function mineOnce() {\n+  const { data: cand } = await axios.get(`${NODE}/block/candidate/${minerAddress}`);\n+  let block = cand;\n+  const target = bitsToTarget(block.bits);\n+  const start = Date.now();\n+  let nonce = 0;\n+  let iter = 0;\n+\n+  while (true) {\n+    for (let i=0;i<5000;i++) {\n+      block.nonce = nonce++;\n+      block.timestamp = Date.now();\n+      block.hash = headerHash(block);\n+      iter++;\n+      if (BigInt('0x'+block.hash) <= target) {\n+        log(`FOUND index=${block.index} nonce=${block.nonce} hash=${block.hash.slice(0,16)}‚Ä¶ bits=${block.bits.toString(16)} iters=${iter} ${(Date.now()-start)}ms`);\n+        return block;\n+      }\n+    }\n+    // give CPU a breath & allow new tip/candidate\n+    await new Promise(r=>setTimeout(r,10));\n+    if (Date.now()-start > 2500) return null; // refresh candidate periodically\n+  }\n }\n \n-async function main() {\n-  console.log('Miner starting. Miner address:', minerAddress);\n-  // connect ws for notifications\n+(async ()=>{\n+  log('connecting WS', NODE_WS);\n   try {\n     const ws = new WebSocket(NODE_WS);\n-    ws.on('open', () => {\n-      console.log('WS connected to node');\n+    ws.on('open', ()=> log('WS connected'));\n+    ws.on('message', (m)=> {\n+      try {\n+        const msg = JSON.parse(m.toString());\n+        if (msg.type === 'new_block') {\n+          log(`tip advanced -> #${msg.block.index}`);\n+        }\n+      } catch {}\n     });\n-    ws.on('message', (m) => {\n-      const msg = JSON.parse(m.toString());\n-      if (msg.type === 'new_block') {\n-        console.log('Node broadcast: new block', msg.block.index);\n-      } else if (msg.type === 'mempool_tx') {\n-        // could reprioritize\n-      }\n-    });\n-  } catch(e) {\n-    console.warn('WS connect failed:', e.message);\n-  }\n+  } catch {}\n \n   while (true) {\n     try {\n-      // request a block candidate\n-      const r = await axios.get(`${NODE_HTTP}/block/candidate/${minerAddress}`);\n-      let block = r.data;\n-      // mining loop: iterate nonces\n-      const startTs = Date.now();\n-      let nonce = 0;\n-      let found = false;\n-      // we will try in batches then re-fetch candidate periodically to avoid wasted work\n-      while (!found) {\n-        // try a batch of nonces\n-        for (let i = 0; i < 5000; i++) {\n-          block.nonce = nonce++;\n-          block.timestamp = Date.now(); // allow timestamp change\n-          block.hash = headerHash(block);\n-          if (hashMeetsDifficulty(block.hash, block.difficulty)) {\n-            found = true;\n-            break;\n-          }\n+      const b = await mineOnce();\n+      if (b) {\n+        try {\n+          const res = await axios.post(`${NODE}/blocks`, b);\n+          log('submit ->', res.data);\n+        } catch(e) {\n+          log('submit rejected:', e.response ? e.response.data : e.message);\n         }\n-        if (found) break;\n-        // small sleep to avoid pegging CPU fully and give chance to node updates\n-        await new Promise(r => setTimeout(r, 10));\n-        // occasionally refresh candidate (if new block added)\n-        const now = Date.now();\n-        if ((now - startTs) > 2000) {\n-          // refresh candidate to pick new mempool/chain tip\n-          break;\n-        }\n+        await new Promise(r=>setTimeout(r,200));\n       }\n-      if (!found) continue;\n-      console.log(`Mined block! index=${block.index} nonce=${block.nonce} hash=${block.hash}`);\n-      // submit to node\n-      try {\n-        const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n-        console.log('Node accepted block:', res.data);\n-      } catch (e) {\n-        console.error('Node rejected block:', e.response ? e.response.data : e.message);\n-      }\n-      // after success small wait\n-      await new Promise(r => setTimeout(r, 200));\n-    } catch (e) {\n-      console.error('Miner error:', e.message);\n-      await new Promise(r => setTimeout(r, 1000));\n+    } catch(e) {\n+      log('miner error:', e.message);\n+      await new Promise(r=>setTimeout(r,1000));\n     }\n   }\n-}\n-\n-main();\n+})();\n"
                },
                {
                    "date": 1762000064937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,25 +11,25 @@\n if (!minerAddress) {\n   console.error('Usage: node apps/miner/server.js --address <ADDRESS> [--node http://localhost:3000]');\n   process.exit(1);\n }\n-const NODE = argv.node || 'http://localhost:3000';\n-const NODE_WS = 'ws://' + NODE.replace(/^https?:\\/\\//,'').replace(/\\/$/,'');\n+const NODE = process.env.NODE || 'http://localhost:3000';\n+const NODE_WS = 'ws://' + NODE.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n \n-const log = (...a)=>console.log('[MINER]',...a);\n+const log = (...a) => console.log('[MINER]', ...a);\n \n-const sha256Hex = (b)=> crypto.createHash('sha256').update(b).digest('hex');\n+const sha256Hex = (b) => crypto.createHash('sha256').update(b).digest('hex');\n const headerHash = (block) => sha256Hex(Buffer.from(`${block.index}|${block.previousHash}|${block.timestamp}|${block.merkleRoot}|${block.nonce}|${block.bits}`));\n-const bitsToTarget = (bits)=>{\n-  const exp = (bits>>>24)&0xff;\n+const bitsToTarget = (bits) => {\n+  const exp = (bits >>> 24) & 0xff;\n   let mant = BigInt(bits & 0x007fffff);\n-  if (bits & 0x00800000) mant = mant | (1n<<23n);\n-  const shift = BigInt(8*(exp-3));\n+  if (bits & 0x00800000) mant = mant | (1n << 23n);\n+  const shift = BigInt(8 * (exp - 3));\n   return mant << shift;\n };\n \n function meets(hexHash, bits) {\n-  return BigInt('0x'+hexHash) <= bitsToTarget(bits);\n+  return BigInt('0x' + hexHash) <= bitsToTarget(bits);\n }\n \n async function mineOnce() {\n   const { data: cand } = await axios.get(`${NODE}/block/candidate/${minerAddress}`);\n@@ -39,53 +39,53 @@\n   let nonce = 0;\n   let iter = 0;\n \n   while (true) {\n-    for (let i=0;i<5000;i++) {\n+    for (let i = 0; i < 5000; i++) {\n       block.nonce = nonce++;\n       block.timestamp = Date.now();\n       block.hash = headerHash(block);\n       iter++;\n-      if (BigInt('0x'+block.hash) <= target) {\n-        log(`FOUND index=${block.index} nonce=${block.nonce} hash=${block.hash.slice(0,16)}‚Ä¶ bits=${block.bits.toString(16)} iters=${iter} ${(Date.now()-start)}ms`);\n+      if (BigInt('0x' + block.hash) <= target) {\n+        log(`FOUND index=${block.index} nonce=${block.nonce} hash=${block.hash.slice(0, 16)}‚Ä¶ bits=${block.bits.toString(16)} iters=${iter} ${(Date.now() - start)}ms`);\n         return block;\n       }\n     }\n     // give CPU a breath & allow new tip/candidate\n-    await new Promise(r=>setTimeout(r,10));\n-    if (Date.now()-start > 2500) return null; // refresh candidate periodically\n+    await new Promise(r => setTimeout(r, 10));\n+    if (Date.now() - start > 2500) return null; // refresh candidate periodically\n   }\n }\n \n-(async ()=>{\n+(async () => {\n   log('connecting WS', NODE_WS);\n   try {\n     const ws = new WebSocket(NODE_WS);\n-    ws.on('open', ()=> log('WS connected'));\n-    ws.on('message', (m)=> {\n+    ws.on('open', () => log('WS connected'));\n+    ws.on('message', (m) => {\n       try {\n         const msg = JSON.parse(m.toString());\n         if (msg.type === 'new_block') {\n           log(`tip advanced -> #${msg.block.index}`);\n         }\n-      } catch {}\n+      } catch { }\n     });\n-  } catch {}\n+  } catch { }\n \n   while (true) {\n     try {\n       const b = await mineOnce();\n       if (b) {\n         try {\n           const res = await axios.post(`${NODE}/blocks`, b);\n           log('submit ->', res.data);\n-        } catch(e) {\n+        } catch (e) {\n           log('submit rejected:', e.response ? e.response.data : e.message);\n         }\n-        await new Promise(r=>setTimeout(r,200));\n+        await new Promise(r => setTimeout(r, 200));\n       }\n-    } catch(e) {\n+    } catch (e) {\n       log('miner error:', e.message);\n-      await new Promise(r=>setTimeout(r,1000));\n+      await new Promise(r => setTimeout(r, 1000));\n     }\n   }\n })();\n"
                },
                {
                    "date": 1762000238283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,20 +1,20 @@\n // apps/miner/server.js\n // PoW miner with compact target bits & polite CPU usage + logs\n-// Run: node apps/miner/server.js --address <ADDRESS> [--node http://host:3000]\n+// Run: node apps/miner/server.js --address <ADDRESS>\n \n const axios = require('axios');\n const crypto = require('crypto');\n const WebSocket = require('ws');\n const argv = require('minimist')(process.argv.slice(2));\n \n const minerAddress = argv.address || argv.a;\n if (!minerAddress) {\n-  console.error('Usage: node apps/miner/server.js --address <ADDRESS> [--node http://localhost:3000]');\n+  console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n   process.exit(1);\n }\n-const NODE = process.env.NODE || 'http://localhost:3000';\n-const NODE_WS = 'ws://' + NODE.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n+const NODE_URL = process.env.NODE_URL || 'http://localhost:3000';\n+const NODE_WS = 'ws://' + NODE_URL.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n \n const log = (...a) => console.log('[MINER]', ...a);\n \n const sha256Hex = (b) => crypto.createHash('sha256').update(b).digest('hex');\n@@ -31,9 +31,9 @@\n   return BigInt('0x' + hexHash) <= bitsToTarget(bits);\n }\n \n async function mineOnce() {\n-  const { data: cand } = await axios.get(`${NODE}/block/candidate/${minerAddress}`);\n+  const { data: cand } = await axios.get(`${NODE_URL}/block/candidate/${minerAddress}`);\n   let block = cand;\n   const target = bitsToTarget(block.bits);\n   const start = Date.now();\n   let nonce = 0;\n@@ -75,9 +75,9 @@\n     try {\n       const b = await mineOnce();\n       if (b) {\n         try {\n-          const res = await axios.post(`${NODE}/blocks`, b);\n+          const res = await axios.post(`${NODE_URL}/blocks`, b);\n           log('submit ->', res.data);\n         } catch (e) {\n           log('submit rejected:', e.response ? e.response.data : e.message);\n         }\n"
                },
                {
                    "date": 1762000502255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n if (!minerAddress) {\n   console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n   process.exit(1);\n }\n-const NODE_URL = process.env.NODE_URL || 'http://localhost:3000';\n+const NODE_URL = process.env.NODE_URL;\n const NODE_WS = 'ws://' + NODE_URL.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n \n const log = (...a) => console.log('[MINER]', ...a);\n \n"
                },
                {
                    "date": 1762002844729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n   process.exit(1);\n }\n const NODE_URL = process.env.NODE_URL;\n-const NODE_WS = 'ws://' + NODE_URL.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n+const NODE_WS = process.env.WS_URL;\n \n const log = (...a) => console.log('[MINER]', ...a);\n \n const sha256Hex = (b) => crypto.createHash('sha256').update(b).digest('hex');\n"
                },
                {
                    "date": 1762002852408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   console.error('Usage: node apps/miner/server.js --address <ADDRESS>');\n   process.exit(1);\n }\n const NODE_URL = process.env.NODE_URL;\n-const NODE_WS = process.env.WS_URL;\n+const NODE_WS = process.env.NODE_WS;\n \n const log = (...a) => console.log('[MINER]', ...a);\n \n const sha256Hex = (b) => crypto.createHash('sha256').update(b).digest('hex');\n"
                }
            ],
            "date": 1761988261380,
            "name": "Commit-0",
            "content": "// miner.js - Full Bitcoin-like miner (Target-based PoW + Live Stats)\n//-----------------------------------------------------------\nconst axios = require('axios');\nconst crypto = require('crypto');\nconst WebSocket = require('ws');\nconst argv = require('minimist')(process.argv.slice(2));\n\nif (!argv.address) {\n  console.error('Usage: node miner.js --address <ADDRESS>');\n  process.exit(1);\n}\n\n// Node endpoints\nconst NODE_HTTP = 'http://localhost:3000';\nconst NODE_WS = 'ws://localhost:3000';\nconst ADDRESS = argv.address;\n\n//-----------------------------------------------\n// üîπ Hash & Target Utilities\n//-----------------------------------------------\nconst sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n\nfunction blockHash(b) {\n  return sha256hex(\n    b.index +\n    b.previousHash +\n    b.timestamp +\n    JSON.stringify(b.transactions) +\n    b.nonce +\n    b.difficulty\n  );\n}\n\n// Convert difficulty ‚Üí numeric PoW target\nfunction getTarget(difficulty) {\n  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n  return maxTarget / BigInt(difficulty);\n}\n\n// Build Merkle root from transaction IDs\nfunction merkleRoot(txids) {\n  if (txids.length === 0) return sha256hex('');\n  let layer = txids.map(x => Buffer.from(x, 'hex'));\n  while (layer.length > 1) {\n    const next = [];\n    for (let i = 0; i < layer.length; i += 2) {\n      const left = layer[i];\n      const right = layer[i + 1] || left; // duplicate last if odd\n      next.push(sha256(Buffer.concat([left, right])));\n    }\n    layer = next;\n  }\n  return layer[0].toString('hex');\n}\n\n//-----------------------------------------------\n// üîπ Global mining state\n//-----------------------------------------------\nlet abortFlag = false;\nlet totalMined = 0;\nlet currentDiff = 1;\nlet blockTimes = [];\nlet hashrateWindow = [];\n\n//-----------------------------------------------\n// üîπ Fetch block template from node\n//-----------------------------------------------\nasync function buildTemplate() {\n  const [{ data: chainData }, { data: memData }, { data: conf }] = await Promise.all([\n    axios.get(`${NODE_HTTP}/chain`),\n    axios.get(`${NODE_HTTP}/mempool`),\n    axios.get(`${NODE_HTTP}/config`)\n  ]);\n\n  const chain = chainData.chain;\n  const mempool = memData.mempool || [];\n  currentDiff = conf.difficulty;\n\n  const reward = conf.blockSubsidy;\n  const fees = mempool.reduce((a, t) => a + (t.fee || 0), 0);\n  const last = chain[chain.length - 1];\n  const index = chain.length;\n  const previousHash = last.hash;\n  const timestamp = new Date().toISOString();\n\n  const coinbase = {\n    id: sha256hex('coinbase' + Date.now()),\n    inputs: [],\n    outputs: [{ address: ADDRESS, amount: reward + fees }]\n  };\n\n  return { index, previousHash, timestamp, txs: [coinbase, ...mempool], diff: conf.difficulty };\n}\n\n//-----------------------------------------------\n// üîπ Main mining loop (with target-based PoW)\n//-----------------------------------------------\nasync function mineLoop() {\n  while (true) {\n    try {\n      const tpl = await buildTemplate();\n      const { index, previousHash, timestamp, txs, diff } = tpl;\n      abortFlag = false;\n\n      const target = getTarget(diff);\n      console.log(`\\n‚õèÔ∏è  Mining block #${index} | diff=${diff} | txs=${txs.length}`);\n\n      let nonce = 0;\n      let hash;\n      const start = Date.now();\n      let lastHashCheck = start;\n      let hashesTried = 0;\n\n      while (!abortFlag) {\n        const block = { index, previousHash, timestamp, transactions: txs, nonce, difficulty: diff };\n        hash = blockHash(block);\n        hashesTried++;\n\n        // Measure hashrate every 1M tries\n        if (hashesTried % 1_000_000 === 0) {\n          const now = Date.now();\n          const elapsedSec = (now - lastHashCheck) / 1000;\n          const hashrate = (1_000_000 / elapsedSec) / 1_000_000; // MH/s\n          process.stdout.write(`\\r‚öôÔ∏è  Hashrate ‚âà ${hashrate.toFixed(2)} MH/s`);\n          hashrateWindow.push(hashrate);\n          if (hashrateWindow.length > 10) hashrateWindow.shift();\n          lastHashCheck = now;\n        }\n\n        // ‚úÖ Real Proof-of-Work check (numeric comparison)\n        const hashInt = BigInt('0x' + hash);\n        if (hashInt < target) {\n          const took = (Date.now() - start) / 1000;\n          block.hash = hash;\n          totalMined++;\n\n          blockTimes.push(took);\n          if (blockTimes.length > 10) blockTimes.shift();\n\n          const avgTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;\n          const avgHashrate = hashrateWindow.reduce((a, b) => a + b, 0) / hashrateWindow.length || 0;\n\n          console.log(`\\n‚úÖ Block mined #${index} | time=${took.toFixed(2)}s`);\n          console.log(`üìä Stats ‚Üí Avg block time: ${avgTime.toFixed(2)}s | Avg Hashrate: ${avgHashrate.toFixed(2)} MH/s`);\n          console.log(`üî¢ hash = ${hash}`);\n          console.log(`üéØ target = ${target.toString(16).slice(0, 16)}...`);\n\n          try {\n            const res = await axios.post(`${NODE_HTTP}/blocks`, block);\n            console.log('üì¶ Submitted:', res.data);\n          } catch (e) {\n            console.error('‚ùå Submit error:', e.response?.data || e.message);\n          }\n\n          break; // break inner loop ‚Üí new template\n        }\n\n        nonce++;\n      }\n    } catch (e) {\n      console.error('‚ö†Ô∏è Miner error:', e.message);\n      await new Promise(r => setTimeout(r, 2000));\n    }\n  }\n}\n\n//-----------------------------------------------\n// üîπ WebSocket listener (react to network updates)\n//-----------------------------------------------\nfunction startWS() {\n  const ws = new WebSocket(NODE_WS);\n  ws.on('open', () => console.log('üîå Connected to node'));\n  ws.on('message', buf => {\n    try {\n      const msg = JSON.parse(buf.toString());\n      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n        console.log(`‚ö° ${msg.type} ‚Üí abort current mining`);\n        abortFlag = true;\n      }\n    } catch (e) {\n      console.error('‚ö†Ô∏è WS parse error:', e.message);\n    }\n  });\n  ws.on('close', () => {\n    console.log('üîÑ WS closed ‚Üí reconnecting...');\n    setTimeout(startWS, 3000);\n  });\n}\n\n//-----------------------------------------------\n// üîπ Start miner\n//-----------------------------------------------\nconsole.log('üöÄ Full-featured Bitcoin-like miner started');\nstartWS();\nmineLoop();\n"
        }
    ]
}