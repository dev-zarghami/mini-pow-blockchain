{
    "sourceFile": "scanner.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1761986524822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1761986524822,
            "name": "Commit-0",
            "content": "/**\n * scanner.js\n * Simple block scanner / address indexer for your minimalist node.\n *\n * Usage:\n *   node scanner.js --address <ADDRESS>\n *\n * Features:\n * - Fetch chain + mempool from node\n * - Build tx history for the address (with block index & confirmations)\n * - Compute UTXOs (confirmed + including mempool spends)\n * - Live update on new_block / mempool_tx via WebSocket\n *\n * Notes:\n * - This scanner does not use the node's internal UTXO map; it rebuilds state\n *   by scanning blocks from genesis → tip, which makes it portable and robust.\n */\n\nconst axios = require('axios');\nconst WebSocket = require('ws');\nconst argv = require('minimist')(process.argv.slice(2));\n\nif (!argv.address) {\n  console.error('Usage: node scanner.js --address <ADDRESS>');\n  process.exit(1);\n}\n\nconst ADDRESS = argv.address;\nconst NODE_HTTP = 'http://localhost:3000';\nconst NODE_WS = 'ws://localhost:3000';\n\nlet chain = [];      // loaded chain from node\nlet mempool = [];    // loaded mempool from node\nlet tipIndex = 0;    // chain tip index\n\n// data structures produced by scanner\nlet txIndex = new Map(); // txid -> { tx, blockIndex (or null), fee }\nlet addressTxs = [];     // array of { txid, blockIndex, direction, amount, fee, inputs, outputs, timestamp }\nlet UTXOs = new Map();   // outpoint -> { txid, index, address, amount, blockIndex (or null) }\n\nasync function fetchChainAndMempool() {\n  const [chainRes, mempoolRes] = await Promise.all([\n    axios.get(`${NODE_HTTP}/chain`),\n    axios.get(`${NODE_HTTP}/mempool`)\n  ]);\n  chain = chainRes.data.chain || [];\n  mempool = mempoolRes.data.mempool || [];\n  tipIndex = chain.length - 1;\n}\n\nfunction resetIndex() {\n  txIndex.clear();\n  addressTxs = [];\n  UTXOs.clear();\n}\n\n// helper: outpoint string\nconst outpointKey = (txid, index) => `${txid}:${index}`;\n\n// Build index by scanning chain (confirmed txs) then mempool (unconfirmed)\nfunction buildIndex() {\n  resetIndex();\n\n  // 1) scan blocks from genesis -> tip; record txs, build UTXO map and mark spends\n  for (const block of chain) {\n    const bIndex = block.index;\n    for (const tx of block.transactions) {\n      // ensure tx entry\n      txIndex.set(tx.id, { tx, blockIndex: bIndex, fee: (tx.fee || 0) });\n\n      // mark inputs as spent (consume UTXO)\n      for (const inp of (tx.inputs || [])) {\n        const key = outpointKey(inp.txid, inp.index);\n        // spending a previously created UTXO -> remove it\n        if (UTXOs.has(key)) UTXOs.delete(key);\n      }\n\n      // add outputs as UTXOs\n      tx.outputs.forEach((o, i) => {\n        const key = outpointKey(tx.id, i);\n        UTXOs.set(key, { txid: tx.id, index: i, address: o.address, amount: o.amount, blockIndex: bIndex });\n      });\n    }\n  }\n\n  // 2) Now incorporate mempool txs (unconfirmed)\n  for (const tx of mempool) {\n    txIndex.set(tx.id, { tx, blockIndex: null, fee: (tx.fee || 0) });\n\n    // mempool inputs spend either confirmed UTXOs or other mempool outputs\n    for (const inp of (tx.inputs || [])) {\n      const key = outpointKey(inp.txid, inp.index);\n      if (UTXOs.has(key)) UTXOs.delete(key);\n    }\n\n    // mempool outputs become unconfirmed UTXOs\n    tx.outputs.forEach((o, i) => {\n      const key = outpointKey(tx.id, i);\n      UTXOs.set(key, { txid: tx.id, index: i, address: o.address, amount: o.amount, blockIndex: null });\n    });\n  }\n\n  // 3) Build address-specific transaction list and compute direction and amounts\n  // We'll iterate over txIndex entries and pick those where this address is involved\n  for (const [txid, entry] of txIndex.entries()) {\n    const tx = entry.tx;\n    const bIndex = entry.blockIndex; // null for mempool\n    let valueIn = 0;\n    let valueOut = 0;\n    let involves = false;\n\n    // Sum inputs that belong to this address (we need to resolve inputs' referenced outputs)\n    for (const inp of (tx.inputs || [])) {\n      const key = outpointKey(inp.txid, inp.index);\n      // try to find that output in txIndex or UTXOs (it may be spent already)\n      // best effort: if we have the original tx in txIndex, look into its outputs\n      const refEntry = txIndex.get(inp.txid);\n      if (refEntry && refEntry.tx && refEntry.tx.outputs[inp.index]) {\n        const origOut = refEntry.tx.outputs[inp.index];\n        if (origOut.address === ADDRESS) {\n          valueIn += origOut.amount;\n          involves = true;\n        }\n      } else {\n        // fallback: if we don't have ref tx, check current UTXO map (maybe unspent)\n        // (rare in our small node, but keep for safety)\n        // nothing to do if not resolvable\n      }\n    }\n\n    // Sum outputs to this address\n    tx.outputs.forEach((o, i) => {\n      if (o.address === ADDRESS) {\n        valueOut += o.amount;\n        involves = true;\n      }\n    });\n\n    if (involves) {\n      const direction = valueOut > valueIn ? 'incoming' : (valueOut < valueIn ? 'outgoing' : 'self/contract');\n      const amount = Math.abs(valueOut - valueIn);\n      addressTxs.push({\n        txid,\n        blockIndex: bIndex,\n        confirmations: (bIndex === null) ? 0 : (tipIndex - bIndex + 1),\n        direction,\n        amount,\n        fee: entry.fee || 0,\n        inputs: tx.inputs || [],\n        outputs: tx.outputs || [],\n        timestamp: (tx.timestamp || null)\n      });\n    }\n  }\n\n  // Sort addressTxs: confirmed desc by blockIndex then mempool last (blockIndex null)\n  addressTxs.sort((a, b) => {\n    if (a.blockIndex === null && b.blockIndex === null) return 0;\n    if (a.blockIndex === null) return 1;\n    if (b.blockIndex === null) return -1;\n    return b.blockIndex - a.blockIndex;\n  });\n}\n\n// Utility: compute balance (confirmed and unconfirmed)\nfunction computeBalance() {\n  let confirmed = 0;\n  let unconfirmed = 0;\n  for (const [key, u] of UTXOs.entries()) {\n    if (u.address !== ADDRESS) continue;\n    if (u.blockIndex === null) unconfirmed += u.amount;\n    else confirmed += u.amount;\n  }\n  return { confirmed, unconfirmed, total: confirmed + unconfirmed };\n}\n\n// Pretty-print results\nfunction printSummary() {\n  console.clear();\n  console.log('===== Simple Scanner =====');\n  console.log(`Address: ${ADDRESS}`);\n  console.log(`Chain tip: #${tipIndex}`);\n  const bal = computeBalance();\n  console.log(`Balance: confirmed=${bal.confirmed} | unconfirmed=${bal.unconfirmed} | total=${bal.total}`);\n  console.log('---------------------------');\n\n  console.log('UTXOs (unspent outputs):');\n  for (const [k, u] of UTXOs.entries()) {\n    if (u.address !== ADDRESS) continue;\n    console.log(`  - ${k} | amount=${u.amount} | ${u.blockIndex === null ? 'unconfirmed' : `blk#${u.blockIndex}`}`);\n  }\n  console.log('---------------------------');\n\n  console.log('Transactions (most recent first):');\n  for (const t of addressTxs.slice(0, 50)) {\n    console.log(`  - tx=${t.txid} | ${t.direction} | amt=${t.amount} | fee=${t.fee} | confirmations=${t.confirmations} ${t.blockIndex===null? '(mempool)':''}`);\n  }\n  console.log('===========================');\n}\n\n// Live watcher: listen WS and update index when events come\nfunction startWatcher() {\n  const ws = new WebSocket(NODE_WS);\n  ws.on('open', () => {\n    console.log('[WS] connected to node');\n  });\n  ws.on('message', async (buf) => {\n    try {\n      const msg = JSON.parse(buf.toString());\n      if (['new_block', 'mempool_tx', 'config_update'].includes(msg.type)) {\n        console.log('[WS] event:', msg.type, '→ rebuilding index...');\n        // fetch fresh chain & mempool and rebuild index\n        await fetchChainAndMempool();\n        buildIndex();\n        printSummary();\n      } else {\n        // ignore other messages\n      }\n    } catch (e) {\n      console.error('[WS] parse error', e.message);\n    }\n  });\n  ws.on('close', () => {\n    console.log('[WS] closed. reconnecting in 3s...');\n    setTimeout(startWatcher, 3000);\n  });\n  ws.on('error', (err) => {\n    console.error('[WS] error', err.message);\n  });\n}\n\n// main\n(async () => {\n  try {\n    console.log('Scanner starting...');\n    await fetchChainAndMempool();\n    buildIndex();\n    printSummary();\n    startWatcher();\n    // Also poll periodically in case WS missed something\n    setInterval(async () => {\n      try {\n        await fetchChainAndMempool();\n        buildIndex();\n        printSummary();\n      } catch (e) {\n        console.error('Periodic scan error', e.message);\n      }\n    }, 15_000); // every 15 seconds\n  } catch (e) {\n    console.error('Fatal error', e.message);\n    process.exit(1);\n  }\n})();\n"
        }
    ]
}