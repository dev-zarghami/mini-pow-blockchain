{
    "sourceFile": "server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 32,
            "patches": [
                {
                    "date": 1761980246374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761981196844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,84 +24,107 @@\n \n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n const sha256 = d => crypto.createHash('sha256').update(d).digest();\n const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n-function pubKeyToAddress(pubKeyHex){return ripemd160hex(sha256(Buffer.from(pubKeyHex,'hex')));}\n-function blockHash(b){return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty);}\n-function txHashForSigning(tx){\n+function pubKeyToAddress(pubKeyHex) { return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex'))); }\n+function blockHash(b) { return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty); }\n+function txHashForSigning(tx) {\n   const slim = {\n     inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n     outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n   };\n   return sha256hex(JSON.stringify(slim));\n }\n \n-function createGenesisBlock(){\n-  const g={index:0,timestamp:new Date().toISOString(),transactions:[],previousHash:'0',nonce:0,difficulty:config.difficulty};\n-  g.hash=blockHash(g);\n+function merkleRoot(txids) {\n+  if (txids.length === 0) return sha256hex('');\n+  let layer = txids.map(x => Buffer.from(x, 'hex'));\n+  while (layer.length > 1) {\n+    const next = [];\n+    for (let i = 0; i < layer.length; i += 2) {\n+      const left = layer[i];\n+      const right = layer[i + 1] || left; // duplicate odd leaf\n+      next.push(sha256(Buffer.concat([left, right])));\n+    }\n+    layer = next;\n+  }\n+  return layer[0].toString('hex');\n+}\n+\n+function headerHash(header) { // canonical, no JSON\n+  const data = [\n+    String(header.index), header.previousHash, String(header.timestamp),\n+    header.merkleRoot, String(header.nonce), String(header.difficulty)\n+  ].join('|'); // simple, deterministic serialization\n+  return sha256hex(data);\n+}\n+\n+function createGenesisBlock() {\n+  const g = { index: 0, timestamp: new Date().toISOString(), transactions: [], previousHash: '0', nonce: 0, difficulty: config.difficulty };\n+  g.hash = blockHash(g);\n   return g;\n }\n-function applyTxToUTXO(tx){\n-  for(const inp of (tx.inputs||[])) UTXO.delete(`${inp.txid}:${inp.index}`);\n-  tx.outputs.forEach((o,i)=>UTXO.set(`${tx.id}:${i}`,{address:o.address,amount:o.amount}));\n+function applyTxToUTXO(tx) {\n+  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n+  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n }\n-function rebuildUTXO(){\n+function rebuildUTXO() {\n   UTXO.clear();\n-  for(const b of chain) for(const tx of b.transactions) applyTxToUTXO(tx);\n+  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n }\n-function loadChain(){\n-  const files=fs.readdirSync(BLOCKS_DIR).filter(f=>f.endsWith('.txt')).sort();\n-  if(files.length===0){\n-    const g=createGenesisBlock();\n+function loadChain() {\n+  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n+  if (files.length === 0) {\n+    const g = createGenesisBlock();\n     chain.push(g);\n-    fs.writeFileSync(path.join(BLOCKS_DIR,'block_0.txt'),JSON.stringify(g,null,2));\n+    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n     console.log('ðŸ§± Genesis block created');\n-  }else{\n-    for(const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR,f),'utf8')));\n+  } else {\n+    for (const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n     console.log(`ðŸ“¦ Loaded ${chain.length} blocks`);\n   }\n   rebuildUTXO();\n }\n loadChain();\n \n // validation\n-function validateTx(tx, utxoSet=UTXO){\n-  const isCoinbase=!tx.inputs||tx.inputs.length===0;\n-  if(isCoinbase)return{ok:true,fee:0};\n-  let inSum=0,outSum=0;\n-  const msgHash=txHashForSigning(tx);\n-  for(const inp of tx.inputs){\n-    const key=`${inp.txid}:${inp.index}`;\n-    const u=utxoSet.get(key);\n-    if(!u)return{ok:false,error:`missing utxo ${key}`};\n-    const addr=pubKeyToAddress(inp.pubKey);\n-    if(addr!==u.address)return{ok:false,error:'pubKey mismatch'};\n-    const pub=ec.keyFromPublic(inp.pubKey,'hex');\n-    if(!pub.verify(msgHash,inp.sig))return{ok:false,error:'bad signature'};\n-    inSum+=u.amount;\n+function validateTx(tx, utxoSet = UTXO) {\n+  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n+  if (isCoinbase) return { ok: true, fee: 0 };\n+  let inSum = 0, outSum = 0;\n+  const msgHash = txHashForSigning(tx);\n+  for (const inp of tx.inputs) {\n+    const key = `${inp.txid}:${inp.index}`;\n+    const u = utxoSet.get(key);\n+    if (!u) return { ok: false, error: `missing utxo ${key}` };\n+    const addr = pubKeyToAddress(inp.pubKey);\n+    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n+    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n+    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n+    inSum += u.amount;\n   }\n-  for(const o of tx.outputs){\n-    if(typeof o.amount!=='number'||o.amount<=0)return{ok:false,error:'invalid output'};\n-    outSum+=o.amount;\n+  for (const o of tx.outputs) {\n+    if (typeof o.amount !== 'number' || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+    outSum += o.amount;\n   }\n-  const fee=inSum-outSum;\n-  if(fee<0)return{ok:false,error:'negative fee'};\n-  return{ok:true,fee};\n+  const fee = inSum - outSum;\n+  if (fee < 0) return { ok: false, error: 'negative fee' };\n+  return { ok: true, fee };\n }\n \n-function validateBlock(block){\n-  const last=chain[chain.length-1];\n-  if(block.previousHash!==last.hash)return{ok:false,error:'prev hash mismatch'};\n-  if(block.hash!==blockHash(block))return{ok:false,error:'bad block hash'};\n-  if(!block.hash.startsWith('0'.repeat(block.difficulty)))return{ok:false,error:'not meeting difficulty'};\n-  const temp=new Map(UTXO);\n-  for(const tx of block.transactions){\n-    const v=validateTx(tx,temp);\n-    if(!v.ok)return v;\n-    for(const i of(tx.inputs||[]))temp.delete(`${i.txid}:${i.index}`);\n-    tx.outputs.forEach((o,i)=>temp.set(`${tx.id}:${i}`,{address:o.address,amount:o.amount}));\n+function validateBlock(block) {\n+  const last = chain[chain.length - 1];\n+  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n+  if (block.hash !== blockHash(block)) return { ok: false, error: 'bad block hash' };\n+  if (!block.hash.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n+  const temp = new Map(UTXO);\n+  for (const tx of block.transactions) {\n+    const v = validateTx(tx, temp);\n+    if (!v.ok) return v;\n+    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n+    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n-  return{ok:true};\n+  return { ok: true };\n }\n \n // difficulty adjustment (real)\n function adjustDifficulty() {\n@@ -122,52 +145,52 @@\n   else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n \n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n   console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type:'config_update', config });\n+  wsBroadcast({ type: 'config_update', config });\n }\n \n // API\n-app.get('/chain',(req,res)=>res.json({length:chain.length,chain}));\n-app.get('/mempool',(req,res)=>res.json({mempool}));\n-app.get('/config',(req,res)=>res.json(config));\n+app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n+app.get('/mempool', (req, res) => res.json({ mempool }));\n+app.get('/config', (req, res) => res.json(config));\n \n-app.post('/transactions',(req,res)=>{\n-  const tx=req.body;\n-  tx.id=tx.id||sha256hex(JSON.stringify(tx)+Date.now());\n-  const v=validateTx(tx);\n-  if(!v.ok)return res.status(400).json({error:v.error});\n-  tx.fee=v.fee;\n+app.post('/transactions', (req, res) => {\n+  const tx = req.body;\n+  tx.id = tx.id || sha256hex(JSON.stringify(tx) + Date.now());\n+  const v = validateTx(tx);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n+  tx.fee = v.fee;\n   mempool.push(tx);\n   console.log(`ðŸ’° TX added: ${tx.id} | fee=${v.fee}`);\n-  wsBroadcast({type:'mempool_tx',tx});\n-  res.json({status:'added',id:tx.id});\n+  wsBroadcast({ type: 'mempool_tx', tx });\n+  res.json({ status: 'added', id: tx.id });\n });\n \n-app.post('/blocks',(req,res)=>{\n-  const block=req.body;\n-  const v=validateBlock(block);\n-  if(!v.ok)return res.status(400).json({error:v.error});\n+app.post('/blocks', (req, res) => {\n+  const block = req.body;\n+  const v = validateBlock(block);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n \n   chain.push(block);\n-  fs.writeFileSync(path.join(BLOCKS_DIR,`block_${block.index}.txt`),JSON.stringify(block,null,2));\n-  for(const tx of block.transactions)applyTxToUTXO(tx);\n-  const ids=new Set(block.transactions.map(t=>t.id));\n-  mempool=mempool.filter(t=>!ids.has(t.id));\n+  fs.writeFileSync(path.join(BLOCKS_DIR, `block_${block.index}.txt`), JSON.stringify(block, null, 2));\n+  for (const tx of block.transactions) applyTxToUTXO(tx);\n+  const ids = new Set(block.transactions.map(t => t.id));\n+  mempool = mempool.filter(t => !ids.has(t.id));\n   console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n-  wsBroadcast({type:'new_block',header:{index:block.index,hash:block.hash,difficulty:block.difficulty,txs:block.transactions.length}});\n+  wsBroadcast({ type: 'new_block', header: { index: block.index, hash: block.hash, difficulty: block.difficulty, txs: block.transactions.length } });\n   adjustDifficulty();\n-  res.json({status:'block accepted',index:block.index});\n+  res.json({ status: 'block accepted', index: block.index });\n });\n \n // WebSocket server\n const server = http.createServer(app);\n const wss = new WebSocketServer({ server });\n-function wsBroadcast(obj){\n-  const msg=JSON.stringify(obj);\n-  wss.clients.forEach(c=>{if(c.readyState===1)c.send(msg);});\n+function wsBroadcast(obj) {\n+  const msg = JSON.stringify(obj);\n+  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n }\n-wss.on('connection',(ws)=>{\n+wss.on('connection', (ws) => {\n   console.log('ðŸ”Œ Miner connected');\n-  ws.send(JSON.stringify({type:'hello',height:chain.length,diff:config.difficulty}));\n+  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n });\n-server.listen(PORT,()=>console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n+server.listen(PORT, () => console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n"
                },
                {
                    "date": 1761981215962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,21 +112,55 @@\n }\n \n function validateBlock(block) {\n   const last = chain[chain.length - 1];\n+\n+  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n   if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n-  if (block.hash !== blockHash(block)) return { ok: false, error: 'bad block hash' };\n-  if (!block.hash.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n+\n+  // Timestamp sanity (allow small future skew)\n+  const t = new Date(block.timestamp).getTime();\n+  const now = Date.now();\n+  const lastT = new Date(last.timestamp).getTime();\n+  if (!(t >= lastT && t <= now + 2 * 60 * 1000)) return { ok: false, error: 'bad timestamp' };\n+\n+  // Merkle & header\n+  const root = merkleRoot(block.transactions.map(tx => tx.id));\n+  const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n+  const h = headerHash(header);\n+  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n+  if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n+\n+  // Transactions & temporary UTXO\n   const temp = new Map(UTXO);\n+  let seenTxIds = new Set();\n+  let coinbaseCount = 0;\n+  let feeTotal = 0;\n+\n   for (const tx of block.transactions) {\n+    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n+    seenTxIds.add(tx.id);\n+\n     const v = validateTx(tx, temp);\n     if (!v.ok) return v;\n+\n+    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n+    feeTotal += v.fee;\n+\n+    // apply to temp\n     for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n     tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n+\n+  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n+  // OPTIONAL: enforce subsidy\n+  // const expectedReward = config.blockSubsidy + feeTotal;\n+  // if (sumCoinbaseOutputs(block.transactions[0]) !== expectedReward) return { ok:false, error:'bad coinbase value' };\n+\n   return { ok: true };\n }\n \n+\n // difficulty adjustment (real)\n function adjustDifficulty() {\n   const n = config.adjustEvery;\n   if (chain.length <= n) return;\n"
                },
                {
                    "date": 1761981247210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,26 @@\n   };\n   return sha256hex(JSON.stringify(slim));\n }\n \n+function stableStringify(obj) {\n+  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n+  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n+  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n+}\n+\n+function computeTxId(tx) {\n+  // txid should include inputs (incl. pubKey & sig) and outputs, deterministically\n+  const idShape = {\n+    inputs: (tx.inputs || []).map(i => ({\n+      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n+    })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256hex(stableStringify(idShape));\n+}\n+\n+\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n"
                },
                {
                    "date": 1761981267606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,18 +207,30 @@\n app.get('/config', (req, res) => res.json(config));\n \n app.post('/transactions', (req, res) => {\n   const tx = req.body;\n-  tx.id = tx.id || sha256hex(JSON.stringify(tx) + Date.now());\n+\n+  // Basic shape checks\n+  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n+    return res.status(400).json({ error: 'missing outputs' });\n+\n+  // Deterministic id\n+  tx.id = computeTxId(tx);\n+\n+  // Validate\n   const v = validateTx(tx);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n   tx.fee = v.fee;\n+\n+  // Mempool double-spend guard\n+  if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n+\n   mempool.push(tx);\n-  console.log(`ðŸ’° TX added: ${tx.id} | fee=${v.fee}`);\n   wsBroadcast({ type: 'mempool_tx', tx });\n   res.json({ status: 'added', id: tx.id });\n });\n \n+\n app.post('/blocks', (req, res) => {\n   const block = req.body;\n   const v = validateBlock(block);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n"
                },
                {
                    "date": 1761981292293,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,30 +106,53 @@\n \n // validation\n function validateTx(tx, utxoSet = UTXO) {\n   const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n-  if (isCoinbase) return { ok: true, fee: 0 };\n+  if (isCoinbase) {\n+    // No inputs, but still validate outputs strictly\n+    let outSum = 0;\n+    for (const o of tx.outputs) {\n+      if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+      outSum += o.amount;\n+    }\n+    return { ok: true, fee: 0 };\n+  }\n+\n+  // Duplicate input detection\n+  const seen = new Set();\n   let inSum = 0, outSum = 0;\n   const msgHash = txHashForSigning(tx);\n+\n   for (const inp of tx.inputs) {\n+    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number') return { ok: false, error: 'bad input' };\n     const key = `${inp.txid}:${inp.index}`;\n+    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n+    seen.add(key);\n+\n     const u = utxoSet.get(key);\n     if (!u) return { ok: false, error: `missing utxo ${key}` };\n+\n+    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n     const addr = pubKeyToAddress(inp.pubKey);\n     if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n+\n     const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n     if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n+\n     inSum += u.amount;\n   }\n+\n   for (const o of tx.outputs) {\n-    if (typeof o.amount !== 'number' || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+    if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n     outSum += o.amount;\n   }\n+\n   const fee = inSum - outSum;\n   if (fee < 0) return { ok: false, error: 'negative fee' };\n   return { ok: true, fee };\n }\n \n+\n function validateBlock(block) {\n   const last = chain[chain.length - 1];\n \n   if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n"
                },
                {
                    "date": 1761981332906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,290 @@\n+const express = require('express');\n+const bodyParser = require('body-parser');\n+const fs = require('fs');\n+const path = require('path');\n+const crypto = require('crypto');\n+const EC = require('elliptic').ec;\n+const ec = new EC('secp256k1');\n+const http = require('http');\n+const { WebSocketServer } = require('ws');\n+\n+const app = express();\n+app.use(bodyParser.json());\n+\n+const PORT = 3000;\n+const BLOCKS_DIR = path.join(__dirname, 'blocks');\n+if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n+\n+const CONFIG_FILE = path.join(__dirname, 'config.json');\n+let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n+\n+let chain = [];\n+let mempool = [];\n+let UTXO = new Map();\n+\n+const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n+const sha256 = d => crypto.createHash('sha256').update(d).digest();\n+const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n+function pubKeyToAddress(pubKeyHex) { return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex'))); }\n+function blockHash(b) { return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty); }\n+function txHashForSigning(tx) {\n+  const slim = {\n+    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256hex(JSON.stringify(slim));\n+}\n+\n+function conflictsWithMempool(tx) {\n+  if (!tx.inputs) return false;\n+  const memSpent = new Set();\n+  for (const t of mempool) for (const i of (t.inputs || [])) memSpent.add(`${i.txid}:${i.index}`);\n+  return tx.inputs.some(i => memSpent.has(`${i.txid}:${i.index}`));\n+}\n+\n+function stableStringify(obj) {\n+  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n+  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n+  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n+}\n+\n+function computeTxId(tx) {\n+  // txid should include inputs (incl. pubKey & sig) and outputs, deterministically\n+  const idShape = {\n+    inputs: (tx.inputs || []).map(i => ({\n+      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n+    })),\n+    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n+  };\n+  return sha256hex(stableStringify(idShape));\n+}\n+\n+\n+function merkleRoot(txids) {\n+  if (txids.length === 0) return sha256hex('');\n+  let layer = txids.map(x => Buffer.from(x, 'hex'));\n+  while (layer.length > 1) {\n+    const next = [];\n+    for (let i = 0; i < layer.length; i += 2) {\n+      const left = layer[i];\n+      const right = layer[i + 1] || left; // duplicate odd leaf\n+      next.push(sha256(Buffer.concat([left, right])));\n+    }\n+    layer = next;\n+  }\n+  return layer[0].toString('hex');\n+}\n+\n+function headerHash(header) { // canonical, no JSON\n+  const data = [\n+    String(header.index), header.previousHash, String(header.timestamp),\n+    header.merkleRoot, String(header.nonce), String(header.difficulty)\n+  ].join('|'); // simple, deterministic serialization\n+  return sha256hex(data);\n+}\n+\n+function createGenesisBlock() {\n+  const g = { index: 0, timestamp: new Date().toISOString(), transactions: [], previousHash: '0', nonce: 0, difficulty: config.difficulty };\n+  g.hash = blockHash(g);\n+  return g;\n+}\n+function applyTxToUTXO(tx) {\n+  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n+  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+}\n+function rebuildUTXO() {\n+  UTXO.clear();\n+  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n+}\n+function loadChain() {\n+  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n+  if (files.length === 0) {\n+    const g = createGenesisBlock();\n+    chain.push(g);\n+    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n+    console.log('ðŸ§± Genesis block created');\n+  } else {\n+    for (const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n+    console.log(`ðŸ“¦ Loaded ${chain.length} blocks`);\n+  }\n+  rebuildUTXO();\n+}\n+loadChain();\n+\n+// validation\n+function validateTx(tx, utxoSet = UTXO) {\n+  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n+  if (isCoinbase) {\n+    // No inputs, but still validate outputs strictly\n+    let outSum = 0;\n+    for (const o of tx.outputs) {\n+      if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+      outSum += o.amount;\n+    }\n+    return { ok: true, fee: 0 };\n+  }\n+\n+  // Duplicate input detection\n+  const seen = new Set();\n+  let inSum = 0, outSum = 0;\n+  const msgHash = txHashForSigning(tx);\n+\n+  for (const inp of tx.inputs) {\n+    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number') return { ok: false, error: 'bad input' };\n+    const key = `${inp.txid}:${inp.index}`;\n+    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n+    seen.add(key);\n+\n+    const u = utxoSet.get(key);\n+    if (!u) return { ok: false, error: `missing utxo ${key}` };\n+\n+    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n+    const addr = pubKeyToAddress(inp.pubKey);\n+    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n+\n+    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n+    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n+\n+    inSum += u.amount;\n+  }\n+\n+  for (const o of tx.outputs) {\n+    if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+    outSum += o.amount;\n+  }\n+\n+  const fee = inSum - outSum;\n+  if (fee < 0) return { ok: false, error: 'negative fee' };\n+  return { ok: true, fee };\n+}\n+\n+\n+function validateBlock(block) {\n+  const last = chain[chain.length - 1];\n+\n+  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n+  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n+\n+  // Timestamp sanity (allow small future skew)\n+  const t = new Date(block.timestamp).getTime();\n+  const now = Date.now();\n+  const lastT = new Date(last.timestamp).getTime();\n+  if (!(t >= lastT && t <= now + 2 * 60 * 1000)) return { ok: false, error: 'bad timestamp' };\n+\n+  // Merkle & header\n+  const root = merkleRoot(block.transactions.map(tx => tx.id));\n+  const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n+  const h = headerHash(header);\n+  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n+  if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n+\n+  // Transactions & temporary UTXO\n+  const temp = new Map(UTXO);\n+  let seenTxIds = new Set();\n+  let coinbaseCount = 0;\n+  let feeTotal = 0;\n+\n+  for (const tx of block.transactions) {\n+    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n+    seenTxIds.add(tx.id);\n+\n+    const v = validateTx(tx, temp);\n+    if (!v.ok) return v;\n+\n+    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n+    feeTotal += v.fee;\n+\n+    // apply to temp\n+    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n+    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n+  }\n+\n+  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n+  // OPTIONAL: enforce subsidy\n+  // const expectedReward = config.blockSubsidy + feeTotal;\n+  // if (sumCoinbaseOutputs(block.transactions[0]) !== expectedReward) return { ok:false, error:'bad coinbase value' };\n+\n+  return { ok: true };\n+}\n+\n+\n+// difficulty adjustment (real)\n+function adjustDifficulty() {\n+  const n = config.adjustEvery;\n+  if (chain.length <= n) return;\n+\n+  const lastN = chain.slice(-n);\n+  const times = lastN.map(b => new Date(b.timestamp).getTime());\n+  const duration = (times[times.length - 1] - times[0]) / 1000; // seconds\n+  const avgTime = duration / (n - 1);\n+  const target = config.targetBlockTimeSec;\n+  const ratio = avgTime / target;\n+\n+  // log previous difficulty\n+  const oldDiff = config.difficulty;\n+\n+  if (ratio < 0.9) config.difficulty++;        // blocks too fast\n+  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n+\n+  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n+  console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n+  wsBroadcast({ type: 'config_update', config });\n+}\n+\n+// API\n+app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n+app.get('/mempool', (req, res) => res.json({ mempool }));\n+app.get('/config', (req, res) => res.json(config));\n+\n+app.post('/transactions', (req, res) => {\n+  const tx = req.body;\n+\n+  // Basic shape checks\n+  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n+    return res.status(400).json({ error: 'missing outputs' });\n+\n+  // Deterministic id\n+  tx.id = computeTxId(tx);\n+\n+  // Validate\n+  const v = validateTx(tx);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n+  tx.fee = v.fee;\n+\n+  // Mempool double-spend guard\n+  if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n+\n+  mempool.push(tx);\n+  wsBroadcast({ type: 'mempool_tx', tx });\n+  res.json({ status: 'added', id: tx.id });\n+});\n+\n+\n+app.post('/blocks', (req, res) => {\n+  const block = req.body;\n+  const v = validateBlock(block);\n+  if (!v.ok) return res.status(400).json({ error: v.error });\n+\n+  chain.push(block);\n+  fs.writeFileSync(path.join(BLOCKS_DIR, `block_${block.index}.txt`), JSON.stringify(block, null, 2));\n+  for (const tx of block.transactions) applyTxToUTXO(tx);\n+  const ids = new Set(block.transactions.map(t => t.id));\n+  mempool = mempool.filter(t => !ids.has(t.id));\n+  console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n+  wsBroadcast({ type: 'new_block', header: { index: block.index, hash: block.hash, difficulty: block.difficulty, txs: block.transactions.length } });\n+  adjustDifficulty();\n+  res.json({ status: 'block accepted', index: block.index });\n+});\n+\n+// WebSocket server\n+const server = http.createServer(app);\n+const wss = new WebSocketServer({ server });\n+function wsBroadcast(obj) {\n+  const msg = JSON.stringify(obj);\n+  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n+}\n+wss.on('connection', (ws) => {\n+  console.log('ðŸ”Œ Miner connected');\n+  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n+});\n+server.listen(PORT, () => console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n"
                },
                {
                    "date": 1761981409818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,314 +207,29 @@\n   return { ok: true };\n }\n \n \n-// difficulty adjustment (real)\n function adjustDifficulty() {\n   const n = config.adjustEvery;\n-  if (chain.length <= n) return;\n+  if (chain.length <= n || n < 2) return;\n \n   const lastN = chain.slice(-n);\n-  const times = lastN.map(b => new Date(b.timestamp).getTime());\n-  const duration = (times[times.length - 1] - times[0]) / 1000; // seconds\n+  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a,b)=>a-b);\n+  const duration = (times[times.length - 1] - times[0]) / 1000;\n   const avgTime = duration / (n - 1);\n   const target = config.targetBlockTimeSec;\n   const ratio = avgTime / target;\n \n-  // log previous difficulty\n   const oldDiff = config.difficulty;\n-\n-  if (ratio < 0.9) config.difficulty++;        // blocks too fast\n+  if (ratio < 0.9) config.difficulty++;\n   else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n \n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n   console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type: 'config_update', config });\n+  wsBroadcast({ type:'config_update', config });\n }\n \n-// API\n-app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n-app.get('/mempool', (req, res) => res.json({ mempool }));\n-app.get('/config', (req, res) => res.json(config));\n \n-app.post('/transactions', (req, res) => {\n-  const tx = req.body;\n-\n-  // Basic shape checks\n-  if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n-    return res.status(400).json({ error: 'missing outputs' });\n-\n-  // Deterministic id\n-  tx.id = computeTxId(tx);\n-\n-  // Validate\n-  const v = validateTx(tx);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n-  tx.fee = v.fee;\n-\n-  // Mempool double-spend guard\n-  if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n-\n-  mempool.push(tx);\n-  wsBroadcast({ type: 'mempool_tx', tx });\n-  res.json({ status: 'added', id: tx.id });\n-});\n-\n-\n-app.post('/blocks', (req, res) => {\n-  const block = req.body;\n-  const v = validateBlock(block);\n-  if (!v.ok) return res.status(400).json({ error: v.error });\n-\n-  chain.push(block);\n-  fs.writeFileSync(path.join(BLOCKS_DIR, `block_${block.index}.txt`), JSON.stringify(block, null, 2));\n-  for (const tx of block.transactions) applyTxToUTXO(tx);\n-  const ids = new Set(block.transactions.map(t => t.id));\n-  mempool = mempool.filter(t => !ids.has(t.id));\n-  console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n-  wsBroadcast({ type: 'new_block', header: { index: block.index, hash: block.hash, difficulty: block.difficulty, txs: block.transactions.length } });\n-  adjustDifficulty();\n-  res.json({ status: 'block accepted', index: block.index });\n-});\n-\n-// WebSocket server\n-const server = http.createServer(app);\n-const wss = new WebSocketServer({ server });\n-function wsBroadcast(obj) {\n-  const msg = JSON.stringify(obj);\n-  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n-}\n-wss.on('connection', (ws) => {\n-  console.log('ðŸ”Œ Miner connected');\n-  ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n-});\n-server.listen(PORT, () => console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n-const express = require('express');\n-const bodyParser = require('body-parser');\n-const fs = require('fs');\n-const path = require('path');\n-const crypto = require('crypto');\n-const EC = require('elliptic').ec;\n-const ec = new EC('secp256k1');\n-const http = require('http');\n-const { WebSocketServer } = require('ws');\n-\n-const app = express();\n-app.use(bodyParser.json());\n-\n-const PORT = 3000;\n-const BLOCKS_DIR = path.join(__dirname, 'blocks');\n-if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n-\n-const CONFIG_FILE = path.join(__dirname, 'config.json');\n-let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n-\n-let chain = [];\n-let mempool = [];\n-let UTXO = new Map();\n-\n-const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n-const sha256 = d => crypto.createHash('sha256').update(d).digest();\n-const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n-function pubKeyToAddress(pubKeyHex) { return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex'))); }\n-function blockHash(b) { return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty); }\n-function txHashForSigning(tx) {\n-  const slim = {\n-    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256hex(JSON.stringify(slim));\n-}\n-\n-function stableStringify(obj) {\n-  if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n-  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n-  return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n-}\n-\n-function computeTxId(tx) {\n-  // txid should include inputs (incl. pubKey & sig) and outputs, deterministically\n-  const idShape = {\n-    inputs: (tx.inputs || []).map(i => ({\n-      txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n-    })),\n-    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n-  };\n-  return sha256hex(stableStringify(idShape));\n-}\n-\n-\n-function merkleRoot(txids) {\n-  if (txids.length === 0) return sha256hex('');\n-  let layer = txids.map(x => Buffer.from(x, 'hex'));\n-  while (layer.length > 1) {\n-    const next = [];\n-    for (let i = 0; i < layer.length; i += 2) {\n-      const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate odd leaf\n-      next.push(sha256(Buffer.concat([left, right])));\n-    }\n-    layer = next;\n-  }\n-  return layer[0].toString('hex');\n-}\n-\n-function headerHash(header) { // canonical, no JSON\n-  const data = [\n-    String(header.index), header.previousHash, String(header.timestamp),\n-    header.merkleRoot, String(header.nonce), String(header.difficulty)\n-  ].join('|'); // simple, deterministic serialization\n-  return sha256hex(data);\n-}\n-\n-function createGenesisBlock() {\n-  const g = { index: 0, timestamp: new Date().toISOString(), transactions: [], previousHash: '0', nonce: 0, difficulty: config.difficulty };\n-  g.hash = blockHash(g);\n-  return g;\n-}\n-function applyTxToUTXO(tx) {\n-  for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n-  tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n-}\n-function rebuildUTXO() {\n-  UTXO.clear();\n-  for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n-}\n-function loadChain() {\n-  const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n-  if (files.length === 0) {\n-    const g = createGenesisBlock();\n-    chain.push(g);\n-    fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n-    console.log('ðŸ§± Genesis block created');\n-  } else {\n-    for (const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n-    console.log(`ðŸ“¦ Loaded ${chain.length} blocks`);\n-  }\n-  rebuildUTXO();\n-}\n-loadChain();\n-\n-// validation\n-function validateTx(tx, utxoSet = UTXO) {\n-  const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n-  if (isCoinbase) {\n-    // No inputs, but still validate outputs strictly\n-    let outSum = 0;\n-    for (const o of tx.outputs) {\n-      if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n-      outSum += o.amount;\n-    }\n-    return { ok: true, fee: 0 };\n-  }\n-\n-  // Duplicate input detection\n-  const seen = new Set();\n-  let inSum = 0, outSum = 0;\n-  const msgHash = txHashForSigning(tx);\n-\n-  for (const inp of tx.inputs) {\n-    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number') return { ok: false, error: 'bad input' };\n-    const key = `${inp.txid}:${inp.index}`;\n-    if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n-    seen.add(key);\n-\n-    const u = utxoSet.get(key);\n-    if (!u) return { ok: false, error: `missing utxo ${key}` };\n-\n-    if (!/^[0-9a-fA-F]+$/.test(inp.pubKey)) return { ok: false, error: 'bad pubKey' };\n-    const addr = pubKeyToAddress(inp.pubKey);\n-    if (addr !== u.address) return { ok: false, error: 'pubKey mismatch' };\n-\n-    const pub = ec.keyFromPublic(inp.pubKey, 'hex');\n-    if (!pub.verify(msgHash, inp.sig)) return { ok: false, error: 'bad signature' };\n-\n-    inSum += u.amount;\n-  }\n-\n-  for (const o of tx.outputs) {\n-    if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n-    outSum += o.amount;\n-  }\n-\n-  const fee = inSum - outSum;\n-  if (fee < 0) return { ok: false, error: 'negative fee' };\n-  return { ok: true, fee };\n-}\n-\n-\n-function validateBlock(block) {\n-  const last = chain[chain.length - 1];\n-\n-  if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n-  if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n-\n-  // Timestamp sanity (allow small future skew)\n-  const t = new Date(block.timestamp).getTime();\n-  const now = Date.now();\n-  const lastT = new Date(last.timestamp).getTime();\n-  if (!(t >= lastT && t <= now + 2 * 60 * 1000)) return { ok: false, error: 'bad timestamp' };\n-\n-  // Merkle & header\n-  const root = merkleRoot(block.transactions.map(tx => tx.id));\n-  const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n-  const h = headerHash(header);\n-  if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n-  if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n-\n-  // Transactions & temporary UTXO\n-  const temp = new Map(UTXO);\n-  let seenTxIds = new Set();\n-  let coinbaseCount = 0;\n-  let feeTotal = 0;\n-\n-  for (const tx of block.transactions) {\n-    if (seenTxIds.has(tx.id)) return { ok: false, error: 'duplicate tx in block' };\n-    seenTxIds.add(tx.id);\n-\n-    const v = validateTx(tx, temp);\n-    if (!v.ok) return v;\n-\n-    if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n-    feeTotal += v.fee;\n-\n-    // apply to temp\n-    for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n-    tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n-  }\n-\n-  if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n-  // OPTIONAL: enforce subsidy\n-  // const expectedReward = config.blockSubsidy + feeTotal;\n-  // if (sumCoinbaseOutputs(block.transactions[0]) !== expectedReward) return { ok:false, error:'bad coinbase value' };\n-\n-  return { ok: true };\n-}\n-\n-\n-// difficulty adjustment (real)\n-function adjustDifficulty() {\n-  const n = config.adjustEvery;\n-  if (chain.length <= n) return;\n-\n-  const lastN = chain.slice(-n);\n-  const times = lastN.map(b => new Date(b.timestamp).getTime());\n-  const duration = (times[times.length - 1] - times[0]) / 1000; // seconds\n-  const avgTime = duration / (n - 1);\n-  const target = config.targetBlockTimeSec;\n-  const ratio = avgTime / target;\n-\n-  // log previous difficulty\n-  const oldDiff = config.difficulty;\n-\n-  if (ratio < 0.9) config.difficulty++;        // blocks too fast\n-  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n-\n-  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type: 'config_update', config });\n-}\n-\n // API\n app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n app.get('/mempool', (req, res) => res.json({ mempool }));\n app.get('/config', (req, res) => res.json(config));\n"
                },
                {
                    "date": 1761981511378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,9 +212,9 @@\n   const n = config.adjustEvery;\n   if (chain.length <= n || n < 2) return;\n \n   const lastN = chain.slice(-n);\n-  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a,b)=>a-b);\n+  const times = lastN.map(b => new Date(b.timestamp).getTime()).sort((a, b) => a - b);\n   const duration = (times[times.length - 1] - times[0]) / 1000;\n   const avgTime = duration / (n - 1);\n   const target = config.targetBlockTimeSec;\n   const ratio = avgTime / target;\n@@ -224,9 +224,9 @@\n   else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n \n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n   console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n-  wsBroadcast({ type:'config_update', config });\n+  wsBroadcast({ type: 'config_update', config });\n }\n \n \n // API\n@@ -263,8 +263,13 @@\n   const v = validateBlock(block);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n \n   chain.push(block);\n+  const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n+  if (fs.existsSync(filePath)) return res.status(400).json({ error: 'block file already exists' });\n+  fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n+\n+\n   fs.writeFileSync(path.join(BLOCKS_DIR, `block_${block.index}.txt`), JSON.stringify(block, null, 2));\n   for (const tx of block.transactions) applyTxToUTXO(tx);\n   const ids = new Set(block.transactions.map(t => t.id));\n   mempool = mempool.filter(t => !ids.has(t.id));\n"
                },
                {
                    "date": 1761981547288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -266,11 +266,8 @@\n   chain.push(block);\n   const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n   if (fs.existsSync(filePath)) return res.status(400).json({ error: 'block file already exists' });\n   fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n-\n-\n-  fs.writeFileSync(path.join(BLOCKS_DIR, `block_${block.index}.txt`), JSON.stringify(block, null, 2));\n   for (const tx of block.transactions) applyTxToUTXO(tx);\n   const ids = new Set(block.transactions.map(t => t.id));\n   mempool = mempool.filter(t => !ids.has(t.id));\n   console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n"
                },
                {
                    "date": 1761981605252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -266,8 +266,9 @@\n   chain.push(block);\n   const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n   if (fs.existsSync(filePath)) return res.status(400).json({ error: 'block file already exists' });\n   fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n+\n   for (const tx of block.transactions) applyTxToUTXO(tx);\n   const ids = new Set(block.transactions.map(t => t.id));\n   mempool = mempool.filter(t => !ids.has(t.id));\n   console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n"
                },
                {
                    "date": 1761981623032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,12 +83,22 @@\n   return sha256hex(data);\n }\n \n function createGenesisBlock() {\n-  const g = { index: 0, timestamp: new Date().toISOString(), transactions: [], previousHash: '0', nonce: 0, difficulty: config.difficulty };\n-  g.hash = blockHash(g);\n+  const g = {\n+    index: 0,\n+    timestamp: new Date().toISOString(),\n+    transactions: [],\n+    previousHash: '0',\n+    nonce: 0,\n+    difficulty: config.difficulty\n+  };\n+  const root = merkleRoot([]); // empty txs\n+  const header = { ...g, merkleRoot: root };\n+  g.hash = headerHash(header);\n   return g;\n }\n+\n function applyTxToUTXO(tx) {\n   for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n   tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n }\n"
                },
                {
                    "date": 1761981656742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,12 +272,13 @@\n   const block = req.body;\n   const v = validateBlock(block);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n \n-  chain.push(block);\n   const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n   if (fs.existsSync(filePath)) return res.status(400).json({ error: 'block file already exists' });\n+\n   fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n+  chain.push(block);\n \n   for (const tx of block.transactions) applyTxToUTXO(tx);\n   const ids = new Set(block.transactions.map(t => t.id));\n   mempool = mempool.filter(t => !ids.has(t.id));\n"
                },
                {
                    "date": 1761981715800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n \n const app = express();\n app.use(bodyParser.json());\n \n+const MEMPOOL_MAX = 1000;\n const PORT = 3000;\n const BLOCKS_DIR = path.join(__dirname, 'blocks');\n if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n"
                },
                {
                    "date": 1761981722929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,14 +9,15 @@\n const { WebSocketServer } = require('ws');\n \n const app = express();\n app.use(bodyParser.json());\n-\n-const MEMPOOL_MAX = 1000;\n const PORT = 3000;\n const BLOCKS_DIR = path.join(__dirname, 'blocks');\n if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n+const MEMPOOL_MAX = 1000;\n+\n+\n const CONFIG_FILE = path.join(__dirname, 'config.json');\n let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n \n let chain = [];\n"
                },
                {
                    "date": 1761981744526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,11 +13,8 @@\n const PORT = 3000;\n const BLOCKS_DIR = path.join(__dirname, 'blocks');\n if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n-const MEMPOOL_MAX = 1000;\n-\n-\n const CONFIG_FILE = path.join(__dirname, 'config.json');\n let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n \n let chain = [];\n"
                },
                {
                    "date": 1761981795372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -245,8 +245,10 @@\n \n app.post('/transactions', (req, res) => {\n   const tx = req.body;\n \n+\n+  \n   // Basic shape checks\n   if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n     return res.status(400).json({ error: 'missing outputs' });\n \n"
                },
                {
                    "date": 1761981809722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,10 @@\n const PORT = 3000;\n const BLOCKS_DIR = path.join(__dirname, 'blocks');\n if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n+const MEMPOOL_MAX = 1000;\n+\n const CONFIG_FILE = path.join(__dirname, 'config.json');\n let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n \n let chain = [];\n@@ -245,10 +247,12 @@\n \n app.post('/transactions', (req, res) => {\n   const tx = req.body;\n \n+  if (mempool.length >= MEMPOOL_MAX) {\n+    return res.status(400).json({ error: 'mempool full' });\n+  }\n \n-  \n   // Basic shape checks\n   if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n     return res.status(400).json({ error: 'missing outputs' });\n \n"
                },
                {
                    "date": 1761981874234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,12 +210,14 @@\n     tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n \n   if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n-  // OPTIONAL: enforce subsidy\n-  // const expectedReward = config.blockSubsidy + feeTotal;\n-  // if (sumCoinbaseOutputs(block.transactions[0]) !== expectedReward) return { ok:false, error:'bad coinbase value' };\n \n+  const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n+  const expectedReward = config.blockSubsidy + feeTotal;\n+  if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n+    return { ok: false, error: 'coinbase reward too high' };\n+\n   return { ok: true };\n }\n \n \n"
                },
                {
                    "date": 1761981917749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,8 +268,13 @@\n \n   // Mempool double-spend guard\n   if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n \n+\n+  console.log(`ðŸ’° TX added ${tx.id.slice(0, 8)} | fee=${tx.fee}`);\n+  console.log(`ðŸ§± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n+\n+\n   mempool.push(tx);\n   wsBroadcast({ type: 'mempool_tx', tx });\n   res.json({ status: 'added', id: tx.id });\n });\n"
                },
                {
                    "date": 1761981925128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,13 +268,8 @@\n \n   // Mempool double-spend guard\n   if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n \n-\n-  console.log(`ðŸ’° TX added ${tx.id.slice(0, 8)} | fee=${tx.fee}`);\n-  console.log(`ðŸ§± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n-\n-\n   mempool.push(tx);\n   wsBroadcast({ type: 'mempool_tx', tx });\n   res.json({ status: 'added', id: tx.id });\n });\n"
                },
                {
                    "date": 1761982048848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,16 @@\n+/**\n+ * ðŸ§± Minimal Blockchain Full Node\n+ * ------------------------------------------------------------\n+ * Implements a simple Bitcoin-like blockchain node with:\n+ *  - UTXO validation\n+ *  - Deterministic TX IDs\n+ *  - Difficulty adjustment\n+ *  - File-based block persistence\n+ *  - REST + WebSocket miner interface\n+ * ------------------------------------------------------------\n+ */\n+\n const express = require('express');\n const bodyParser = require('body-parser');\n const fs = require('fs');\n const path = require('path');\n@@ -10,48 +22,73 @@\n \n const app = express();\n app.use(bodyParser.json());\n const PORT = 3000;\n+\n+// ----------------------\n+// Directory & Config Setup\n+// ----------------------\n const BLOCKS_DIR = path.join(__dirname, 'blocks');\n if (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n \n-const MEMPOOL_MAX = 1000;\n-\n+const MEMPOOL_MAX = 1000; // Maximum mempool size\n const CONFIG_FILE = path.join(__dirname, 'config.json');\n let config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n \n-let chain = [];\n-let mempool = [];\n-let UTXO = new Map();\n+// ----------------------\n+// In-memory state\n+// ----------------------\n+let chain = [];     // Full blockchain\n+let mempool = [];   // Pending transactions\n+let UTXO = new Map(); // Unspent Transaction Outputs\n \n+// ----------------------\n+// Hashing & Crypto Utils\n+// ----------------------\n const sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\n const sha256 = d => crypto.createHash('sha256').update(d).digest();\n const ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\n-function pubKeyToAddress(pubKeyHex) { return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex'))); }\n-function blockHash(b) { return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty); }\n+\n+// Address = RIPEMD160(SHA256(pubkey))\n+function pubKeyToAddress(pubKeyHex) {\n+  return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n+}\n+\n+// Old-style block hash (used for debugging)\n+function blockHash(b) {\n+  return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty);\n+}\n+\n+// Create message hash for transaction signing\n function txHashForSigning(tx) {\n   const slim = {\n     inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n     outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n   };\n   return sha256hex(JSON.stringify(slim));\n }\n \n+// ----------------------\n+// Helper Functions\n+// ----------------------\n+\n+// Prevent double-spend in mempool\n function conflictsWithMempool(tx) {\n   if (!tx.inputs) return false;\n   const memSpent = new Set();\n   for (const t of mempool) for (const i of (t.inputs || [])) memSpent.add(`${i.txid}:${i.index}`);\n   return tx.inputs.some(i => memSpent.has(`${i.txid}:${i.index}`));\n }\n \n+// Stable deterministic JSON stringifier (used for tx ID)\n function stableStringify(obj) {\n   if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n   if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n   return '{' + Object.keys(obj).sort().map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n }\n \n+// Deterministic transaction ID\n function computeTxId(tx) {\n-  // txid should include inputs (incl. pubKey & sig) and outputs, deterministically\n   const idShape = {\n     inputs: (tx.inputs || []).map(i => ({\n       txid: i.txid, index: i.index, pubKey: i.pubKey, sig: i.sig\n     })),\n@@ -59,32 +96,38 @@\n   };\n   return sha256hex(stableStringify(idShape));\n }\n \n-\n+// Build Merkle root from transaction IDs\n function merkleRoot(txids) {\n   if (txids.length === 0) return sha256hex('');\n   let layer = txids.map(x => Buffer.from(x, 'hex'));\n   while (layer.length > 1) {\n     const next = [];\n     for (let i = 0; i < layer.length; i += 2) {\n       const left = layer[i];\n-      const right = layer[i + 1] || left; // duplicate odd leaf\n+      const right = layer[i + 1] || left; // duplicate last if odd\n       next.push(sha256(Buffer.concat([left, right])));\n     }\n     layer = next;\n   }\n   return layer[0].toString('hex');\n }\n \n-function headerHash(header) { // canonical, no JSON\n+// Canonical block header hashing (deterministic)\n+function headerHash(header) {\n   const data = [\n     String(header.index), header.previousHash, String(header.timestamp),\n     header.merkleRoot, String(header.nonce), String(header.difficulty)\n-  ].join('|'); // simple, deterministic serialization\n+  ].join('|');\n   return sha256hex(data);\n }\n \n+// ----------------------\n+// Chain Initialization\n+// ----------------------\n+\n+// Create the genesis block\n function createGenesisBlock() {\n   const g = {\n     index: 0,\n     timestamp: new Date().toISOString(),\n@@ -92,57 +135,69 @@\n     previousHash: '0',\n     nonce: 0,\n     difficulty: config.difficulty\n   };\n-  const root = merkleRoot([]); // empty txs\n+  const root = merkleRoot([]);\n   const header = { ...g, merkleRoot: root };\n   g.hash = headerHash(header);\n   return g;\n }\n \n+// Apply a transactionâ€™s effects to UTXO set\n function applyTxToUTXO(tx) {\n   for (const inp of (tx.inputs || [])) UTXO.delete(`${inp.txid}:${inp.index}`);\n   tx.outputs.forEach((o, i) => UTXO.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n }\n+\n+// Rebuild UTXO set from full chain\n function rebuildUTXO() {\n   UTXO.clear();\n   for (const b of chain) for (const tx of b.transactions) applyTxToUTXO(tx);\n }\n+\n+// Load blockchain from /blocks folder or create genesis\n function loadChain() {\n   const files = fs.readdirSync(BLOCKS_DIR).filter(f => f.endsWith('.txt')).sort();\n   if (files.length === 0) {\n     const g = createGenesisBlock();\n     chain.push(g);\n     fs.writeFileSync(path.join(BLOCKS_DIR, 'block_0.txt'), JSON.stringify(g, null, 2));\n     console.log('ðŸ§± Genesis block created');\n   } else {\n-    for (const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n-    console.log(`ðŸ“¦ Loaded ${chain.length} blocks`);\n+    for (const f of files)\n+      chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR, f), 'utf8')));\n+    console.log(`ðŸ“¦ Loaded ${chain.length} blocks from disk`);\n   }\n   rebuildUTXO();\n+  console.log(`â›“ï¸  Current tip: #${chain[chain.length - 1].index}, hash=${chain[chain.length - 1].hash.slice(0, 12)}...`);\n }\n loadChain();\n \n-// validation\n+// ----------------------\n+// Validation Functions\n+// ----------------------\n+\n+// Transaction validation\n function validateTx(tx, utxoSet = UTXO) {\n   const isCoinbase = !tx.inputs || tx.inputs.length === 0;\n+\n+  // Coinbase TX: only outputs to miner, no inputs\n   if (isCoinbase) {\n-    // No inputs, but still validate outputs strictly\n-    let outSum = 0;\n-    for (const o of tx.outputs) {\n-      if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n-      outSum += o.amount;\n-    }\n+    for (const o of tx.outputs)\n+      if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n+        return { ok: false, error: 'invalid output' };\n     return { ok: true, fee: 0 };\n   }\n \n-  // Duplicate input detection\n   const seen = new Set();\n   let inSum = 0, outSum = 0;\n   const msgHash = txHashForSigning(tx);\n \n+  // Validate each input\n   for (const inp of tx.inputs) {\n-    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number') return { ok: false, error: 'bad input' };\n+    if (!inp || typeof inp.txid !== 'string' || typeof inp.index !== 'number')\n+      return { ok: false, error: 'bad input format' };\n+\n     const key = `${inp.txid}:${inp.index}`;\n     if (seen.has(key)) return { ok: false, error: 'duplicate input' };\n     seen.add(key);\n \n@@ -158,39 +213,43 @@\n \n     inSum += u.amount;\n   }\n \n+  // Validate outputs\n   for (const o of tx.outputs) {\n-    if (!Number.isSafeInteger(o.amount) || o.amount <= 0) return { ok: false, error: 'invalid output' };\n+    if (!Number.isSafeInteger(o.amount) || o.amount <= 0)\n+      return { ok: false, error: 'invalid output' };\n     outSum += o.amount;\n   }\n \n   const fee = inSum - outSum;\n   if (fee < 0) return { ok: false, error: 'negative fee' };\n+\n   return { ok: true, fee };\n }\n \n-\n+// Block validation\n function validateBlock(block) {\n   const last = chain[chain.length - 1];\n \n   if (block.index !== last.index + 1) return { ok: false, error: 'bad index' };\n   if (block.previousHash !== last.hash) return { ok: false, error: 'prev hash mismatch' };\n \n-  // Timestamp sanity (allow small future skew)\n+  // Timestamp sanity check (within +2 min skew)\n   const t = new Date(block.timestamp).getTime();\n   const now = Date.now();\n   const lastT = new Date(last.timestamp).getTime();\n-  if (!(t >= lastT && t <= now + 2 * 60 * 1000)) return { ok: false, error: 'bad timestamp' };\n+  if (!(t >= lastT && t <= now + 2 * 60 * 1000))\n+    return { ok: false, error: 'bad timestamp' };\n \n-  // Merkle & header\n+  // Validate block hash & difficulty\n   const root = merkleRoot(block.transactions.map(tx => tx.id));\n   const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n   const h = headerHash(header);\n   if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n   if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n \n-  // Transactions & temporary UTXO\n+  // Validate all transactions in block\n   const temp = new Map(UTXO);\n   let seenTxIds = new Set();\n   let coinbaseCount = 0;\n   let feeTotal = 0;\n@@ -204,24 +263,27 @@\n \n     if (!tx.inputs || tx.inputs.length === 0) coinbaseCount++;\n     feeTotal += v.fee;\n \n-    // apply to temp\n+    // Apply to temp UTXO\n     for (const i of (tx.inputs || [])) temp.delete(`${i.txid}:${i.index}`);\n     tx.outputs.forEach((o, i) => temp.set(`${tx.id}:${i}`, { address: o.address, amount: o.amount }));\n   }\n \n   if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n \n+  // Enforce miner reward limit\n   const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n   const expectedReward = config.blockSubsidy + feeTotal;\n   if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n     return { ok: false, error: 'coinbase reward too high' };\n \n   return { ok: true };\n }\n \n-\n+// ----------------------\n+// Difficulty Adjustment\n+// ----------------------\n function adjustDifficulty() {\n   const n = config.adjustEvery;\n   if (chain.length <= n || n < 2) return;\n \n@@ -236,74 +298,94 @@\n   if (ratio < 0.9) config.difficulty++;\n   else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n \n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n-  console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n+  console.log(`âš™ï¸ Difficulty adjust â†’ old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n   wsBroadcast({ type: 'config_update', config });\n }\n \n+// ----------------------\n+// REST API\n+// ----------------------\n \n-// API\n+// Chain and state endpoints\n app.get('/chain', (req, res) => res.json({ length: chain.length, chain }));\n app.get('/mempool', (req, res) => res.json({ mempool }));\n app.get('/config', (req, res) => res.json(config));\n \n+// New transaction submission\n app.post('/transactions', (req, res) => {\n   const tx = req.body;\n \n-  if (mempool.length >= MEMPOOL_MAX) {\n+  if (mempool.length >= MEMPOOL_MAX)\n     return res.status(400).json({ error: 'mempool full' });\n-  }\n \n-  // Basic shape checks\n   if (!tx.outputs || !Array.isArray(tx.outputs) || tx.outputs.length === 0)\n     return res.status(400).json({ error: 'missing outputs' });\n \n-  // Deterministic id\n   tx.id = computeTxId(tx);\n \n-  // Validate\n   const v = validateTx(tx);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n   tx.fee = v.fee;\n \n-  // Mempool double-spend guard\n-  if (conflictsWithMempool(tx)) return res.status(400).json({ error: 'mempool double-spend' });\n+  if (conflictsWithMempool(tx))\n+    return res.status(400).json({ error: 'mempool double-spend' });\n \n   mempool.push(tx);\n+  console.log(`ðŸ’° TX accepted: ${tx.id.slice(0, 12)}... | fee=${tx.fee}`);\n   wsBroadcast({ type: 'mempool_tx', tx });\n   res.json({ status: 'added', id: tx.id });\n });\n \n-\n+// New block submission\n app.post('/blocks', (req, res) => {\n   const block = req.body;\n   const v = validateBlock(block);\n   if (!v.ok) return res.status(400).json({ error: v.error });\n \n   const filePath = path.join(BLOCKS_DIR, `block_${block.index}.txt`);\n-  if (fs.existsSync(filePath)) return res.status(400).json({ error: 'block file already exists' });\n+  if (fs.existsSync(filePath))\n+    return res.status(400).json({ error: 'block file already exists' });\n \n   fs.writeFileSync(filePath, JSON.stringify(block, null, 2));\n   chain.push(block);\n \n   for (const tx of block.transactions) applyTxToUTXO(tx);\n   const ids = new Set(block.transactions.map(t => t.id));\n   mempool = mempool.filter(t => !ids.has(t.id));\n-  console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n-  wsBroadcast({ type: 'new_block', header: { index: block.index, hash: block.hash, difficulty: block.difficulty, txs: block.transactions.length } });\n+\n+  console.log(`ðŸ§± Accepted block #${block.index} (${block.transactions.length} txs, diff=${block.difficulty})`);\n+  wsBroadcast({\n+    type: 'new_block',\n+    header: {\n+      index: block.index,\n+      hash: block.hash,\n+      difficulty: block.difficulty,\n+      txs: block.transactions.length\n+    }\n+  });\n+\n   adjustDifficulty();\n   res.json({ status: 'block accepted', index: block.index });\n });\n \n-// WebSocket server\n+// ----------------------\n+// WebSocket Server (for miners/peers)\n+// ----------------------\n const server = http.createServer(app);\n const wss = new WebSocketServer({ server });\n+\n function wsBroadcast(obj) {\n   const msg = JSON.stringify(obj);\n   wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });\n }\n+\n wss.on('connection', (ws) => {\n   console.log('ðŸ”Œ Miner connected');\n   ws.send(JSON.stringify({ type: 'hello', height: chain.length, diff: config.difficulty }));\n });\n+\n+// ----------------------\n+// Start the Node\n+// ----------------------\n server.listen(PORT, () => console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n"
                },
                {
                    "date": 1761982124480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,13 +52,8 @@\n function pubKeyToAddress(pubKeyHex) {\n   return ripemd160hex(sha256(Buffer.from(pubKeyHex, 'hex')));\n }\n \n-// Old-style block hash (used for debugging)\n-function blockHash(b) {\n-  return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty);\n-}\n-\n // Create message hash for transaction signing\n function txHashForSigning(tx) {\n   const slim = {\n     inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n"
                },
                {
                    "date": 1761982703973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,8 +117,19 @@\n   return sha256hex(data);\n }\n \n // ----------------------\n+// Block Reward (Halving Logic)\n+// ----------------------\n+function getBlockReward(height) {\n+  const halvings = Math.floor(height / config.halvingInterval);\n+  // Ù‡Ø± Ø¨Ø§Ø± Ú©Ù‡ Ø¨Ù‡ halvingInterval Ø¨Ø±Ø³ÛŒÙ…ØŒ Ù¾Ø§Ø¯Ø§Ø´ Ù†ØµÙ Ù…ÛŒâ€ŒØ´ÙˆØ¯\n+  const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n+  return reward > 0 ? reward : 0; // Ù‡ÛŒÚ†ÙˆÙ‚Øª Ù…Ù†ÙÛŒ ÛŒØ§ Ø§Ø¹Ø´Ø§Ø±ÛŒ Ù†Ø¨Ø§Ø´Ù‡\n+}\n+\n+\n+// ----------------------\n // Chain Initialization\n // ----------------------\n \n // Create the genesis block\n"
                },
                {
                    "date": 1761982746460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,11 +121,10 @@\n // Block Reward (Halving Logic)\n // ----------------------\n function getBlockReward(height) {\n   const halvings = Math.floor(height / config.halvingInterval);\n-  // Ù‡Ø± Ø¨Ø§Ø± Ú©Ù‡ Ø¨Ù‡ halvingInterval Ø¨Ø±Ø³ÛŒÙ…ØŒ Ù¾Ø§Ø¯Ø§Ø´ Ù†ØµÙ Ù…ÛŒâ€ŒØ´ÙˆØ¯\n   const reward = Math.floor(config.blockSubsidy / Math.pow(2, halvings));\n-  return reward > 0 ? reward : 0; // Ù‡ÛŒÚ†ÙˆÙ‚Øª Ù…Ù†ÙÛŒ ÛŒØ§ Ø§Ø¹Ø´Ø§Ø±ÛŒ Ù†Ø¨Ø§Ø´Ù‡\n+  return reward > 0 ? reward : 0;\n }\n \n \n // ----------------------\n@@ -278,9 +277,9 @@\n   if (coinbaseCount !== 1) return { ok: false, error: 'must have exactly one coinbase' };\n \n   // Enforce miner reward limit\n   const sumCoinbaseOutputs = tx => tx.outputs.reduce((a, o) => a + o.amount, 0);\n-  const expectedReward = config.blockSubsidy + feeTotal;\n+  const expectedReward = getBlockReward(block.index) + feeTotal;\n   if (sumCoinbaseOutputs(block.transactions[0]) > expectedReward)\n     return { ok: false, error: 'coinbase reward too high' };\n \n   return { ok: true };\n"
                },
                {
                    "date": 1761982792940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,8 +305,13 @@\n \n   fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n   console.log(`âš™ï¸ Difficulty adjust â†’ old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n   wsBroadcast({ type: 'config_update', config });\n+\n+  const currentReward = getBlockReward(block.index);\n+  const nextHalving = Math.ceil((Math.floor(block.index / config.halvingInterval) + 1) * config.halvingInterval);\n+  console.log(`ðŸ’Ž Block reward: ${currentReward} | Next halving at #${nextHalving}`);\n+\n }\n \n // ----------------------\n // REST API\n"
                },
                {
                    "date": 1761985138837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,8 +61,16 @@\n   };\n   return sha256hex(JSON.stringify(slim));\n }\n \n+// ----------------------------------------------------\n+// Proof-of-Work Target calculation (Bitcoin-style)\n+// ----------------------------------------------------\n+function getTarget(difficulty) {\n+  const maxTarget = BigInt('0x' + 'f'.repeat(64)); // 2^256 - 1\n+  return maxTarget / BigInt(difficulty);\n+}\n+\n // ----------------------\n // Helper Functions\n // ----------------------\n \n"
                },
                {
                    "date": 1761985165984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -257,8 +257,9 @@\n   // Validate block hash & difficulty\n   const root = merkleRoot(block.transactions.map(tx => tx.id));\n   const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n   const h = headerHash(header);\n+  \n   if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n   if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n \n   // Validate all transactions in block\n"
                },
                {
                    "date": 1761985186204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -257,12 +257,16 @@\n   // Validate block hash & difficulty\n   const root = merkleRoot(block.transactions.map(tx => tx.id));\n   const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n   const h = headerHash(header);\n-  \n+\n   if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n-  if (!h.startsWith('0'.repeat(block.difficulty))) return { ok: false, error: 'not meeting difficulty' };\n \n+  // âœ… Real numeric PoW check\n+  const target = getTarget(block.difficulty);\n+  const hashInt = BigInt('0x' + block.hash);\n+  if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n+\n   // Validate all transactions in block\n   const temp = new Map(UTXO);\n   let seenTxIds = new Set();\n   let coinbaseCount = 0;\n"
                },
                {
                    "date": 1761985221168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -265,8 +265,10 @@\n   const target = getTarget(block.difficulty);\n   const hashInt = BigInt('0x' + block.hash);\n   if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n \n+  console.log(`ðŸ” Validating PoW: target=${target.toString(16).slice(0, 16)}...`);\n+\n   // Validate all transactions in block\n   const temp = new Map(UTXO);\n   let seenTxIds = new Set();\n   let coinbaseCount = 0;\n"
                },
                {
                    "date": 1761985280602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -255,9 +255,16 @@\n     return { ok: false, error: 'bad timestamp' };\n \n   // Validate block hash & difficulty\n   const root = merkleRoot(block.transactions.map(tx => tx.id));\n-  const header = { index: block.index, previousHash: block.previousHash, timestamp: block.timestamp, merkleRoot: root, nonce: block.nonce, difficulty: block.difficulty };\n+  const header = {\n+    index: block.index,\n+    previousHash: block.previousHash,\n+    timestamp: block.timestamp,\n+    merkleRoot: root,\n+    nonce: block.nonce,\n+    difficulty: block.difficulty\n+  };\n   const h = headerHash(header);\n \n   if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n \n"
                },
                {
                    "date": 1761985307396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -267,9 +267,9 @@\n   const h = headerHash(header);\n \n   if (block.hash !== h) return { ok: false, error: 'bad block hash' };\n \n-  // âœ… Real numeric PoW check\n+  // âœ… Numeric Proof-of-Work check\n   const target = getTarget(block.difficulty);\n   const hashInt = BigInt('0x' + block.hash);\n   if (hashInt >= target) return { ok: false, error: 'not meeting difficulty' };\n \n"
                },
                {
                    "date": 1761985351102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -259,9 +259,9 @@\n   const header = {\n     index: block.index,\n     previousHash: block.previousHash,\n     timestamp: block.timestamp,\n-    merkleRoot: root,\n+    merkleRoot: root,       \n     nonce: block.nonce,\n     difficulty: block.difficulty\n   };\n   const h = headerHash(header);\n"
                }
            ],
            "date": 1761980246374,
            "name": "Commit-0",
            "content": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst EC = require('elliptic').ec;\nconst ec = new EC('secp256k1');\nconst http = require('http');\nconst { WebSocketServer } = require('ws');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst PORT = 3000;\nconst BLOCKS_DIR = path.join(__dirname, 'blocks');\nif (!fs.existsSync(BLOCKS_DIR)) fs.mkdirSync(BLOCKS_DIR);\n\nconst CONFIG_FILE = path.join(__dirname, 'config.json');\nlet config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));\n\nlet chain = [];\nlet mempool = [];\nlet UTXO = new Map();\n\nconst sha256hex = d => crypto.createHash('sha256').update(d).digest('hex');\nconst sha256 = d => crypto.createHash('sha256').update(d).digest();\nconst ripemd160hex = d => crypto.createHash('ripemd160').update(d).digest('hex');\nfunction pubKeyToAddress(pubKeyHex){return ripemd160hex(sha256(Buffer.from(pubKeyHex,'hex')));}\nfunction blockHash(b){return sha256hex(b.index + b.previousHash + b.timestamp + JSON.stringify(b.transactions) + b.nonce + b.difficulty);}\nfunction txHashForSigning(tx){\n  const slim = {\n    inputs: tx.inputs.map(i => ({ txid: i.txid, index: i.index })),\n    outputs: tx.outputs.map(o => ({ address: o.address, amount: o.amount }))\n  };\n  return sha256hex(JSON.stringify(slim));\n}\n\nfunction createGenesisBlock(){\n  const g={index:0,timestamp:new Date().toISOString(),transactions:[],previousHash:'0',nonce:0,difficulty:config.difficulty};\n  g.hash=blockHash(g);\n  return g;\n}\nfunction applyTxToUTXO(tx){\n  for(const inp of (tx.inputs||[])) UTXO.delete(`${inp.txid}:${inp.index}`);\n  tx.outputs.forEach((o,i)=>UTXO.set(`${tx.id}:${i}`,{address:o.address,amount:o.amount}));\n}\nfunction rebuildUTXO(){\n  UTXO.clear();\n  for(const b of chain) for(const tx of b.transactions) applyTxToUTXO(tx);\n}\nfunction loadChain(){\n  const files=fs.readdirSync(BLOCKS_DIR).filter(f=>f.endsWith('.txt')).sort();\n  if(files.length===0){\n    const g=createGenesisBlock();\n    chain.push(g);\n    fs.writeFileSync(path.join(BLOCKS_DIR,'block_0.txt'),JSON.stringify(g,null,2));\n    console.log('ðŸ§± Genesis block created');\n  }else{\n    for(const f of files) chain.push(JSON.parse(fs.readFileSync(path.join(BLOCKS_DIR,f),'utf8')));\n    console.log(`ðŸ“¦ Loaded ${chain.length} blocks`);\n  }\n  rebuildUTXO();\n}\nloadChain();\n\n// validation\nfunction validateTx(tx, utxoSet=UTXO){\n  const isCoinbase=!tx.inputs||tx.inputs.length===0;\n  if(isCoinbase)return{ok:true,fee:0};\n  let inSum=0,outSum=0;\n  const msgHash=txHashForSigning(tx);\n  for(const inp of tx.inputs){\n    const key=`${inp.txid}:${inp.index}`;\n    const u=utxoSet.get(key);\n    if(!u)return{ok:false,error:`missing utxo ${key}`};\n    const addr=pubKeyToAddress(inp.pubKey);\n    if(addr!==u.address)return{ok:false,error:'pubKey mismatch'};\n    const pub=ec.keyFromPublic(inp.pubKey,'hex');\n    if(!pub.verify(msgHash,inp.sig))return{ok:false,error:'bad signature'};\n    inSum+=u.amount;\n  }\n  for(const o of tx.outputs){\n    if(typeof o.amount!=='number'||o.amount<=0)return{ok:false,error:'invalid output'};\n    outSum+=o.amount;\n  }\n  const fee=inSum-outSum;\n  if(fee<0)return{ok:false,error:'negative fee'};\n  return{ok:true,fee};\n}\n\nfunction validateBlock(block){\n  const last=chain[chain.length-1];\n  if(block.previousHash!==last.hash)return{ok:false,error:'prev hash mismatch'};\n  if(block.hash!==blockHash(block))return{ok:false,error:'bad block hash'};\n  if(!block.hash.startsWith('0'.repeat(block.difficulty)))return{ok:false,error:'not meeting difficulty'};\n  const temp=new Map(UTXO);\n  for(const tx of block.transactions){\n    const v=validateTx(tx,temp);\n    if(!v.ok)return v;\n    for(const i of(tx.inputs||[]))temp.delete(`${i.txid}:${i.index}`);\n    tx.outputs.forEach((o,i)=>temp.set(`${tx.id}:${i}`,{address:o.address,amount:o.amount}));\n  }\n  return{ok:true};\n}\n\n// difficulty adjustment (real)\nfunction adjustDifficulty() {\n  const n = config.adjustEvery;\n  if (chain.length <= n) return;\n\n  const lastN = chain.slice(-n);\n  const times = lastN.map(b => new Date(b.timestamp).getTime());\n  const duration = (times[times.length - 1] - times[0]) / 1000; // seconds\n  const avgTime = duration / (n - 1);\n  const target = config.targetBlockTimeSec;\n  const ratio = avgTime / target;\n\n  // log previous difficulty\n  const oldDiff = config.difficulty;\n\n  if (ratio < 0.9) config.difficulty++;        // blocks too fast\n  else if (ratio > 1.1) config.difficulty = Math.max(1, config.difficulty - 1);\n\n  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n  console.log(`âš™ï¸ Difficulty adjust: old=${oldDiff}, new=${config.difficulty}, avgTime=${avgTime.toFixed(2)}s`);\n  wsBroadcast({ type:'config_update', config });\n}\n\n// API\napp.get('/chain',(req,res)=>res.json({length:chain.length,chain}));\napp.get('/mempool',(req,res)=>res.json({mempool}));\napp.get('/config',(req,res)=>res.json(config));\n\napp.post('/transactions',(req,res)=>{\n  const tx=req.body;\n  tx.id=tx.id||sha256hex(JSON.stringify(tx)+Date.now());\n  const v=validateTx(tx);\n  if(!v.ok)return res.status(400).json({error:v.error});\n  tx.fee=v.fee;\n  mempool.push(tx);\n  console.log(`ðŸ’° TX added: ${tx.id} | fee=${v.fee}`);\n  wsBroadcast({type:'mempool_tx',tx});\n  res.json({status:'added',id:tx.id});\n});\n\napp.post('/blocks',(req,res)=>{\n  const block=req.body;\n  const v=validateBlock(block);\n  if(!v.ok)return res.status(400).json({error:v.error});\n\n  chain.push(block);\n  fs.writeFileSync(path.join(BLOCKS_DIR,`block_${block.index}.txt`),JSON.stringify(block,null,2));\n  for(const tx of block.transactions)applyTxToUTXO(tx);\n  const ids=new Set(block.transactions.map(t=>t.id));\n  mempool=mempool.filter(t=>!ids.has(t.id));\n  console.log(`ðŸ§± Block #${block.index} accepted (diff=${block.difficulty})`);\n  wsBroadcast({type:'new_block',header:{index:block.index,hash:block.hash,difficulty:block.difficulty,txs:block.transactions.length}});\n  adjustDifficulty();\n  res.json({status:'block accepted',index:block.index});\n});\n\n// WebSocket server\nconst server = http.createServer(app);\nconst wss = new WebSocketServer({ server });\nfunction wsBroadcast(obj){\n  const msg=JSON.stringify(obj);\n  wss.clients.forEach(c=>{if(c.readyState===1)c.send(msg);});\n}\nwss.on('connection',(ws)=>{\n  console.log('ðŸ”Œ Miner connected');\n  ws.send(JSON.stringify({type:'hello',height:chain.length,diff:config.difficulty}));\n});\nserver.listen(PORT,()=>console.log(`ðŸš€ Node running on http://localhost:${PORT}`));\n"
        }
    ]
}