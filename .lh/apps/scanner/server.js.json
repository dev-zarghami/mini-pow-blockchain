{
    "sourceFile": "apps/scanner/server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1761986979595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761986985698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,10 +3,10 @@\n const axios = require('axios');\n const WebSocket = require('ws');\n const path = require('path');\n \n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n+const NODE_HTTP = 'http://localhost:4000';\n+const NODE_WS = 'ws://localhost:4000';\n const PORT = 4000; // Ø±Ø§Ø¨Ø· Ø¯Ø± Ù¾ÙˆØ±Øª 4000\n \n const app = express();\n app.use(express.static(path.join(__dirname, 'public')));\n"
                },
                {
                    "date": 1761986992781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,11 @@\n-//------------------------------------------------------\n const express = require('express');\n const axios = require('axios');\n const WebSocket = require('ws');\n const path = require('path');\n \n-const NODE_HTTP = 'http://localhost:4000';\n-const NODE_WS = 'ws://localhost:4000';\n+const NODE_HTTP = 'http://localhost:3000';\n+const NODE_WS = 'ws://localhost:3000';\n const PORT = 4000; // Ø±Ø§Ø¨Ø· Ø¯Ø± Ù¾ÙˆØ±Øª 4000\n \n const app = express();\n app.use(express.static(path.join(__dirname, 'public')));\n"
                },
                {
                    "date": 1761986998722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n const path = require('path');\n \n const NODE_HTTP = 'http://localhost:3000';\n const NODE_WS = 'ws://localhost:3000';\n-const PORT = 4000; // Ø±Ø§Ø¨Ø· Ø¯Ø± Ù¾ÙˆØ±Øª 4000\n+const PORT = 4000;\n \n const app = express();\n app.use(express.static(path.join(__dirname, 'public')));\n \n@@ -120,7 +120,7 @@\n       wss.clients.forEach(c => {\n         if (c.readyState === 1) c.send(JSON.stringify(obj));\n       });\n     }\n-  } catch {}\n+  } catch { }\n });\n nodeWS.on('close', () => console.log('Node WS closed.'));\n"
                },
                {
                    "date": 1761988689377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,8 +91,26 @@\n \n // ----------------------\n // API endpoints\n // ----------------------\n+app.get('/api/chain', async (req, res) => {\n+  try {\n+    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n+    res.json(data);\n+  } catch (e) {\n+    res.status(500).json({ error: e.message });\n+  }\n+});\n+\n+app.get('/api/mempool', async (req, res) => {\n+  try {\n+    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n+    res.json(data);\n+  } catch (e) {\n+    res.status(500).json({ error: e.message });\n+  }\n+});\n+\n app.get('/api/address/:addr', async (req, res) => {\n   try {\n     await refreshData();\n     const data = scanAddress(req.params.addr);\n"
                },
                {
                    "date": 1761991237232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,12 @@\n+/**\n+ * ðŸŒ Blockchain Scanner & Address Explorer\n+ * ----------------------------------------\n+ * - Syncs with node via REST + WebSocket\n+ * - Tracks balances & tx history for any address\n+ * - Serves a simple live web UI on port 4000\n+ */\n+\n const express = require('express');\n const axios = require('axios');\n const WebSocket = require('ws');\n const path = require('path');\n@@ -14,9 +22,9 @@\n let mempool = [];\n let tipIndex = 0;\n \n // ----------------------\n-// Helpers\n+// Fetch & cache data\n // ----------------------\n async function refreshData() {\n   const [chainRes, memRes] = await Promise.all([\n     axios.get(`${NODE_HTTP}/chain`),\n@@ -26,36 +34,37 @@\n   mempool = memRes.data.mempool || [];\n   tipIndex = chain.length - 1;\n }\n \n+// ----------------------\n+// Address scanner\n+// ----------------------\n function scanAddress(address) {\n-  const UTXOs = [];\n+  const outputs = new Map(); // txid:index -> {address, amount}\n   const txHistory = [];\n \n-  // map outputs by outpoint\n-  const outputs = new Map();\n-\n-  // iterate all txs\n   for (const block of chain) {\n     for (const tx of block.transactions) {\n-      // record outputs\n+      // Add all new outputs\n       tx.outputs.forEach((o, i) => {\n         outputs.set(`${tx.id}:${i}`, { ...o, txid: tx.id, index: i, block: block.index });\n       });\n \n-      // spend inputs\n+      // Track spent outputs & \"sent\" amount\n+      let sent = 0;\n       for (const inp of tx.inputs || []) {\n-        outputs.delete(`${inp.txid}:${inp.index}`);\n+        const key = `${inp.txid}:${inp.index}`;\n+        const prev = outputs.get(key);\n+        if (prev && prev.address === address) {\n+          sent += prev.amount;\n+        }\n+        outputs.delete(key);\n       }\n \n-      // check if address is involved\n+      // Track \"received\"\n       const received = tx.outputs.filter(o => o.address === address)\n         .reduce((a, b) => a + b.amount, 0);\n-      let sent = 0;\n-      for (const inp of tx.inputs || []) {\n-        const prev = outputs.get(`${inp.txid}:${inp.index}`);\n-        if (prev && prev.address === address) sent += prev.amount;\n-      }\n+\n       if (received || sent) {\n         txHistory.push({\n           txid: tx.id,\n           block: block.index,\n@@ -66,66 +75,65 @@\n       }\n     }\n   }\n \n-  // confirmed UTXOs\n-  for (const [key, o] of outputs.entries()) {\n-    if (o.address === address) UTXOs.push(o);\n+  // Remaining UTXOs\n+  const utxos = [];\n+  for (const [_, o] of outputs.entries()) {\n+    if (o.address === address) utxos.push(o);\n   }\n \n-  // mempool: similar (simplified)\n+  // Include mempool transactions (pending)\n   for (const tx of mempool) {\n     const received = tx.outputs.filter(o => o.address === address)\n       .reduce((a, b) => a + b.amount, 0);\n     if (received) {\n       txHistory.push({ txid: tx.id, block: null, received, sent: 0, net: received, mempool: true });\n       tx.outputs.forEach((o, i) => {\n-        if (o.address === address) UTXOs.push({ ...o, txid: tx.id, index: i, block: null });\n+        if (o.address === address) utxos.push({ ...o, txid: tx.id, index: i, block: null });\n       });\n     }\n   }\n \n-  const balance = UTXOs.reduce((a, u) => a + u.amount, 0);\n+  const balance = utxos.reduce((a, u) => a + u.amount, 0);\n \n-  return { balance, txHistory: txHistory.reverse(), utxos: UTXOs };\n+  return { balance, txHistory: txHistory.reverse(), utxos };\n }\n \n // ----------------------\n-// API endpoints\n+// REST API\n // ----------------------\n-app.get('/api/chain', async (req, res) => {\n+app.get('/api/address/:addr', async (req, res) => {\n   try {\n-    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n+    await refreshData();\n+    const data = scanAddress(req.params.addr);\n     res.json(data);\n   } catch (e) {\n+    console.error(e);\n     res.status(500).json({ error: e.message });\n   }\n });\n \n-app.get('/api/mempool', async (req, res) => {\n+app.get('/api/chain', async (_, res) => {\n   try {\n-    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n+    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n     res.json(data);\n-  } catch (e) {\n-    res.status(500).json({ error: e.message });\n-  }\n+  } catch (e) { res.status(500).json({ error: e.message }); }\n });\n \n-app.get('/api/address/:addr', async (req, res) => {\n+app.get('/api/mempool', async (_, res) => {\n   try {\n-    await refreshData();\n-    const data = scanAddress(req.params.addr);\n+    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n     res.json(data);\n-  } catch (e) {\n-    console.error(e);\n-    res.status(500).json({ error: e.message });\n-  }\n+  } catch (e) { res.status(500).json({ error: e.message }); }\n });\n \n // ----------------------\n-// WebSocket bridge\n+// WebSocket Bridge (Node â†’ UI)\n // ----------------------\n-const server = app.listen(PORT, () => console.log(`ðŸŒ Scanner UI at http://localhost:${PORT}`));\n+const server = app.listen(PORT, () =>\n+  console.log(`ðŸŒ Scanner UI running at http://localhost:${PORT}`)\n+);\n \n const wss = new WebSocket.Server({ server });\n const nodeWS = new WebSocket(NODE_WS);\n \n@@ -133,12 +141,12 @@\n nodeWS.on('message', msg => {\n   try {\n     const obj = JSON.parse(msg.toString());\n     if (['new_block', 'mempool_tx', 'config_update'].includes(obj.type)) {\n-      // broadcast event to connected UI clients\n+      // forward to browser UIs\n       wss.clients.forEach(c => {\n         if (c.readyState === 1) c.send(JSON.stringify(obj));\n       });\n     }\n-  } catch { }\n+  } catch {}\n });\n-nodeWS.on('close', () => console.log('Node WS closed.'));\n+nodeWS.on('close', () => console.log('âŒ Node WS closed.'));\n"
                },
                {
                    "date": 1761995431127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,152 +1,37 @@\n-/**\n- * ðŸŒ Blockchain Scanner & Address Explorer\n- * ----------------------------------------\n- * - Syncs with node via REST + WebSocket\n- * - Tracks balances & tx history for any address\n- * - Serves a simple live web UI on port 4000\n- */\n+// apps/scanner/server.js\n+// Simple scanner to query node and display address balance / tx history\n+// Run: node apps/scanner/server.js\n \n const express = require('express');\n const axios = require('axios');\n-const WebSocket = require('ws');\n-const path = require('path');\n+const bodyParser = require('body-parser');\n \n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n-const PORT = 4000;\n-\n const app = express();\n-app.use(express.static(path.join(__dirname, 'public')));\n+app.use(bodyParser.json());\n \n-let chain = [];\n-let mempool = [];\n-let tipIndex = 0;\n+const NODE = 'http://localhost:3000';\n \n-// ----------------------\n-// Fetch & cache data\n-// ----------------------\n-async function refreshData() {\n-  const [chainRes, memRes] = await Promise.all([\n-    axios.get(`${NODE_HTTP}/chain`),\n-    axios.get(`${NODE_HTTP}/mempool`)\n-  ]);\n-  chain = chainRes.data.chain || [];\n-  mempool = memRes.data.mempool || [];\n-  tipIndex = chain.length - 1;\n-}\n-\n-// ----------------------\n-// Address scanner\n-// ----------------------\n-function scanAddress(address) {\n-  const outputs = new Map(); // txid:index -> {address, amount}\n-  const txHistory = [];\n-\n-  for (const block of chain) {\n-    for (const tx of block.transactions) {\n-      // Add all new outputs\n-      tx.outputs.forEach((o, i) => {\n-        outputs.set(`${tx.id}:${i}`, { ...o, txid: tx.id, index: i, block: block.index });\n-      });\n-\n-      // Track spent outputs & \"sent\" amount\n-      let sent = 0;\n-      for (const inp of tx.inputs || []) {\n-        const key = `${inp.txid}:${inp.index}`;\n-        const prev = outputs.get(key);\n-        if (prev && prev.address === address) {\n-          sent += prev.amount;\n+app.get('/api/address/:addr', async (req, res) => {\n+  const addr = req.params.addr;\n+  try {\n+    const utx = await axios.get(`${NODE}/utxos/${addr}`);\n+    // build history by scanning chain\n+    const chain = (await axios.get(`${NODE}/chain`)).data;\n+    const txHistory = [];\n+    for (const b of chain) {\n+      for (const t of b.transactions) {\n+        // include txs that touch address\n+        const touches = t.outputs.some(o => o.address === addr) || (t.inputs || []).some(i => i.pubKey && i.pubKey === addr);\n+        if (touches) {\n+          txHistory.push({ tx: t, blockHeight: b.index });\n         }\n-        outputs.delete(key);\n       }\n-\n-      // Track \"received\"\n-      const received = tx.outputs.filter(o => o.address === address)\n-        .reduce((a, b) => a + b.amount, 0);\n-\n-      if (received || sent) {\n-        txHistory.push({\n-          txid: tx.id,\n-          block: block.index,\n-          received,\n-          sent,\n-          net: received - sent\n-        });\n-      }\n     }\n-  }\n-\n-  // Remaining UTXOs\n-  const utxos = [];\n-  for (const [_, o] of outputs.entries()) {\n-    if (o.address === address) utxos.push(o);\n-  }\n-\n-  // Include mempool transactions (pending)\n-  for (const tx of mempool) {\n-    const received = tx.outputs.filter(o => o.address === address)\n-      .reduce((a, b) => a + b.amount, 0);\n-    if (received) {\n-      txHistory.push({ txid: tx.id, block: null, received, sent: 0, net: received, mempool: true });\n-      tx.outputs.forEach((o, i) => {\n-        if (o.address === address) utxos.push({ ...o, txid: tx.id, index: i, block: null });\n-      });\n-    }\n-  }\n-\n-  const balance = utxos.reduce((a, u) => a + u.amount, 0);\n-\n-  return { balance, txHistory: txHistory.reverse(), utxos };\n-}\n-\n-// ----------------------\n-// REST API\n-// ----------------------\n-app.get('/api/address/:addr', async (req, res) => {\n-  try {\n-    await refreshData();\n-    const data = scanAddress(req.params.addr);\n-    res.json(data);\n+    const balance = utx.data.utxos.reduce((s,u) => s + u.amount, 0);\n+    res.json({ address: addr, balance, utxos: utx.data.utxos, txHistory });\n   } catch (e) {\n-    console.error(e);\n     res.status(500).json({ error: e.message });\n   }\n });\n \n-app.get('/api/chain', async (_, res) => {\n-  try {\n-    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n-    res.json(data);\n-  } catch (e) { res.status(500).json({ error: e.message }); }\n-});\n-\n-app.get('/api/mempool', async (_, res) => {\n-  try {\n-    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n-    res.json(data);\n-  } catch (e) { res.status(500).json({ error: e.message }); }\n-});\n-\n-// ----------------------\n-// WebSocket Bridge (Node â†’ UI)\n-// ----------------------\n-const server = app.listen(PORT, () =>\n-  console.log(`ðŸŒ Scanner UI running at http://localhost:${PORT}`)\n-);\n-\n-const wss = new WebSocket.Server({ server });\n-const nodeWS = new WebSocket(NODE_WS);\n-\n-nodeWS.on('open', () => console.log('ðŸ”Œ Connected to blockchain node'));\n-nodeWS.on('message', msg => {\n-  try {\n-    const obj = JSON.parse(msg.toString());\n-    if (['new_block', 'mempool_tx', 'config_update'].includes(obj.type)) {\n-      // forward to browser UIs\n-      wss.clients.forEach(c => {\n-        if (c.readyState === 1) c.send(JSON.stringify(obj));\n-      });\n-    }\n-  } catch {}\n-});\n-nodeWS.on('close', () => console.log('âŒ Node WS closed.'));\n+app.listen(4000, () => console.log('Scanner started on http://localhost:4000'));\n"
                },
                {
                    "date": 1761995961107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,37 +1,152 @@\n-// apps/scanner/server.js\n-// Simple scanner to query node and display address balance / tx history\n-// Run: node apps/scanner/server.js\n+/**\n+ * ðŸŒ Blockchain Scanner & Address Explorer\n+ * ----------------------------------------\n+ * - Syncs with node via REST + WebSocket\n+ * - Tracks balances & tx history for any address\n+ * - Serves a simple live web UI on port 4000\n+ */\n \n const express = require('express');\n const axios = require('axios');\n-const bodyParser = require('body-parser');\n+const WebSocket = require('ws');\n+const path = require('path');\n \n+const NODE_HTTP = 'http://localhost:3000';\n+const NODE_WS = 'ws://localhost:3000';\n+const PORT = 4000;\n+\n const app = express();\n-app.use(bodyParser.json());\n+app.use(express.static(path.join(__dirname, 'public')));\n \n-const NODE = 'http://localhost:3000';\n+let chain = [];\n+let mempool = [];\n+let tipIndex = 0;\n \n-app.get('/api/address/:addr', async (req, res) => {\n-  const addr = req.params.addr;\n-  try {\n-    const utx = await axios.get(`${NODE}/utxos/${addr}`);\n-    // build history by scanning chain\n-    const chain = (await axios.get(`${NODE}/chain`)).data;\n-    const txHistory = [];\n-    for (const b of chain) {\n-      for (const t of b.transactions) {\n-        // include txs that touch address\n-        const touches = t.outputs.some(o => o.address === addr) || (t.inputs || []).some(i => i.pubKey && i.pubKey === addr);\n-        if (touches) {\n-          txHistory.push({ tx: t, blockHeight: b.index });\n+// ----------------------\n+// Fetch & cache data\n+// ----------------------\n+async function refreshData() {\n+  const [chainRes, memRes] = await Promise.all([\n+    axios.get(`${NODE_HTTP}/chain`),\n+    axios.get(`${NODE_HTTP}/mempool`)\n+  ]);\n+  chain = chainRes.data.chain || [];\n+  mempool = memRes.data.mempool || [];\n+  tipIndex = chain.length - 1;\n+}\n+\n+// ----------------------\n+// Address scanner\n+// ----------------------\n+function scanAddress(address) {\n+  const outputs = new Map(); // txid:index -> {address, amount}\n+  const txHistory = [];\n+\n+  for (const block of chain) {\n+    for (const tx of block.transactions) {\n+      // Add all new outputs\n+      tx.outputs.forEach((o, i) => {\n+        outputs.set(`${tx.id}:${i}`, { ...o, txid: tx.id, index: i, block: block.index });\n+      });\n+\n+      // Track spent outputs & \"sent\" amount\n+      let sent = 0;\n+      for (const inp of tx.inputs || []) {\n+        const key = `${inp.txid}:${inp.index}`;\n+        const prev = outputs.get(key);\n+        if (prev && prev.address === address) {\n+          sent += prev.amount;\n         }\n+        outputs.delete(key);\n       }\n+\n+      // Track \"received\"\n+      const received = tx.outputs.filter(o => o.address === address)\n+        .reduce((a, b) => a + b.amount, 0);\n+\n+      if (received || sent) {\n+        txHistory.push({\n+          txid: tx.id,\n+          block: block.index,\n+          received,\n+          sent,\n+          net: received - sent\n+        });\n+      }\n     }\n-    const balance = utx.data.utxos.reduce((s,u) => s + u.amount, 0);\n-    res.json({ address: addr, balance, utxos: utx.data.utxos, txHistory });\n+  }\n+\n+  // Remaining UTXOs\n+  const utxos = [];\n+  for (const [_, o] of outputs.entries()) {\n+    if (o.address === address) utxos.push(o);\n+  }\n+\n+  // Include mempool transactions (pending)\n+  for (const tx of mempool) {\n+    const received = tx.outputs.filter(o => o.address === address)\n+      .reduce((a, b) => a + b.amount, 0);\n+    if (received) {\n+      txHistory.push({ txid: tx.id, block: null, received, sent: 0, net: received, mempool: true });\n+      tx.outputs.forEach((o, i) => {\n+        if (o.address === address) utxos.push({ ...o, txid: tx.id, index: i, block: null });\n+      });\n+    }\n+  }\n+\n+  const balance = utxos.reduce((a, u) => a + u.amount, 0);\n+\n+  return { balance, txHistory: txHistory.reverse(), utxos };\n+}\n+\n+// ----------------------\n+// REST API\n+// ----------------------\n+app.get('/api/address/:addr', async (req, res) => {\n+  try {\n+    await refreshData();\n+    const data = scanAddress(req.params.addr);\n+    res.json(data);\n   } catch (e) {\n+    console.error(e);\n     res.status(500).json({ error: e.message });\n   }\n });\n \n-app.listen(4000, () => console.log('Scanner started on http://localhost:4000'));\n+app.get('/api/chain', async (_, res) => {\n+  try {\n+    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n+    res.json(data);\n+  } catch (e) { res.status(500).json({ error: e.message }); }\n+});\n+\n+app.get('/api/mempool', async (_, res) => {\n+  try {\n+    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n+    res.json(data);\n+  } catch (e) { res.status(500).json({ error: e.message }); }\n+});\n+\n+// ----------------------\n+// WebSocket Bridge (Node â†’ UI)\n+// ----------------------\n+const server = app.listen(PORT, () =>\n+  console.log(`ðŸŒ Scanner UI running at http://localhost:${PORT}`)\n+);\n+\n+const wss = new WebSocket.Server({ server });\n+const nodeWS = new WebSocket(NODE_WS);\n+\n+nodeWS.on('open', () => console.log('ðŸ”Œ Connected to blockchain node'));\n+nodeWS.on('message', msg => {\n+  try {\n+    const obj = JSON.parse(msg.toString());\n+    if (['new_block', 'mempool_tx', 'config_update'].includes(obj.type)) {\n+      // forward to browser UIs\n+      wss.clients.forEach(c => {\n+        if (c.readyState === 1) c.send(JSON.stringify(obj));\n+      });\n+    }\n+  } catch {}\n+});\n+nodeWS.on('close', () => console.log('âŒ Node WS closed.'));\n"
                },
                {
                    "date": 1761996014240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,152 +1,37 @@\n-/**\n- * ðŸŒ Blockchain Scanner & Address Explorer\n- * ----------------------------------------\n- * - Syncs with node via REST + WebSocket\n- * - Tracks balances & tx history for any address\n- * - Serves a simple live web UI on port 4000\n- */\n+// apps/scanner/server.js\n+// Simple scanner to query node and display address balance / tx history\n+// Run: node apps/scanner/server.js\n \n const express = require('express');\n const axios = require('axios');\n-const WebSocket = require('ws');\n-const path = require('path');\n+const bodyParser = require('body-parser');\n \n-const NODE_HTTP = 'http://localhost:3000';\n-const NODE_WS = 'ws://localhost:3000';\n-const PORT = 4000;\n-\n const app = express();\n-app.use(express.static(path.join(__dirname, 'public')));\n+app.use(bodyParser.json());\n \n-let chain = [];\n-let mempool = [];\n-let tipIndex = 0;\n+const NODE = 'http://localhost:3000';\n \n-// ----------------------\n-// Fetch & cache data\n-// ----------------------\n-async function refreshData() {\n-  const [chainRes, memRes] = await Promise.all([\n-    axios.get(`${NODE_HTTP}/chain`),\n-    axios.get(`${NODE_HTTP}/mempool`)\n-  ]);\n-  chain = chainRes.data.chain || [];\n-  mempool = memRes.data.mempool || [];\n-  tipIndex = chain.length - 1;\n-}\n-\n-// ----------------------\n-// Address scanner\n-// ----------------------\n-function scanAddress(address) {\n-  const outputs = new Map(); // txid:index -> {address, amount}\n-  const txHistory = [];\n-\n-  for (const block of chain) {\n-    for (const tx of block.transactions) {\n-      // Add all new outputs\n-      tx.outputs.forEach((o, i) => {\n-        outputs.set(`${tx.id}:${i}`, { ...o, txid: tx.id, index: i, block: block.index });\n-      });\n-\n-      // Track spent outputs & \"sent\" amount\n-      let sent = 0;\n-      for (const inp of tx.inputs || []) {\n-        const key = `${inp.txid}:${inp.index}`;\n-        const prev = outputs.get(key);\n-        if (prev && prev.address === address) {\n-          sent += prev.amount;\n+app.get('/api/address/:addr', async (req, res) => {\n+  const addr = req.params.addr;\n+  try {\n+    const utx = await axios.get(`${NODE}/utxos/${addr}`);\n+    // build history by scanning chain\n+    const chain = (await axios.get(`${NODE}/chain`)).data;\n+    const txHistory = [];\n+    for (const b of chain) {\n+      for (const t of b.transactions) {\n+        // include txs that touch address\n+        const touches = t.outputs.some(o => o.address === addr) || (t.inputs || []).some(i => i.pubKey && i.pubKey === addr);\n+        if (touches) {\n+          txHistory.push({ tx: t, blockHeight: b.index });\n         }\n-        outputs.delete(key);\n       }\n-\n-      // Track \"received\"\n-      const received = tx.outputs.filter(o => o.address === address)\n-        .reduce((a, b) => a + b.amount, 0);\n-\n-      if (received || sent) {\n-        txHistory.push({\n-          txid: tx.id,\n-          block: block.index,\n-          received,\n-          sent,\n-          net: received - sent\n-        });\n-      }\n     }\n-  }\n-\n-  // Remaining UTXOs\n-  const utxos = [];\n-  for (const [_, o] of outputs.entries()) {\n-    if (o.address === address) utxos.push(o);\n-  }\n-\n-  // Include mempool transactions (pending)\n-  for (const tx of mempool) {\n-    const received = tx.outputs.filter(o => o.address === address)\n-      .reduce((a, b) => a + b.amount, 0);\n-    if (received) {\n-      txHistory.push({ txid: tx.id, block: null, received, sent: 0, net: received, mempool: true });\n-      tx.outputs.forEach((o, i) => {\n-        if (o.address === address) utxos.push({ ...o, txid: tx.id, index: i, block: null });\n-      });\n-    }\n-  }\n-\n-  const balance = utxos.reduce((a, u) => a + u.amount, 0);\n-\n-  return { balance, txHistory: txHistory.reverse(), utxos };\n-}\n-\n-// ----------------------\n-// REST API\n-// ----------------------\n-app.get('/api/address/:addr', async (req, res) => {\n-  try {\n-    await refreshData();\n-    const data = scanAddress(req.params.addr);\n-    res.json(data);\n+    const balance = utx.data.utxos.reduce((s,u) => s + u.amount, 0);\n+    res.json({ address: addr, balance, utxos: utx.data.utxos, txHistory });\n   } catch (e) {\n-    console.error(e);\n     res.status(500).json({ error: e.message });\n   }\n });\n \n-app.get('/api/chain', async (_, res) => {\n-  try {\n-    const { data } = await axios.get(`${NODE_HTTP}/chain`);\n-    res.json(data);\n-  } catch (e) { res.status(500).json({ error: e.message }); }\n-});\n-\n-app.get('/api/mempool', async (_, res) => {\n-  try {\n-    const { data } = await axios.get(`${NODE_HTTP}/mempool`);\n-    res.json(data);\n-  } catch (e) { res.status(500).json({ error: e.message }); }\n-});\n-\n-// ----------------------\n-// WebSocket Bridge (Node â†’ UI)\n-// ----------------------\n-const server = app.listen(PORT, () =>\n-  console.log(`ðŸŒ Scanner UI running at http://localhost:${PORT}`)\n-);\n-\n-const wss = new WebSocket.Server({ server });\n-const nodeWS = new WebSocket(NODE_WS);\n-\n-nodeWS.on('open', () => console.log('ðŸ”Œ Connected to blockchain node'));\n-nodeWS.on('message', msg => {\n-  try {\n-    const obj = JSON.parse(msg.toString());\n-    if (['new_block', 'mempool_tx', 'config_update'].includes(obj.type)) {\n-      // forward to browser UIs\n-      wss.clients.forEach(c => {\n-        if (c.readyState === 1) c.send(JSON.stringify(obj));\n-      });\n-    }\n-  } catch {}\n-});\n-nodeWS.on('close', () => console.log('âŒ Node WS closed.'));\n+app.listen(4000, () => console.log('Scanner started on http://localhost:4000'));\n"
                },
                {
                    "date": 1761996856030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,37 +1,30 @@\n // apps/scanner/server.js\n-// Simple scanner to query node and display address balance / tx history\n+// Quick API to view address balance and tx history\n // Run: node apps/scanner/server.js\n \n const express = require('express');\n const axios = require('axios');\n-const bodyParser = require('body-parser');\n \n+const NODE = process.env.NODE || 'http://localhost:3000';\n const app = express();\n-app.use(bodyParser.json());\n \n-const NODE = 'http://localhost:3000';\n-\n-app.get('/api/address/:addr', async (req, res) => {\n-  const addr = req.params.addr;\n+app.get('/api/address/:addr', async (req,res)=>{\n   try {\n-    const utx = await axios.get(`${NODE}/utxos/${addr}`);\n-    // build history by scanning chain\n+    const addr = req.params.addr;\n+    const utx = (await axios.get(`${NODE}/utxos/${addr}`)).data.utxos;\n     const chain = (await axios.get(`${NODE}/chain`)).data;\n-    const txHistory = [];\n+    const hist = [];\n     for (const b of chain) {\n       for (const t of b.transactions) {\n-        // include txs that touch address\n-        const touches = t.outputs.some(o => o.address === addr) || (t.inputs || []).some(i => i.pubKey && i.pubKey === addr);\n-        if (touches) {\n-          txHistory.push({ tx: t, blockHeight: b.index });\n-        }\n+        const touches = t.outputs.some(o => o.address === addr) || (t.inputs||[]).some(i => i.pubKey && i.pubKey === addr);\n+        if (touches) hist.push({ tx: t, blockHeight: b.index });\n       }\n     }\n-    const balance = utx.data.utxos.reduce((s,u) => s + u.amount, 0);\n-    res.json({ address: addr, balance, utxos: utx.data.utxos, txHistory });\n-  } catch (e) {\n+    const balance = utx.reduce((s,u)=>s+u.amount,0);\n+    res.json({ address: addr, balance, utxos: utx, txHistory: hist });\n+  } catch(e) {\n     res.status(500).json({ error: e.message });\n   }\n });\n \n-app.listen(4000, () => console.log('Scanner started on http://localhost:4000'));\n+app.listen(4000, ()=> console.log('[SCANNER] http://localhost:4000'));\n"
                }
            ],
            "date": 1761986979595,
            "name": "Commit-0",
            "content": "//------------------------------------------------------\nconst express = require('express');\nconst axios = require('axios');\nconst WebSocket = require('ws');\nconst path = require('path');\n\nconst NODE_HTTP = 'http://localhost:3000';\nconst NODE_WS = 'ws://localhost:3000';\nconst PORT = 4000; // Ø±Ø§Ø¨Ø· Ø¯Ø± Ù¾ÙˆØ±Øª 4000\n\nconst app = express();\napp.use(express.static(path.join(__dirname, 'public')));\n\nlet chain = [];\nlet mempool = [];\nlet tipIndex = 0;\n\n// ----------------------\n// Helpers\n// ----------------------\nasync function refreshData() {\n  const [chainRes, memRes] = await Promise.all([\n    axios.get(`${NODE_HTTP}/chain`),\n    axios.get(`${NODE_HTTP}/mempool`)\n  ]);\n  chain = chainRes.data.chain || [];\n  mempool = memRes.data.mempool || [];\n  tipIndex = chain.length - 1;\n}\n\nfunction scanAddress(address) {\n  const UTXOs = [];\n  const txHistory = [];\n\n  // map outputs by outpoint\n  const outputs = new Map();\n\n  // iterate all txs\n  for (const block of chain) {\n    for (const tx of block.transactions) {\n      // record outputs\n      tx.outputs.forEach((o, i) => {\n        outputs.set(`${tx.id}:${i}`, { ...o, txid: tx.id, index: i, block: block.index });\n      });\n\n      // spend inputs\n      for (const inp of tx.inputs || []) {\n        outputs.delete(`${inp.txid}:${inp.index}`);\n      }\n\n      // check if address is involved\n      const received = tx.outputs.filter(o => o.address === address)\n        .reduce((a, b) => a + b.amount, 0);\n      let sent = 0;\n      for (const inp of tx.inputs || []) {\n        const prev = outputs.get(`${inp.txid}:${inp.index}`);\n        if (prev && prev.address === address) sent += prev.amount;\n      }\n      if (received || sent) {\n        txHistory.push({\n          txid: tx.id,\n          block: block.index,\n          received,\n          sent,\n          net: received - sent\n        });\n      }\n    }\n  }\n\n  // confirmed UTXOs\n  for (const [key, o] of outputs.entries()) {\n    if (o.address === address) UTXOs.push(o);\n  }\n\n  // mempool: similar (simplified)\n  for (const tx of mempool) {\n    const received = tx.outputs.filter(o => o.address === address)\n      .reduce((a, b) => a + b.amount, 0);\n    if (received) {\n      txHistory.push({ txid: tx.id, block: null, received, sent: 0, net: received, mempool: true });\n      tx.outputs.forEach((o, i) => {\n        if (o.address === address) UTXOs.push({ ...o, txid: tx.id, index: i, block: null });\n      });\n    }\n  }\n\n  const balance = UTXOs.reduce((a, u) => a + u.amount, 0);\n\n  return { balance, txHistory: txHistory.reverse(), utxos: UTXOs };\n}\n\n// ----------------------\n// API endpoints\n// ----------------------\napp.get('/api/address/:addr', async (req, res) => {\n  try {\n    await refreshData();\n    const data = scanAddress(req.params.addr);\n    res.json(data);\n  } catch (e) {\n    console.error(e);\n    res.status(500).json({ error: e.message });\n  }\n});\n\n// ----------------------\n// WebSocket bridge\n// ----------------------\nconst server = app.listen(PORT, () => console.log(`ðŸŒ Scanner UI at http://localhost:${PORT}`));\n\nconst wss = new WebSocket.Server({ server });\nconst nodeWS = new WebSocket(NODE_WS);\n\nnodeWS.on('open', () => console.log('ðŸ”Œ Connected to blockchain node'));\nnodeWS.on('message', msg => {\n  try {\n    const obj = JSON.parse(msg.toString());\n    if (['new_block', 'mempool_tx', 'config_update'].includes(obj.type)) {\n      // broadcast event to connected UI clients\n      wss.clients.forEach(c => {\n        if (c.readyState === 1) c.send(JSON.stringify(obj));\n      });\n    }\n  } catch {}\n});\nnodeWS.on('close', () => console.log('Node WS closed.'));\n"
        }
    ]
}